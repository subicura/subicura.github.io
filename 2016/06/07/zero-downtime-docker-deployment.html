<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <!-- (1) Optimize for mobile versions: http://goo.gl/EOpFl -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- (1) force latest IE rendering engine: bit.ly/1c8EiC9 -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <title>도커를 이용한 웹서비스 무중단 배포하기</title>
  <meta name="description" content="홈쇼핑처럼x밀본고기덮밥이 팔리는걸 관리자화면에서 보면서 하루에도 여러번 소스를 업데이트 하고 운영서버로 배포했던 내용이 떠올라 후기로 정리합니다. 배포는 단순히 로컬의 소스를 운영 서버로 복사하는 것입니다. FTP로 파일을 복사하는 방식은 가장 기본이면서 그럭저럭 잘 동작합니다. 배포 중에 서비스가 잠깐 멈추는 문제가 있다면 새벽에 배포하면 되고 굳이..." />

  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@subicura" />
    <meta name="twitter:title" content="도커를 이용한 웹서비스 무중단 배포하기" />
    <meta name="twitter:image" content="https://subicura.com/assets/images/df_logo.png" />
    
    <meta name="twitter:description"  content="홈쇼핑처럼x밀본고기덮밥이 팔리는걸 관리자화면에서 보면서 하루에도 여러번 소스를 업데이트 하고 운영서버로 배포했던 내용이 떠올라 후기로 정리합니다. 배포는 단순히 로컬의 소스를 운영 서버로 복사하는 것입니다. FTP로 파일을 복사하는 방식은 가장 기본이면서 그럭저럭 잘 동작합니다. 배포 중에 서비스가 잠깐 멈추는 문제가 있다면 새벽에 배포하면 되고 굳이..." />
    
    
  
  
  <meta property="og:site_name" content="Subicura's Blog" />
  <meta property="og:title" content="도커를 이용한 웹서비스 무중단 배포하기"/>
  
  <meta property="og:description" content="홈쇼핑처럼x밀본고기덮밥이 팔리는걸 관리자화면에서 보면서 하루에도 여러번 소스를 업데이트 하고 운영서버로 배포했던 내용이 떠올라 후기로 정리합니다. 배포는 단순히 로컬의 소스를 운영 서버로 복사하는 것입니다. FTP로 파일을 복사하는 방식은 가장 기본이면서 그럭저럭 잘 동작합니다. 배포 중에 서비스가 잠깐 멈추는 문제가 있다면 새벽에 배포하면 되고 굳이..." />
  
  <meta property="og:image" content="https://subicura.com/assets/images/df_logo.png" />
  <meta property="og:url" content="https://subicura.com/2016/06/07/zero-downtime-docker-deployment.html" />
  <meta property="og:type" content="article" />
  <meta property="article:published_time" content="2016-06-07T00:00:00+09:00">

  <meta property="fb:app_id" content="1611862309129685" />

  <meta name="naver-site-verification" content="cc257cc7988ed85c9db6c228330b4870f9dfa25f" />

  <link rel="canonical" href="https://subicura.com/2016/06/07/zero-downtime-docker-deployment.html"/>
  <link rel="shortcut icon" href="/assets/images/favicon.png" type="image/png"/>
  <!-- <link rel="stylesheet" href="//brick.a.ssl.fastly.net/Linux+Libertine:400,400i,700,700i/Open+Sans:400,400i,700,700i" /> -->
  <!-- <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" /> -->

  <link rel="stylesheet" type="text/css" href="/css/main.css?1648601050285363000" />
  <link rel="stylesheet" type="text/css" href="/css/asciinema-player.css" />
  <link rel="stylesheet" type="text/css" href="/css/asciinema-theme-snazzy.css" />
  <link rel="stylesheet" type="text/css" href="/css/nerd-fonts-generated.css" />
  <link rel="stylesheet" type="text/css" href="/css/custom.css" />
  <!-- <link rel="stylesheet" type="text/css" media="print" href="/css/print.css" />-->
  
  <script src="/assets/js/webfont.js"></script>
  <script type="text/javascript">
    WebFont.load({
      custom: {
        families: ['Spoqa Han Sans'],
        urls: ['/css/spoqa-han-sans-font.css']
      }
    });
  </script>
  <script>
    var _mailChimpUrl = "http://eepurl.com/cywDtP";
  </script>

  
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  
</head>

  <body itemscope itemtype="http://schema.org/BlogPosting">
    <!-- header start -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-43194822-1', 'auto');
  ga('require', 'displayfeatures');
  ga('send', 'pageview');
</script>

<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "https://connect.facebook.net/ko_KR/sdk.js#xfbml=1&version=v2.12&appId=1611862309129685";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>

<a href="https://subicura.com" class="logo-readium"><span class="logo" style="background-image: url(/assets/images/df_logo.png)"></span></a>
<!-- header end -->



    
      <a href="https://subicura.com/k8s/" target="_blank" class="top-banner">📔 쿠버네티스 안내서 →</a>



    

    <main class="content" role="main">
      <article class="post">
        <div itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
          <meta itemprop="name" content="Subicura's Blog" />
          <meta itemprop="url" content="https://subicura.com" />
          <div itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
            <meta itemprop="url" content="https://subicura.com/assets/images/df_logo.png" />
          </div>
        </div>
        <div itemprop="image" itemscope itemtype="http://schema.org/ImageObject">
          <meta itemprop="url" content="https://subicura.com/assets/images/author.jpg" />
        </div>
        <meta itemprop="headline" content="도커를 이용한 웹서비스 무중단 배포하기" />
        <meta itemprop="mainEntityOfPage" content="/2016/06/07/zero-downtime-docker-deployment.html" />
        <meta itemprop="datePublished" content="2016-06-07 00:00:00 +0900" />
        <meta itemprop="dateModified" content="2017-01-21 10:00:00 +0900" />
        
        <div class="noarticleimage">
          <div class="post-meta">
            <h1 class="post-title">
              도커를 이용한 웹서비스 무중단 배포하기
              
            </h1>
            <div class="cf post-meta-text">
              <section class="share">
                <div class="fb-like" data-href="https://subicura.com/2016/06/07/zero-downtime-docker-deployment.html" data-layout="button_count" data-action="like" data-show-faces="true" data-share="true"></div>
                <a data-pocket-label="pocket" data-pocket-count="none" class="pocket-btn" data-lang="ko"></a>
                
                  
                    <a class="icon-twitter" href="http://twitter.com/share?text=%EB%8F%84%EC%BB%A4%EB%A5%BC+%EC%9D%B4%EC%9A%A9%ED%95%9C+%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4+%EB%AC%B4%EC%A4%91%EB%8B%A8+%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0&amp;url=https://subicura.com/2016/06/07/zero-downtime-docker-deployment.html"
                      onclick="window.open(this.href, 'twitter-share', 'width=550,height=255');return false;">
                      <i class="nf nf-fa-twitter"></i><span class="hidden">twitter</span>
                    </a>
                  
                
                  
                
              </section>
              <div class="author-info">
                <div class="author-image" style="background-image: url(/assets/images/author.jpg)">Blog Logo</div>
                <h4 class="author-name" itemprop="author" itemscope itemtype="http://schema.org/Person">
                  subicura<meta itemprop="name" content="subicura" /><meta itemprop="url" content="https://subicura.com/about" />
                </h4>
                on
                <time datetime="2016-06-07T00:00:00+09:00">07 Jun 2016</time>
              </div>
            </div>
          </div>
        </div>
        <br>
        <br>
        <br>
        
        <section class="post-content">
          <div class="post-reading">
            <span class="post-reading-time"></span> read
          </div>
          <a name="topofpage"></a>
          <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#어떻게-배포할까">어떻게 배포할까?</a></li>
<li class="toc-entry toc-h2"><a href="#왜-도커인가">왜 도커인가?</a></li>
<li class="toc-entry toc-h2"><a href="#도커를-이용한-배포">도커를 이용한 배포</a></li>
<li class="toc-entry toc-h2"><a href="#도커-이미지-만들기">도커 이미지 만들기</a></li>
<li class="toc-entry toc-h2"><a href="#컨테이너-구성">컨테이너 구성</a></li>
<li class="toc-entry toc-h2"><a href="#웹서비스-배포하기">웹서비스 배포하기</a></li>
<li class="toc-entry toc-h2"><a href="#blue-green-배포">Blue-Green 배포</a></li>
<li class="toc-entry toc-h2"><a href="#service-discovery">Service Discovery</a></li>
<li class="toc-entry toc-h2"><a href="#자동화">자동화</a></li>
<li class="toc-entry toc-h2"><a href="#롤백">롤백</a></li>
<li class="toc-entry toc-h2"><a href="#그래서">그래서</a></li>
</ul><p><img src="https://subicura.com/assets/article_images/2016-06-07-zero-downtime-docker-deployment/milbon.jpg" alt="밀본x고기덮밥"></p>

<p><a href="https://www.likehs.com/tvprogram/index/view/id/22/">홈쇼핑처럼x밀본고기덮밥</a>이 팔리는걸 관리자화면에서 보면서 하루에도 여러번 소스를 업데이트 하고 운영서버로 배포했던 내용이 떠올라 후기로 정리합니다.</p>

<p>배포는 단순히 로컬의 소스를 운영 서버로 복사하는 것입니다. FTP로 파일을 복사하는 방식은 가장 기본이면서 그럭저럭 잘 동작합니다. 배포 중에 서비스가 잠깐 멈추는 문제가 있다면 새벽에 배포하면 되고 굳이 다른 개발할일도 많은데 배포에 신경을 써야 하는 생각도 듭니다.</p>

<p>하지만, 오히려 배포가 탄탄해지면 서비스 개발에 집중할 수 있고 하루에 몇번이라도 배포를 자주, 더 빨리 하는 것이 서비스의 경쟁력이 되는 세상입니다. 서비스가 빠르게 발전하고 있고 서버를 확장하려면 미리미리 신경쓰는 것이 맞다고 생각합니다.</p>

<p>현재 홈쇼핑처럼 운영서버는 크게 웹(+API), 마이크로서비스(배송조회, 우편번호검색), 영상, 채팅, 모니터링으로 구성되어 있습니다. 여기서는 웹 서비스 배포에 대해서 이야기 하려고 합니다.</p>

<p>웹 서비스는 웹서버 1대(nginx + php)와 디비서버 1대(mysql + redis)로 가난하게 구성되어 있습니다. 서버 규모에 맞게 최대한 단순하게 배포 프로세스를 구성하려고 했지만, 추후 서비스가 잘 되었을때를 고려하여 확장가능성도 고려하였습니다.</p>

<div align="center" class="googleads googleads-content">
                <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-2468713653725581" data-ad-slot="8649023787" data-ad-format="auto"></ins>
                <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
            </div>

<hr>

<h2 id="어떻게-배포할까">
<a class="anchor" href="#%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%B0%B0%ED%8F%AC%ED%95%A0%EA%B9%8C" aria-hidden="true"><span class="octicon octicon-link"></span></a>어떻게 배포할까?</h2>

<p>배포 프로세스를 만들면서 고민했던 내용입니다.</p>

<ul>
  <li>쉽고 관리하기 편한 방법을 선택하자</li>
  <li>자동으로 배포하자</li>
  <li>하루에도 여러번 배포하자</li>
  <li>배포중 서비스가 중단되는 일이 없도록 하자</li>
  <li>모든 서비스는 도커를 이용해서 컨테이너 형태로 표준화하여 배포하자</li>
  <li>테스트 서버에 동일한 방법으로 배포하고 테스트하자</li>
  <li>시작은 서버 한대지만 나중에 여러대(수백대?!)로 확장되었을때를 대비하여 설계를 고민하자</li>
</ul>

<h2 id="왜-도커인가">
<a class="anchor" href="#%EC%99%9C-%EB%8F%84%EC%BB%A4%EC%9D%B8%EA%B0%80" aria-hidden="true"><span class="octicon octicon-link"></span></a>왜 도커인가?</h2>

<p>배포 프로세스를 고려하면서 가장 중요하게 생각한 개념이 <a href="http://www.docker.com/">도커</a>입니다. 도커는 굉장히 빠르게 인기를 얻고 있는 기술이지만 생소하거나 잘 모르는 분들을 위해 간단하게 도커를 소개합니다.</p>

<p><strong>Container</strong></p>

<p>새로운(깨끗한) 서버에 서비스를 동작시키려면 굉장히 많은 작업이 필요합니다.</p>

<p>php로 만든 서비스를 동작시키려면 일단 php를 설치하고 관련 extention으로 php-mysql, php-curl, php-mcrypt, php-mbstring등등을 설치해야 합니다. nginx를 앞단에 두고 php를 연결하기 위해 php-fpm도 설치합니다.</p>

<p>자, 서버가 한대 더 추가되었습니다. 똑같이 셋팅할 수 있을까요?</p>

<p>물론입니다. 우리 서버 관리자는 굉장히 섬세하고 고오급 개발자여서 기존에 설치된 내용을 기억하고 정리해두었습니다.</p>

<p>이 서버에 다른 php 서비스를 올려봅니다. 엇, 그런데 이 서비스는 php7에서 돌지 않습니다. php7이 속도도 빠르고 기능도 짱짱맨이라 사용하고 있었는데 이번에 올릴 서비스는 php7에서 동작하지 않는 모듈이 포함되어 있습니다.</p>

<p>이렇게 되면 서버 관리자가 굉장히 똑똑하여 슬기롭게 두개를 잘 돌리던가, 아니면 서버가 점점 지저분해 진다던가, 아니면 포기하고 다른 서버에 서비스를 띄우게 됩니다.</p>

<p>그리고 3년후 서버 관리자가 퇴사하고 이 서버들은 레거시가 되고 가끔 오류가 발생하지만 아무도 왜 그런지 모르고 재부팅하면 운 좋게 동작하는 서버가 되버립니다.</p>

<p>php를 예로 들었지만, ruby on rails나 nodejs, java기반의 프로젝트도 비슷한 문제를 가지고 있습니다.</p>

<p>하지만, 도커라면?</p>

<p><img src="https://subicura.com/assets/article_images/2016-06-07-zero-downtime-docker-deployment/container-docker-blue-whale.jpg" alt="Docker Container"></p>

<p>도커 컨테이너는 가상의 공간을 만들어서 호스트OS와는 전혀 별개의 환경에서 프로세스들이 동작하는 기술입니다.</p>

<p>도커는 가상의 공간을 이미지로 만들어 저장한 후 하나의 이미지에서 여러개의 컨테이너를 생성할 수 있는데, 이 말은 한번 이미지를 만들어 놓으면 마구 컨테이너를 띄울 수 있다는 의미입니다. 그것도 완전히 독립된 가상의 공간에서 실행이 됩니다. 관리자는 컨테이너가 어떻게 구성되어 있는지 신경쓸 필요가 없습니다. 그냥 이 컨테이너는 (예를들어)80포트가 열려 있으니 호스트의 80포트를 컨테이너의 80포트로 연결만 하면 바로 동작하게 됩니다.</p>

<p>도커 이미지를 만드는 방법은 Dockerfile이라는 파일로 관리하기 때문에 원한다면 이미지 생성 과정을 보거나 수정할 수 있습니다.</p>

<p><strong>vmware 가상머신같은건가?</strong></p>

<p>마치 가상머신 같지만 분명 가상머신과는 다릅니다.</p>

<ul>
  <li>호스트OS 위에 또다른 OS를 가상화 하는 것이 아니라 같은 OS에서 프로세스를 격리 시켜 마치 독립적으로 실행한 것 처럼 사용</li>
  <li>단지, 독립된 공간을 만들어 프로세스를 실행하기 때문에 실행속도가 빠르고(띄우는데 1초) 일반적으로 cpu, memory, network 성능저하가 거어어의 없음(호스트 대비 99% 성능 나옴)</li>
  <li>도커를 도와주는 생태계가 엄청남. 편리한 툴과 다양한 문서들이 많고 커뮤니티가 활발함</li>
  <li>이미지파일을 git처럼 변경분만 저장하기 때문에 컨테이너를 여러개 띄워도 추가적인 용량은 거의 0M임. 실제로 이미지를 원격 저장소에 저장할 때도 push, pull같은 명령어를 이용함</li>
</ul>

<p><strong>왜 인기있을까?</strong></p>

<p>도커가 나오기 전에 가장 인기 있었던 가상화 시스템은 Xen, KVM등이 있습니다. 이러한 기술들은 일부 고오급 개발자들만 사용이 가능했고 가상화에 따른 성능이슈도 존재했습니다.</p>

<p>도커는 프로세스 격리라는 개념을 적극 도입하여 성능 이슈를 줄이고, 일반 개발자들도 굉장히 사용하기 쉽게 개발하였습니다. 그리고 큰 용량의 이미지를 쉽게 다운받고 저장할 수 있게 <a href="https://hub.docker.com/">docker hub</a>와 같은 서비스도 같이 오픈하였고 전세계적으로 커뮤니티 또한 적극적으로 지원하였습니다.(티셔츠랑 스티커!) 한국에서 온 처음만나는 개발자에게 회사의 <a href="https://twitter.com/jpetazzo">고오오오급 개발자</a>가 직접 궁금증을 풀어주는 경우가 흔치는 않겠죠.</p>

<p><img src="https://subicura.com/assets/article_images/2016-06-07-zero-downtime-docker-deployment/docker-jpetazzo.jpg" alt="Docker office에서 만난 Jérôme Petazzoni"></p>

<p><strong>단점</strong></p>

<p>단점이 있을테니 단점을 찾아봅시다.</p>

<ul>
  <li>(사실상)리눅스에서만 사용함</li>
  <li>리눅스 커널에 따라 이슈가 약간 있음(최신 커널을 못 쓰는 클라우드에서 문제가 있을수 있음)</li>
  <li>도커 버전업할때 컨테이너가 쥬금 ㅠ (단순하게 만드는 unix철학이 아닌 도커데몬이 모든걸 관리하고 제어하기때문..)</li>
  <li>포트 포워딩에 iptable을 사용하면서 생기는 보안상 제약사항이 있음</li>
</ul>

<h2 id="도커를-이용한-배포">
<a class="anchor" href="#%EB%8F%84%EC%BB%A4%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%B0%B0%ED%8F%AC" aria-hidden="true"><span class="octicon octicon-link"></span></a>도커를 이용한 배포</h2>

<p>도커를 이용한 배포가 갖는 특징입니다.</p>

<p><strong>확장성</strong></p>

<ul>
  <li>이미지만 만들어 놓으면 컨테이너는 그냥 띄우기만 하면됨</li>
  <li>다른 서버로 서비스를 옮기거나 새로운 서버에 서비스를 하나 더 띄우는건 <code class="language-plaintext highlighter-rouge">docker run</code> 명령어 하나로 끝</li>
  <li>개발서버 띄우기도 편하고 테스트서버 띄우기도 간편</li>
</ul>

<p><strong>표준성</strong></p>

<ul>
  <li>도커를 사용하지 않는 경우 ruby, nodejs, go, php로 만든 서비스들의 배포 방식은 제각각 다름</li>
  <li>컨테이너라는 표준으로 서버를 배포하므로 모든 서비스들의 배포과정이 동일해짐</li>
  <li>capistrano? fabric? ftp? 바이바이~</li>
</ul>

<p><strong>이미지</strong></p>

<ul>
  <li>이미지에서 컨테이너를 생성하기 때문에 반드시 이미지를 만드는 과정이 필요</li>
  <li>이미지를 저장할 곳이 필요</li>
  <li>빌드 서버에서 이미지를 만들면 해당 이미지를 <a href="https://github.com/docker/distribution">distribution</a>에 저장하고 운영서버에서 이미지를 불러옴</li>
</ul>

<p><strong>설정</strong></p>

<ul>
  <li>설정은 보통 환경변수로 제어함</li>
  <li>
<code class="language-plaintext highlighter-rouge">MYSQL_PASS=password</code>와 같이 컨테이너를 띄울때 환경변수를 같이 지정</li>
  <li>하나의 이미지가 환경변수에 따라 동적으로 설정파일을 생성하도록 만들어져야함</li>
</ul>

<p><strong>공유자원</strong></p>

<ul>
  <li>컨테이너는 삭제 후 새로 만들면 모든 데이터가 초기화됨</li>
  <li>업로드 파일을 외부 스토리지와 링크하여 사용하거나 S3같은 별도의 저장소가 필요</li>
  <li>세션이나 캐시를 파일로 사용하고 있다면 memcached나 redis와 같은 외부로 분리</li>
</ul>

<p><strong>힙</strong></p>

<ul>
  <li>왠지 최신기술을 쓰는 느낌을 갖음</li>
  <li>힙한 개발자가 된 느낌을 갖음</li>
</ul>

<h2 id="도커-이미지-만들기">
<a class="anchor" href="#%EB%8F%84%EC%BB%A4-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%A7%8C%EB%93%A4%EA%B8%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>도커 이미지 만들기</h2>

<p>이제 본격적으로 이미지를 만들어 봅니다.</p>

<p><img src="https://subicura.com/assets/article_images/2016-06-07-zero-downtime-docker-deployment/likehs-docker-image.png" alt="홈쇼핑처럼 도커 이미지"></p>

<p><strong>likehs-nginx</strong></p>

<noscript><pre>FROM subicura/nginx:1.11.1
MAINTAINER Chungsub Kim &lt;chungsub.kim@purpleworks.co.kr&gt;

ADD /data/config/nginx/load_pagespeed_module.conf /usr/local/nginx/conf/conf.d/load_pagespeed_module.conf
ADD /data/config/nginx/production.conf /usr/local/nginx/conf/sites/production.conf

CMD /usr/local/sbin/nginx</pre></noscript>
<script src="https://gist.github.com/subicura/8d50a2337e1e3bb6bc43a10e005c5709.js"> </script>

<ul>
  <li>Base Image
    <ul>
      <li><a href="https://github.com/subicura/Dockerfiles/tree/master/nginx">subicura/nginx</a></li>
      <li>nginx 최신버전</li>
      <li>ssl + http2 + stream + realip + ngx pagespeed와 같은 흔히 사용하는 모듈 컴파일</li>
    </ul>
  </li>
  <li>nginx pagespeed 모듈을 활성화하기 위한 설정파일 추가</li>
  <li>php7-fpm 연동을 위한 설정파일 추가</li>
</ul>

<p><strong>likehs-app</strong></p>

<noscript><pre>FROM subicura/php7-fpm:latest
MAINTAINER Chungsub Kim &lt;chungsub.kim@purpleworks.co.kr&gt;

# Add source &amp; config files
ADD src /var/www/magento
ADD data/config/php/99-custom.ini /etc/php/7.0/fpm/conf.d/99-custom.ini

# Volume
VOLUME /var/www/magento
VOLUME /var/run/php

# Run
COPY data/docker/start.sh /usr/local/bin/
RUN ln -s usr/local/bin/start.sh /start.sh
CMD ["start.sh"]</pre></noscript>
<script src="https://gist.github.com/subicura/0ebe5370d8e52dd2a48aa9df53f66b00.js"> </script>

<ul>
  <li>Base Image
    <ul>
      <li><a href="https://github.com/subicura/Dockerfiles/blob/master/php7-fpm">subicura/php7-fpm</a></li>
      <li>php7-fpm 최신버전</li>
      <li>mysql, curl, mcrypt, mbstring등 php 익스텐션 설치</li>
      <li>v8, xdebug 선택적 사용가능</li>
    </ul>
  </li>
  <li>base 이미지에 소스파일과 php custom 설정파일을 추가함</li>
  <li>
<code class="language-plaintext highlighter-rouge">start.sh</code> 파일은 환경변수에 따라 데이터베이스 정보등을 설정하고 php7-fpm 프로세스를 실행함</li>
</ul>

<h2 id="컨테이너-구성">
<a class="anchor" href="#%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B5%AC%EC%84%B1" aria-hidden="true"><span class="octicon octicon-link"></span></a>컨테이너 구성</h2>

<p>이미지를 만들었으니 사실상 90% 작업은 완료되었습니다. 이제 생성된 이미지를 컨테이너로 실행만 하면 됩니다.</p>

<p><img src="https://subicura.com/assets/article_images/2016-06-07-zero-downtime-docker-deployment/likehs-docker-container.png" alt="홈쇼핑처럼 도커 컨테이너 구성"></p>

<noscript><pre>version: '2'
services:
  nginx:
    image: xxx/likehs-nginx:latest
    network_mode: 'bridge'
    depends_on:
      - app
    volumes_from:
      - app
    ports:
      - 8080:80
  app:
    image: xxx/likehs-app:latest
    environment:
      MYSQL_HOST: mysql
      MYSQL_USER: user
      MYSQL_PASSWORD: password
      MYSQL_DATABASE: database
      REDIS_HOST: redis
      REDIS_PORT: 6379
      ENABLE_PHP7_FPM_V8: 1
    volumes:
      - /data/likehs/magento_files:/var/www/magento/media
</pre></noscript>
<script src="https://gist.github.com/subicura/d888929d311a680e7d64a51b03e569ff.js"> </script>

<p>컨테이너를 실행할때 <a href="https://github.com/docker/compose">docker compose</a>를 이용하면 힘들게 명령어를 기이일게 입력하지 않아도 되고 컨테이너간 의존성도 알아서 체크하여 순서대로 실행해줍니다.</p>

<p><strong>nginx container</strong></p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">likehs-app</code>컨테이너에서 <code class="language-plaintext highlighter-rouge">/var/www/magento</code>디렉토리와 <code class="language-plaintext highlighter-rouge">/var/run/php</code>디렉토리가 볼륨으로 설정되어 있으므로 마치 내 컨테이너에 있는 디렉토리처럼 자동으로 마운트됨</li>
  <li>nginx 설정파일은 <code class="language-plaintext highlighter-rouge">unix:/var/run/php/php7.0-fpm.sock</code>여기를 바라보게 셋팅되어 있고 <code class="language-plaintext highlighter-rouge">/var/www/magento</code>디렉토리를 루트로 바라봄</li>
  <li>컨테이너 내부의 <code class="language-plaintext highlighter-rouge">80포트</code>를 호스트의 <code class="language-plaintext highlighter-rouge">8080포트</code>로 연결함</li>
</ul>

<p><strong>app container</strong></p>

<ul>
  <li>데이터베이스와 redis설정을 환경변수로 제어함</li>
  <li>업로드 디렉토리를 호스트의 디렉토리로 연결하여 컨테이너를 새로 띄워도 파일을 유지할 수 있음</li>
</ul>

<p>이제 운영서버에 접속한 후 <code class="language-plaintext highlighter-rouge">docker-compose up -d</code>를 실행하면 원격에서 이미지를 다운받고 서비스가 실행됩니다. 이제 배포를 위한 모든 준비가 끝났습니다.</p>

<h2 id="웹서비스-배포하기">
<a class="anchor" href="#%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>웹서비스 배포하기</h2>

<p>도커생태계에서 배포는 뜨거운 이슈입니다. 그만큼 다양한 방법이 존재하고 다양한 툴들이 있습니다. 배포 프로세스를 설계하면서 고려해봤던 툴들입니다.</p>

<ul>
  <li>
<a href="https://coreos.com/">coreos/fleet</a>
    <ul>
      <li>coreos는 컨테이너를 호율적으로 실행하기 위해 굉장히 가볍게 설계된 리눅스 배포판임</li>
      <li>보안에 신경을써 기본적으로 OS가 자동으로 업데이트됨(자동 재부팅 ㄷㄷ)</li>
      <li>애초에 여러대의 서버에 어플리케이션이 동적으로 배포되는걸 가정하고 만들어짐. 하나가 죽어도 다른 서버에서 살아남!</li>
      <li>
<a href="https://coreos.com/using-coreos/clustering/">fleet</a>은 systemd의 cluster버전으로 사용법이 쉽고 systemd의 장점을 그대로 가지고 있음</li>
      <li>fleet을 운영하기 위해서는 <a href="https://coreos.com/etcd/">etcd</a>가 필요하고 etcd는 최소 3대 이상의 서버가 필요함</li>
      <li>
<a href="http://www.slideshare.net/subicura/launching-containers-with-fleet">테스트</a>만 해보고 소규모에는 적합하지 않다고 생각하여 패스</li>
    </ul>
  </li>
  <li>
<a href="http://mesos.apache.org/">apache mesos</a>
    <ul>
      <li>UC Berkeley에서 연구를 시작하여 Twitter, Facebook, Apple, Airbnb등 여러곳에서 안정적으로 사용중</li>
      <li>
<a href="https://zookeeper.apache.org/">zookeeper</a>를 백엔드로 사용. 이거 관리어떻게 하지…</li>
      <li>최근 도커 컨테이너를 적극 지원하고 있음</li>
      <li>
<a href="http://www.slideshare.net/subicura/mesos-on-coreos">테스트</a>만 해보고 역시나 소규모에는 적합하지 않다고 생각하여 패스</li>
    </ul>
  </li>
  <li>
<a href="http://kubernetes.io/">kubernetes</a>
    <ul>
      <li>구글에서 개발하고 있는 컨테이너 배포, 확장, 운영 툴</li>
      <li>fleet과 마찬가지로 etcd를 백엔드로 사용</li>
      <li>예전에 테스트 해봤을때 아직 프로덕션에 사용은 어려워 보였음</li>
      <li>역시나 소규모에는 적합하지 않음 ㅠ</li>
    </ul>
  </li>
  <li>
<a href="https://docs.docker.com/swarm/">docker swarm</a>
    <ul>
      <li>docker에서 밀고 있는 컨테이너 배포 툴</li>
      <li>호스트 OS에 Agent만 설치하면 간단하게 작동하고 빠름</li>
      <li>소규모에 적합해보임</li>
    </ul>
  </li>
</ul>

<p>결론적으로, 배포와 관련된 테스트와 스터디는 추후 대규모로 서버가 확장되었을때 사용하는 것으로..하고(언젠가 쓸모있겠지 ㅠ) 시작은 가볍게 갑니다.</p>

<p><strong>Docker 원격 API</strong></p>

<p>도커는 기본적으로 원격 API를 호출하기 쉬운 구조입니다. 도커 명령어를 실행할때 의식하고 있지는 않지만 자동으로 <code class="language-plaintext highlighter-rouge">unix:///var/run/docker.sock</code> 여기를 바라보고 명령을 하고 있습니다. 도커 데몬을 실행할때 <code class="language-plaintext highlighter-rouge">-H tcp://0.0.0.0:2375</code> 옵션을 주게 되면 원격에서 명령을 보낼 준비가 완료됩니다.</p>

<blockquote>
  <p>쉽다는건 보안적으로 엄청난 구멍일 수 있다는 뜻입니다. 방화벽 정책은 필수!</p>
</blockquote>

<ul>
  <li>도커 원격명령 실행
    <ul>
      <li>DOCKER_HOST 환경변수를 셋팅합니다.</li>
      <li><code class="language-plaintext highlighter-rouge">DOCKER_HOST=tcp://192.168.0.100:2375 docker run</code></li>
    </ul>
  </li>
  <li>Docker Compose 원격명령 실행
    <ul>
      <li>DOCKER_HOST 환경변수를 셋팅합니다.</li>
      <li><code class="language-plaintext highlighter-rouge">DOCKER_HOST=tcp://192.168.0.100:2375 docker-compose up -d</code></li>
    </ul>
  </li>
</ul>

<p><strong>원격 API를 이용한 배포</strong></p>

<p>원격으로 도커 명령어를 실행하는 방법을 이용해 간단하게 스크립트를 만듭니다.</p>

<noscript><pre>#!/bin/sh

TARGET_DEPLOY_TCP=tcp://192.168.0.100:2375
DOCKER_APP_NAME=likehs
DOCKER_HOST=${TARGET_DEPLOY_TCP} docker-compose -p ${DOCKER_APP_NAME} -f docker-compose.yml down
DOCKER_HOST=${TARGET_DEPLOY_TCP} docker-compose -p ${DOCKER_APP_NAME} -f docker-compose.yml pull
DOCKER_HOST=${TARGET_DEPLOY_TCP} docker-compose -p ${DOCKER_APP_NAME} -f docker-compose.yml up -d
</pre></noscript>
<script src="https://gist.github.com/subicura/f39d180842b2f3bd6323bb467dec75cb.js"> </script>

<p>기존에 실행중인 컨테이너를 멈추고(down) 최신버전을 내려 받고(pull) 실행하면(up) 끝입니다.</p>

<h2 id="blue-green-배포">
<a class="anchor" href="#blue-green-%EB%B0%B0%ED%8F%AC" aria-hidden="true"><span class="octicon octicon-link"></span></a>Blue-Green 배포</h2>

<p>도커 이미지를 만들고 컨테이너를 배포하는데 성공했지만 배포할때마다 서비스가 잠시 중단(down하고 up하는 사이)되는 치명적인 단점이 있습니다. 이부분을 <a href="http://martinfowler.com/bliki/BlueGreenDeployment.html">blue-green 배포 방식</a>을 이용하여 무중단으로 배포해봅니다.</p>

<p><strong>nginx load balance 기능 이용하기</strong></p>

<p><img src="https://subicura.com/assets/article_images/2016-06-07-zero-downtime-docker-deployment/nginx-load-balance.png" alt="nginx"></p>

<p>nginx는 무료면서 훌륭한 성능을 자랑하는 로드밸런서입니다. <code class="language-plaintext highlighter-rouge">80포트</code>로 들어온 요청을 <code class="language-plaintext highlighter-rouge">8080포트</code>, <code class="language-plaintext highlighter-rouge">8081포트</code>로 분산할 수 있고 health check를 통해 포트가 죽어있다면 살아있는 포트로 요청을 보내게 됩니다.</p>

<p>보통은 서로다른 IP의 서버를 로드밸런스 하기 위해 사용하지만 한 IP에서 서로 다른 포트를 지정하는 것도 가능합니다. 도커를 사용하지 않는다면 같은 서비스를 하나의 서버에 여러개 띄운다는 걸 상상하기 어렵지만 도커이기 때문에 쉽게 적용할 수 있습니다.</p>

<noscript><pre>#!/bin/sh

TARGET_DEPLOY_TCP=tcp://192.168.0.100:2375
DOCKER_APP_NAME=likehs

EXIST_BLUE=$(DOCKER_HOST=${TARGET_DEPLOY_TCP} docker-compose -p ${DOCKER_APP_NAME}-blue -f docker-compose.blue.yml ps | grep Up)

if [ -z "$EXIST_BLUE" ]; then
    DOCKER_HOST=${TARGET_DEPLOY_TCP} docker-compose -p ${DOCKER_APP_NAME}-blue -f docker-compose.blue.yml pull
    DOCKER_HOST=${TARGET_DEPLOY_TCP} docker-compose -p ${DOCKER_APP_NAME}-blue -f docker-compose.blue.yml up -d

    sleep 10

    DOCKER_HOST=${TARGET_DEPLOY_TCP} docker-compose -p ${DOCKER_APP_NAME}-green -f docker-compose.green.yml down
else
    DOCKER_HOST=${TARGET_DEPLOY_TCP} docker-compose -p ${DOCKER_APP_NAME}-green -f docker-compose.green.yml pull
    DOCKER_HOST=${TARGET_DEPLOY_TCP} docker-compose -p ${DOCKER_APP_NAME}-green -f docker-compose.green.yml up -d

    sleep 10

    DOCKER_HOST=${TARGET_DEPLOY_TCP} docker-compose -p ${DOCKER_APP_NAME}-blue -f docker-compose.blue.yml down
fi
</pre></noscript>
<script src="https://gist.github.com/subicura/fff289e766a73b0dfb498eadc0d2f9ec.js"> </script>

<p>작은 규모에 맞는 아주 적절한 스크립트를 만들었습니다. 포트를 다르게 설정한 compose 파일을 2개 만들고 어떤 compose가 떠있는지 확인합니다. 실행중이 아닌 compose를 실행하여 컨테이너를 띄운 후 다른 컨테이너를 멈춥니다.</p>

<p>어떤 디펜던시도 필요 없고 어떤 에이전트도 없지만 확실하게 동작하는 스크립트 입니다.</p>

<h2 id="service-discovery">
<a class="anchor" href="#service-discovery" aria-hidden="true"><span class="octicon octicon-link"></span></a>Service Discovery</h2>

<p>nginx를 이용해 2개의 포트를 바라보고 둘중에 동작하는 포트에 요청을 보내는 방법은 몇가지 단점이 있습니다.</p>

<ul>
  <li>서버를 추가하거나 변경할 경우 설정파일을 수정하고 재시작하는 과정이 필요</li>
  <li>프록시 대상 IP와 PORT가 항상 고정이여야 한다는 점</li>
  <li>죽어 있는 포트가 살아 있는지 계속해서 체크하면서 생기는 (작지만 문제 있어보이는) 오버헤드</li>
</ul>

<p>이런 문제를 해결하기 위해 Service Discovery라는 개념이 있습니다. 서버들의 정보(IP, Port등등)를 포함한 다양한 정보를 저장하고 가져오고 값의 변화가 일어날때 이벤트를 받아 자동으로 서비스의 설정 정보를 수정하고 재시작하는 개념입니다.</p>

<p><img src="https://subicura.com/assets/article_images/2016-06-07-zero-downtime-docker-deployment/service-discovery.png" alt="service discovery"></p>

<ol>
  <li>새로운 서버가 추가되면 서버 정보를 <code class="language-plaintext highlighter-rouge">key/value store</code>에 추가함</li>
  <li>
<code class="language-plaintext highlighter-rouge">key/value store</code>는 directory 형태로 값을 저장함. /services/web 하위를 읽으면 전체 web 서버 정보를 읽을 수 있음</li>
  <li>
<code class="language-plaintext highlighter-rouge">key/value store</code>를 watch하고 있던 <code class="language-plaintext highlighter-rouge">configuration manager</code>가 값이 추가되었다는 이벤트를 받음</li>
  <li>이벤트를 받으면 템플릿 파일을 기반으로 새로운 설정파일을 생성</li>
  <li>새로운 설정파일을 만들어 기존파일을 대체하고 서비스를 재시작함</li>
</ol>

<p>이러한 개념을 구현한 다양한 서비스와 툴이 존재하고 각기 다른 특징을 갖습니다. 여러가지 서비스에 대해선 다음기회에.. 알아보고 여기서는 <code class="language-plaintext highlighter-rouge">docker-gen</code>에 대해서 알아봅니다.</p>

<p><strong>docker-gen</strong></p>

<p><a href="https://github.com/jwilder/docker-gen">docker-gen</a>은 docker의 기본 기능을 적극 활용한 service discovery 툴입니다. docker외에 디펜던시는 없기 때문에 구성이 간단하고 편리하지만 하나의 서버에 속한 컨테이너끼리만 동작한다는 단점이 있습니다. 홈쇼핑처럼은 아직 작은 서비스이기 때문에 적합하다고 할 수 있습니다.</p>

<ul>
  <li>key/value store
    <ul>
      <li>도커 데몬이 가지고 있는 컨테이너의 정보를 그대로 이용</li>
      <li>컨테이너를 실행할때 입력한 환경변수를 읽음</li>
      <li>
<code class="language-plaintext highlighter-rouge">VIRTUAL_HOST=www.likehs.com</code>과 같이 환경변수를 지정하면 이를 보고 nginx의 virtual host 설정파일들을 구성함</li>
    </ul>
  </li>
  <li>configuration manager
    <ul>
      <li>도커 데몬은 컨테이너의 생성/삭제에 대한 이벤트를 발생시킴</li>
      <li>docker-gen이 해당 이벤트를 받아서 처리함</li>
      <li>template은 go의 <a href="https://golang.org/pkg/text/template/">text/template language</a>을 그대로 사용하여 매우 자유롭게 구성가능</li>
      <li>조건식/반복문등을 이용하여 template 파일 구성</li>
      <li>template 파일을 가지고 설정파일을 만든 후 원하는 명령어를 수행</li>
      <li>명령어는 보통 서비스 재시작 (<code class="language-plaintext highlighter-rouge">nginx -s reload</code>)</li>
    </ul>
  </li>
</ul>

<p><strong>적용</strong></p>

<p>홈쇼핑처럼의 웹서비스는 컨테이너 앞단에 nginx를 두고 docker-gen을 이용하여 nginx의 설정파일을 변경하고 프로세스를 재시작하고 있습니다.</p>

<p><code class="language-plaintext highlighter-rouge">blue 컨테이너 실행</code> &gt; <code class="language-plaintext highlighter-rouge">docker-gen 이벤트 수신</code> &gt; <code class="language-plaintext highlighter-rouge">nginx 설정파일에 blue container 정보 추가</code> &gt; <code class="language-plaintext highlighter-rouge">nginx 재시작</code></p>

<p>이어서,</p>

<p><code class="language-plaintext highlighter-rouge">green 컨테이너 중지</code> &gt; <code class="language-plaintext highlighter-rouge">docker-gen 이벤트 수신</code> &gt; <code class="language-plaintext highlighter-rouge">nginx 설정파일에 green container 정보 제거</code> &gt; <code class="language-plaintext highlighter-rouge">nginx 재시작</code></p>

<h2 id="자동화">
<a class="anchor" href="#%EC%9E%90%EB%8F%99%ED%99%94" aria-hidden="true"><span class="octicon octicon-link"></span></a>자동화</h2>

<p>이제 무중단 배포까지 완료되었으니 배포를 자동화합니다.</p>

<p><strong>git branch</strong></p>

<p>현재 소스는 총 3가지 타입의 브랜치로 관리하고 있습니다.</p>

<ul>
  <li>기능별 브랜치
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">send-sms-after-order</code>와 같이 기능별로 브랜치를 만듬</li>
      <li>master 브랜치로 머지 후 제거됨</li>
    </ul>
  </li>
  <li>master
    <ul>
      <li>메인 개발소스</li>
      <li>바로 push할 수 없음</li>
      <li>작업별 브랜치를 pull request 보내고 코드 리뷰 후 머지함</li>
      <li>master 브랜치는 바로 스테이징서버로 배포</li>
    </ul>
  </li>
  <li>production
    <ul>
      <li>운영서버에서 사용중인 브랜치</li>
      <li>master 브랜치가 스테이징서버로 배포되고 테스트가 끝나면 수동으로 master 브랜치를 production 브랜치로 머지</li>
      <li>production 브랜치가 푸시되면 바로 운영서버로 배포</li>
    </ul>
  </li>
</ul>

<p><strong>gitlab webhook</strong></p>

<p>gitlab에는 푸시가 될때마다 이벤트를 보낼 수 있는 <a href="https://gitlab.com/gitlab-org/gitlab-ce/blob/master/doc/web_hooks/web_hooks.md">webhook</a>기능이 있고 jenkins는 webhook이 호출되면 자동으로 빌드를 시작하는 <a href="https://wiki.jenkins-ci.org/display/JENKINS/Gitlab+Hook+Plugin">plugin</a>이 존재합니다. gitlab은 모든 푸시 이벤트마다 jenkins를 호출하게 되고 jenkins는 branch를 보고 master일 경우는 staging 배포, production일 경우는 운영서버에 배포하게 됩니다.</p>

<p><strong>jenkins</strong></p>

<p>jenkins에 <a href="https://wiki.jenkins-ci.org/display/JENKINS/Slack+Plugin">slack플러그인</a>을 설치하면 시작, 배포 후 성공/실패 여부를 슬랙 메시지로 받을 수 있습니다.</p>

<p>jenkins는 <code class="language-plaintext highlighter-rouge">테스트</code> &gt; <code class="language-plaintext highlighter-rouge">이미지 빌드</code> &gt; <code class="language-plaintext highlighter-rouge">배포</code> 과정을 수행합니다.</p>

<h2 id="롤백">
<a class="anchor" href="#%EB%A1%A4%EB%B0%B1" aria-hidden="true"><span class="octicon octicon-link"></span></a>롤백</h2>

<p>배포된 이미지에 문제가 심각할 경우 이전 이미지로 되돌릴 수 있어야 합니다. 도커를 이용하면 이미지에 태그를 걸 수 있어, 손쉽게 구현할 수 있습니다.</p>

<noscript><pre>#!/bin/sh

DOCKER_REGISTRY_NAME=xxxx/likehs
COMMIT_HASH="$(git show-ref --head | grep -h HEAD | cut -d':' -f2 | head -n 1 | head -c 10)"
docker build --force-rm=true -f Dockerfile -t ${DOCKER_REGISTRY_NAME}-app:$COMMIT_HASH .
docker tag -f ${DOCKER_REGISTRY_NAME}-app:$COMMIT_HASH ${DOCKER_REGISTRY_NAME}-app:latest</pre></noscript>
<script src="https://gist.github.com/subicura/bd3b275d5330b9eef983ce4e626b6edd.js"> </script>

<p>jenkins에서 이미지를 빌드할때 현재 <code class="language-plaintext highlighter-rouge">git commit hash</code>로 태그로 만듭니다. 그리고 해당 이미지를 다시 배포하려면 해당 git commit hash를 latest로 태그한 후 다시 배포하면 됩니다.</p>

<h2 id="그래서">
<a class="anchor" href="#%EA%B7%B8%EB%9E%98%EC%84%9C" aria-hidden="true"><span class="octicon octicon-link"></span></a>그래서</h2>

<p>도커를 이용한 배포에 대해 전반적인 내용을 살펴보았습니다. 어쩌다보니 도커에 대한 내용이 더 많아진 느낌입니다. 이미 도커를 알고 계신분은 심심한 포스트일지도.. 하지만, 도커를 몰랐던 분들은 꼭 써보세요. 좋습니다! 도커에 대한 내용은 <a href="http://documents.docker.co.kr/">여기</a>에서 더 많이 볼 수 있습니다.</p>

<p>배포는 다양한 기술이 존재하고 서버 규모나 개발팀의 규모에 따라 여러가지 방법이 있으니 자신의 팀에 딱 맞는 방법을 찾아 적용하는 것이 중요한 것 같습니다. 더 쉽거나 나은 방법 있으면 추천해주세요.</p>

<p>지난번 떡볶이에 이어 <strong>고기덮밥</strong> 메뉴도 추가되었으니 서비스에 관심있으신분은 <a href="https://www.likehs.com/">https://www.likehs.com/</a> 에 방문해 주시구요.</p>

<p>개발자 상시 모집중입니다. 연락주세요 ㅎㅎ (<a href="http://www.purpleworks.co.kr/recruit">http://www.purpleworks.co.kr/recruit</a>)</p>


          <p class="tags">
            
              <a href="/tags#docker-ref">Docker</a>
            
              <a href="/tags#devops-ref">DevOps</a>
            
              <a href="/tags#server-ref">Server</a>
            
              <a href="/tags#deployment-ref">Deployment</a>
            
          </p>
        </section>
        <footer class="post-footer">
          <section class="share">
            <div class="fb-like" data-href="https://subicura.com/2016/06/07/zero-downtime-docker-deployment.html" data-layout="button_count" data-action="like" data-show-faces="true" data-share="true"></div>
            <a data-pocket-label="pocket" data-pocket-count="none" class="pocket-btn" data-lang="ko"></a>
            
              
                <a class="icon-twitter" href="http://twitter.com/share?text=%EB%8F%84%EC%BB%A4%EB%A5%BC+%EC%9D%B4%EC%9A%A9%ED%95%9C+%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4+%EB%AC%B4%EC%A4%91%EB%8B%A8+%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0&amp;url=https://subicura.com/2016/06/07/zero-downtime-docker-deployment"
                  onclick="window.open(this.href, 'twitter-share', 'width=550,height=255');return false;">
                <i class="nf nf-fa-twitter"></i><span class="hidden">twitter</span>
                </a>
              
            
              
            
          </section>
        </footer>
        <div class="bottom-teaser cf">
          <div class="isLeft">
            <h5 class="index-headline featured"><span>Written by</span></h5>
            <section class="author">
              <div class="author-image" style="background-image: url(/assets/images/author.jpg)">Blog Logo</div>
              <h4>subicura</h4>
              <p class="bio"></p>
              <hr>
              <p class="published">Published <time datetime="2016-06-07 00:00">07 Jun 2016</time></p>
            </section>
            <footer class="subscribe-info">
                <section class="poweredby">Proudly published with <a href="http://jekyllrb.com"> Jekyll</a></section>
                <a class="subscribe" href="http://bit.ly/2A8Dkav"  target="blank"><img id='feedlyFollow' src='//s3.feedly.com/img/follows/feedly-follow-logo-black_2x.png' alt='follow us in feedly' width='18' height='18'> Feedly 구독하기</a><br />
                <a class="subscribe" href="/feed.xml"> <span class="tooltip"> <i class="nf nf-fa-rss"></i> RSS 구독하기</span></a><br />
                 
                  <a class="subscribe" href="http://eepurl.com/cywDtP" target="_blank"> <span class="tooltip"> <i class="nf nf-oct-mail"></i> Email 구독하기</span></a>
                
            </footer>
          </div>

          <div class="isRight">
            <h5 class="index-headline featured"><span>Supported by</span></h5>
            <div class="googleads">
              
                <!-- 기본 광고 -->
                <ins class="adsbygoogle"
                    style="display:block"
                    data-ad-client="ca-pub-2468713653725581"
                    data-ad-slot="1015072194"
                    data-ad-format="auto"></ins>
                <script>
                (adsbygoogle = window.adsbygoogle || []).push({});
                </script>
              
            </div>
          </div>
        </div>

        

         
        <div class="fb-comments-wrapper">
           
            <div class="fb-comments" data-href="http://subicura.com/2016/06/07/zero-downtime-docker-deployment.html" data-num-posts="5" data-order-by="social" data-width="100%"></div>
          
        </div>
        

        
      </article>
    </main>

    <aside class="read-next">
      
        <a class="read-next-story no-cover" href="/2016/06/13/start-go-shipment-tracking-opensource.html">
          <section class="post">
            <h2>Go언어로 오픈소스 배송조회 서비스 만들기</h2>
            <p>홈쇼핑처럼에서 세번째로 런칭한 돈까스를 구매해 주시는 분들을 보면서 *아.. 받은 만큼 나도 뭔가 베풀어야겠구나* 라는...</p>
          </section>
        </a>
      
      
        <a class="read-next-story prev no-cover" href="/2016/05/30/likehs-develop-log.html">
          <section class="post">
            <h2>홈쇼핑처럼 개발후기</h2>
            <p>홈쇼핑처럼x불맛쌀떡볶이를 배송받으면서 그동안 "홈쇼핑처럼"을 개발했던 내용이 떠올라 후기로 정리합니다. 기술적으로 고민했던 것과 어떤 기술들을 사용했는지를...</p>
          </section>
        </a>
      
    </aside>
    <footer class="post-site-footer clearfix">
      <section class="copyright"><a href="/">Subicura's Blog</a> © 2022</section>
    </footer>

    <script type="text/javascript" src="/assets/js/jquery-1.11.1.min.js"></script>

    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/assets/js/index.js?1648601050285363000"></script>
<script type="text/javascript" src="/assets/js/readingtime.js"></script>
<script type="text/javascript" src="/assets/js/asciinema-player.js"></script>
<script>
(function ($) {
  "use strict";
  $(document).ready(function(){

    var $window = $(window),
    $image = $('.post-image-image, .teaserimage-image');

      $window.on('scroll', function() {
        var top = $window.scrollTop();

        if (top < 0 || top > 1500) { return; }
        $image
          .css('transform', 'translate3d(0px, '+top/3+'px, 0px)')
          .css('opacity', 1-Math.max(top/700, 0));
      });
      $window.trigger('scroll');

      var height = $('.article-image').height();
      $('.post-content').css('padding-top', height + 'px');

      $('a[href*=#]:not([href=#])').click(function() {
        if (location.pathname.replace(/^\//,'') == this.pathname.replace(/^\//,'')
         && location.hostname == this.hostname) {
          var target = $(this.hash);
          target = target.length ? target : $('[name=' + this.hash.slice(1) +']');
          if (target.length) {
            $('html,body').animate({ scrollTop: target.offset().top }, 500);
            return false;
          }
        }
      });

  });
}(jQuery));
</script>

  </body>
</html>
