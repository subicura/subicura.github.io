<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Subicura's Blog</title>
    <description>서비큐라 기술 블로그
</description>
    <link>https://subicura.com/</link>
    <atom:link href="https://subicura.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 30 Jun 2021 08:45:43 +0900</pubDate>
    <lastBuildDate>Wed, 30 Jun 2021 08:45:43 +0900</lastBuildDate>
    <generator>Jekyll v3.9.0</generator>
    
      <item>
        <title>초보 웹 개발자를 위한 학습 안내서</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2021-06-27-study-guide/interview.jpg&quot; alt=&quot;경력있는 신입&quot; /&gt;&lt;/p&gt;

&lt;p&gt;많은 회사가 개발자가 부족하다고 하는데, 신입 개발자는 취업이 어려운 게 현실입니다. 아무래도 예전보다 개발자에게 원하는 요구사항이 많아졌고, 경력 있는(?) 신입이나 특별한 교육이 필요 없는 개발자를 찾기 때문인 것 같습니다.&lt;/p&gt;

&lt;p&gt;예전에&lt;del&gt;라떼&lt;/del&gt;는 Git이나 GitHub 같은 버전 관리 시스템도 없고 JavaScript는 마우스 오버 시 버튼의 이미지 바꾸는 정도로만 사용했습니다. API는 Win32 API 같은 거 부를 때 쓰는 말이지 지금처럼 브라우저에서 동적으로 서버랑 통신하는 건 마법 같은 기술이었습니다.&lt;/p&gt;

&lt;p&gt;WEB 2.0 시대가 지나고 웹 기술이 폭발적으로 성장하면서 예전이랑은 비교할 수 없을 만큼 시스템이 복잡하고 고도화되었습니다. 빠르게 발전한 기술만큼 개발자가 공부해야 할 내용도 많아졌고, 예전보다 신입 개발자에게 원하는 수준이 훨씬 높아졌습니다.&lt;/p&gt;

&lt;p&gt;다행인 것은 개발환경이나 학습환경도 예전과 비교할 수 없을 만큼 좋아졌다는 것입니다. 서버는 클릭 한 번으로 만들 수 있고 컴파일하는 시간&lt;del&gt;커피타임&lt;/del&gt;도 수백 배는 빨라졌습니다. 수많은 온/오프라인 강의와 초고수 개발자들의 노하우를 지하철에서 배울 수 있게 되었습니다.&lt;/p&gt;

&lt;p&gt;이글은 이러한 흐름 속에서 개발자로 취업을 준비 중이거나 좀 더 성장하고 싶은 초보 개발자를 위한 조언을 담고 있습니다. 그동안의 경험과 이력서를 검토하고 면접을 진행하면서 느낀 점, 개발자로 취업을 준비 중인 사촌 동생에게 했던 조언, 개인적으로 멘토링을 하면서 했던 이야기를 모았습니다.&lt;/p&gt;

&lt;p&gt;이 글이 더 좋은 개발자로 성장하는 데 도움이 되길 바라고, 혹시 내용에 공감하고 괜찮은 개발회사를 찾고 있다면 &lt;a href=&quot;https://purple.io&quot;&gt;우리 회사에 지원&lt;/a&gt;하셔도 좋습니다. 제가 잘 교육해드림.. 🙇‍♂️&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;a href=&quot;https://purple.io&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/purpleio_bookmark.png&quot; style=&quot;width: 420px&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;h2 id=&quot;어떤-개발자가-있나요&quot;&gt;어떤 개발자가 있나요?&lt;/h2&gt;

&lt;p&gt;웹 개발 기준으로 크게 프론트엔드&lt;sup&gt;frontend&lt;/sup&gt;, 백엔드&lt;sup&gt;backend&lt;/sup&gt;, 인프라(DevOps) 개발자가 있고 앱(iOS, Android), 게임, 머신러닝/AI, 데이터분석 쪽도 별도로 구분합니다.&lt;/p&gt;

&lt;p&gt;예전엔 뭔가 이렇게 구분하지 않고 개발자면 이것저것 다 &lt;del&gt;사무실 랜선도 깔고&lt;/del&gt; 했는데 점점 기술이 고도화되고 새로운 개발 방식, 각종 라이브러리/프레임워크가 끊임없이 나오면서 전체를 다 하기가 어려워졌습니다. 물론, 전체를 두루두루 하는 풀스택이라는 &lt;del&gt;전설 속의&lt;/del&gt; 직군이 있긴 하지만 드문 케이스입니다.&lt;/p&gt;

&lt;p&gt;프론트엔드나 백엔드등 특정 방향을 정하고 한 우물을 파는 게 바람직하지만, 협업하고 무언가를 만들려면 다른 분야를 이해하고 기본적인 내용은 익혀두는 것이 좋습니다. 결국, A를 잘하려면 B를 이해해야 하고 B를 잘 이해하려면 C가 도움이 되기 때문입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;큰 회사(일명 네카라쿠배)는 특정 분야의 전문가(=스페셜리스트)를 원하는 경우가 많고 스타트업이나 작은 회사일수록 동시에 여러 가지를 하는 사람(=제너럴리스트)을 원하는 경우가 많습니다. 제너럴리스트는 자칫 잡부처럼 느껴질 수 있지만, 성장에 도움이 된다면 여러 가지 경험을 하는 것도 나쁘지 않다고 생각합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;어떤걸-공부할까요&quot;&gt;어떤걸 공부할까요?&lt;/h2&gt;

&lt;h3 id=&quot;웹-개발자-학습-로드맵&quot;&gt;웹 개발자 학습 로드맵&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/kamranahmedse/developer-roadmap/tree/master/translations/korean&quot;&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2021-06-27-study-guide/intro.png&quot; alt=&quot;intro&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/kamranahmedse/developer-roadmap/tree/master/translations/korean&quot;&gt;Kamran Ahmed가 만든 웹 개발자 로드맵&lt;/a&gt;은 웹 개발자가 되기 위해 선택하고 거쳐야 할 기술을 프론트엔드, 백엔드, 데브옵스별로 나누어 제공합니다. 필수적인 내용이 빠짐없이 정리되어 있고 최신 트랜드가 포함되어 있어 어떤 걸 공부할지 갈피를 못 잡고 있다면 방향을 잡기에 좋습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/kamranahmedse/developer-roadmap/tree/master/translations/korean#%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%A1%9C%EB%93%9C%EB%A7%B5&quot;&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2021-06-27-study-guide/frontend.png&quot; alt=&quot;frontend&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;프론트엔드를 살펴보면 인터넷, HTML/CSS/JavaScript부터 패키지 관리자, React와 같은 프레임워크, CSS 프레임워크를 거쳐 서버사이드 렌더링, 정적 사이트 생성기, 웹어셈블리까지 정리가 되어 있습니다. 깔-끔&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/kamranahmedse/developer-roadmap/tree/master/translations/korean#%EB%B0%B1%EC%97%94%EB%93%9C-%EB%A1%9C%EB%93%9C%EB%A7%B5&quot;&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2021-06-27-study-guide/backend.png&quot; alt=&quot;backend&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;백엔드는 인터넷, 프론트엔드 기본 지식(?!), OS에 대한 전반적인 지식, 언어, 데이터베이스, 캐시, CI/CD, 컨테이너, 웹서버를 소개합니다. 역시 깔-끔&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/legend.png&quot; style=&quot;width: 350px&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;항목마다 중요도가 표시되어 있는데, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;추천/개인적인 의견&lt;/code&gt; 항목은 조금 더 자세히 공부하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;대체 가능한 옵션&lt;/code&gt;은 적어도 어떤 기술인지 기본적인 내용은 알아두는 것이 좋습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;선택사항&lt;/code&gt;이나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;추천하지 않음&lt;/code&gt; 항목은 반드시 공부해야 하는 건 아니고 이런 게 있구나! 정도는 알면 좋을 것 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;너무 공부할게 많아요 ㅠㅠ 🤦&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;로드맵 내용은 학습할 수 있는 모든 것을 담고 있기 때문에 초보 입장에서는 당연히 부담스러울 수 있습니다. &lt;del&gt;언젠가 다 알면 좋지만..&lt;/del&gt; 제한된 시간에 모든 걸 공부하는 건 불가능하기 때문에 몇 가지를 깊이 이해하는 것이 중요합니다. “내가 시간이 없어서 그렇지 깊게 파면 이렇게 잘할 수 있다!”라는 걸 어필할 수 있다면, 회사 입장에서도 “뽑은 다음에 키우면 되겠다”라고 생각할 수 있습니다.&lt;/p&gt;

&lt;p&gt;예를 들어, React.js를 사용하는 회사에서 React.js, Vue.js, Angular를 전부 얕게 아는 사람과 Vue.js를 깊이 이해하는 사람이 있다면 후자를 더 좋게 평가할 것입니다. 후자는 무언가를 잘 할 수 있다는 확실히 능력을 보여주었지만, 전자는 알 수 없기 때문입니다.&lt;/p&gt;

&lt;h3 id=&quot;코딩테스트&quot;&gt;코딩테스트&lt;/h3&gt;

&lt;p&gt;“코딩테스트 준비는 얼마나 해야 하나요?” 코딩테스트 공부가 재미없고 시간이 아깝다고 생각하는 분들에게 많이 듣는 질문입니다.&lt;/p&gt;

&lt;p&gt;코딩테스트는 크게 알고리즘형과 제시된 프로그램을 구현하는 프로젝트형이 있습니다. 알고리즘형 코딩테스트를 하는 이유는 보통 지원자가 너무 많기 때문에 효율적으로 평가하기 위함입니다. 코딩테스트의 실효성에 대해서는 여러 가지 의견이 있지만, 특정 수준 이상의 코딩테스트를 통과하면 기본적인 문제해결 능력이 있다고 판단하는 거죠.&lt;/p&gt;

&lt;p&gt;요즘은 대부분의 회사가 코딩테스트를 진행하기 때문에 실무와 별개로 따로 준비해야 합니다. DFS/BFS와 같은 그래프 탐색 알고리즘을 공부하고 유명한 자료구조를 이해해야 합니다. 보통 코딩테스트 사이트에서 수십~수백 개의 문제를 푸는데, 더 깊게 공부할지는 지원하는 회사의 요구사항이나 난이도에 따라 다릅니다. 가고 싶은 회사가 높은 수준을 요구하면 그만큼 준비해야 하는 거죠 뭐;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;개인적으로 알고리즘형 코딩테스트는 개발자의 지극히 일부만 평가할 수 있어 좋은 평가 방식은 아니라고 생각하지만, 적어도 정답을 보고 공부하면 해당 알고리즘을 이해하고 간단하게 구현할 수 있는 수준은 되어야 합니다. 나중에 필요할 때 찾아서 할 수 있는 것과 해보지 않은 것은 차이가 있기 때문입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;코딩테스트를 준비하다 보면 실무와 크게 상관없다고 느끼고 학습 자체가 지루할 수 있습니다. 코딩 테스트가 의미 없어 보이고 나는 뚝딱뚝딱 무언가를 만드는 게 좋다면, 재미있는 부분에 더 집중하고 알고리즘보다 프로젝트형 코딩테스트를 보는 회사에 지원하는 것도 방법입니다.&lt;/p&gt;

&lt;p&gt;다음은 코딩테스트를 준비할 수 있는 사이트입니다.&lt;/p&gt;

&lt;p align=&quot;left&quot; style=&quot;padding-bottom: 0&quot;&gt;
    &lt;a href=&quot;https://www.acmicpc.net/&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/baekjoon_bookmark.png&quot; style=&quot;width: 420px&quot; alt=&quot;Baekjoon Online Judge&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;국내 서비스 중 가장 유명한 온라인 코딩테스트 서비스 / 수많은 프로그래밍 문제를 풀고 온라인으로 채점 받을 수 있음&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;a href=&quot;https://programmers.co.kr/&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/programmers_bookmark.png&quot; style=&quot;width: 420px&quot; alt=&quot;프로그래머스&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Kakao/Line/Naver 등 많은 회사에서 사용 중인 코딩테스트 서비스&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;a href=&quot;https://leetcode.com/&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/leetcode_bookmark.png&quot; style=&quot;width: 420px&quot; alt=&quot;LeetCode&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;글로벌에서 가장 유명한 코딩테스트 서비스&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;기본기&quot;&gt;기본기&lt;/h3&gt;

&lt;p&gt;고도화되고 추상화된 라이브러리, 프레임워크가 많아지면서 포트폴리오는 훌륭한데 그에 비해 기본 지식이 부족한 경우가 있습니다. 기본 지식이라고 하면 흔히 “컴퓨터 관련 전공자”가 배우는 CS 커리큘럼과 언어, 프레임워크의 동작 원리 등입니다.&lt;/p&gt;

&lt;p&gt;조금 더 구체적인 예를 위해 22년 동안 개발자 지원 서류를 수천 건은 검토하고, 면접을 최소 일천 번 이상 보신 &lt;a href=&quot;https://www.facebook.com/dgtgrade/posts/3654195844639255&quot;&gt;남세동님께서 작성하신 기초 질문들&lt;/a&gt;을 볼까요?&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.facebook.com/dgtgrade/posts/3654195844639255&quot;&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2021-06-27-study-guide/question.png&quot; alt=&quot;남세동님 글&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;1바이트는 몇 비트인가요?&lt;/li&gt;
  &lt;li&gt;1픽셀은 몇바이트인가요?&lt;/li&gt;
  &lt;li&gt;2^10은 얼마인가요?&lt;/li&gt;
  &lt;li&gt;Stack과 Queue의 차이가 뭔가요?&lt;/li&gt;
  &lt;li&gt;Binary Tree의 시간 복잡도가 어떻게 되나요?&lt;/li&gt;
  &lt;li&gt;DNS의 역할이 무엇인가요?&lt;/li&gt;
  &lt;li&gt;HTTPS와 HTTP의 차이는 뭔가요?&lt;/li&gt;
  &lt;li&gt;스마트폰 카메라 해상도가 (대강) 어떻게 되나요?&lt;/li&gt;
  &lt;li&gt;왜 사진에는 JPG를 쓸까요?&lt;/li&gt;
  &lt;li&gt;칼라값 ffffff는 무슨 색인가요?&lt;/li&gt;
  &lt;li&gt;&amp;lt;a href&amp;gt;가 무슨 뜻인가요?&lt;/li&gt;
  &lt;li&gt;call by reference가 무슨 말인가요?&lt;/li&gt;
  &lt;li&gt;Event Listener가 무슨 말인가요?&lt;/li&gt;
  &lt;li&gt;OOP에서 상속이 무슨 말인가요?&lt;/li&gt;
  &lt;li&gt;non-blocking call이 뭔가요?&lt;/li&gt;
  &lt;li&gt;버전관리에서 commit이 뭔가요?&lt;/li&gt;
  &lt;li&gt;try/catch는 무슨 뜻인가요?&lt;/li&gt;
  &lt;li&gt;디버깅 할때 breakpoint가 뭔가요?&lt;/li&gt;
  &lt;li&gt;패스워드는 서버에 어떻게 보관되나요?&lt;/li&gt;
  &lt;li&gt;SSD가 HDD보다 빠른 이유가 뭔가요?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;개발에 관심이 있고 꾸준히 공부한 사람인지를 판단하기 굉장히 좋은 질문이라고 생각합니다. 이러한 질문에 대답하기 위해 따로 공부한다면 “어떻게 준비하지..?” 라는 생각이 듭니다. 2의 10승을 일부러 외우진 않지만, 개발을 하다보면 1024, 2048, 4096, 65536 같은 거가 익숙하단 말이죠. &lt;del&gt;Hex 에디터의 추억?&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;기본기를 익히는 것은 아쉽게도 지름길이 없습니다. 내용이 너무 방대하고 따로 CS 학습을 하려면 시간이 부족하기 때문에, 평소에 틈틈이 호기심을 가지고 더 많이 찾아보고 더 깊이 학습하는 방법이 최선인 것 같습니다.&lt;/p&gt;

&lt;p&gt;예를 들어, 자주 사용하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rand()&lt;/code&gt; 함수를 그냥 사용만 하지 않고, “0, 1밖에 모르는 컴퓨터가 어떻게 “랜덤”한 숫자를 임의로 고르는 걸까?”, “진짜 랜덤한가?”, “특정 조건에서 원하는 값을 구할 수 없을까?” 하고 궁금할 수 있습니다. Hash/Map 같은 구조(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data['key'] = value&lt;/code&gt;)를 쓰다 보면 “이런 데이터는 메모리에서 어떻게 관리될까?” 궁금할 수 있습니다. 일반적인 배열은 0, 1, 2, 3 순차적으로 저장이 될 텐데 key는 순서랑 상관없는 문자열이기 때문에 뭔가 다르게 저장될 것 같은 거죠. 미리 메모리 영역을 잡아 놓을까? 어느 정도 크기로 잡을까? 중복은 어떻게 처리하지? 같은 궁금증이 막 생기죠? &lt;del&gt;나만 생기나요? ㅠㅠ&lt;/del&gt; React를 공부하고 있다면 “이런 라이브러리를 처음부터 만들려면 어떻게 해야 할까?” 하고 원리를 궁금해할 수 있습니다.&lt;/p&gt;

&lt;p&gt;다행히 요즘은 인터넷에 검색하면 상세한 답변을 쉽게 찾을 수 있어 지하철을 타고 이동하거나 중간중간 짬이 나는 시간에 호기심을 해결하다 보면 자기도 모르게 기본 지식을 쌓을 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;어떻게-공부하는-게-좋을까요&quot;&gt;어떻게 공부하는 게 좋을까요?&lt;/h2&gt;

&lt;p&gt;지금까지 무엇을 공부할지 이야기했고 어떻게 공부할지 알아보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;클론코딩&quot;&gt;클론코딩&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2021-06-27-study-guide/clone.jpg&quot; alt=&quot;Clone Coding&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클론코딩은 페이스북, 트위터 같은 서비스를 따라 만들면서 배우는 학습 방법입니다. 내가 사용하는 서비스를 내 손으로 직접 만들면서 오는 흥미와 실용적인 방법, 포트폴리오로 제출하기도 좋아 많이 사용하는 방법입니다.&lt;/p&gt;

&lt;p&gt;처음 이력서에 클론코딩 내용이 있으면 신기하면서(신입이 이걸??) 높게 평가했는데 어느 순간 공장에서 찍어서 나오는 것 같은 느낌을 받고 뭔가 이상하다고 느낀 적이 있습니다. 그 시점에 많은 온/오프라인 강의와 학원에서 클론코딩을 하고 있다는 걸 알았고 이력서에 적힌 클론 코딩 항목의 신뢰가 떨어지게 되었습니다.&lt;/p&gt;

&lt;p&gt;클론 코딩 자체는 좋은 학습 방법이라고 생각하는데, 강사의 코드를 거의 그대로 복사하거나 직접 만들었다고 하는데 특정 부분을 물어보면 잘 모르는 경우가 문제였습니다. 단순히 결과물만 보여주기보다는 그걸 만들면서 어떤 걸 배웠고 어떤 게 어려웠는지, 그걸 어떻게 해결했는지 정리하는 것이 필요합니다. 멋진 기술을 쓰고 결과물이 아무리 좋더라도 스스로 한 것인지 도움을 받은 것인지 알 수 없기 때문에 과정이 궁금할 수밖에 없습니다.&lt;/p&gt;

&lt;p&gt;그리고, 그 과정에서 최소 하나 이상 깊게 고민한 기능/기술이 있으면 좋습니다. 모방은 창조의 어머니라고 하지만 모방만으로 끝나서는 의미가 없습니다.&lt;/p&gt;

&lt;p&gt;예를 들면, 이미지를 업로드 하는 기능에 리사이즈 기능을 추가한다던가, 영상을 업로드하면 gif로 변환한다던가, 소셜 공유 기능을 넣고 OpenGraph 이미지를 생성하는 라이브러리를 붙여본다던가, 무엇이 되었든 새로운 기능이 있어야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;토이프로젝트사이드프로젝트&quot;&gt;토이프로젝트/사이드프로젝트&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2021-06-27-study-guide/side_project.png&quot; alt=&quot;Toy Project&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아주 작은 아이디어 &amp;amp; 프로그램을 처음부터 끝까지 만들고 실제 운영까지 해보는 작업입니다. 재미도 있고 새로운 기술도 배우고, 혹시 모르면 추가적인 수입이 있을 수도.. 👀&lt;/p&gt;

&lt;p&gt;먼저 결정할 것은 혼자 할지, 팀을 만들어서 할지 인 데 개인적으로는 혼자 작은 사이즈로 만드는 것을 추천합니다. 좋은 팀을 만드는 것도 어렵지만, 만들었다고 하더라도 중간에 먼저 취업이 되거나 개인 사정으로 팀원들이 빠지면 결국 완성이 안 되고 흐지부지되는 경우가 많기 때문입니다.&lt;/p&gt;

&lt;p&gt;혼자서 풀 스택 경험을 해보면 내가 어떤 분야에 관심이 있고, 어떤 기술을 싫어하는지, 좋아하는지 파악할 수 있습니다. 만약 프론트엔드가 너무 재미없고 집중이 안 된다면 명확하게 선을 긋고 백엔드에 집중할 수도 있습니다. 문제는 만들면서 내가 잘하고 있는 게 맞나..하는 생각이 들 수 있는데, 일단 기능을 만드는 것에 집중하고 문제가 생기면 자연스럽게 구글링 등을 하면서 해결해가는 것이 좋습니다. 너무 고민이 된다면 페이스북 그룹이나 커뮤니티, twitter 등에 문의하면 됩니다. 깊게 고민하고 질문을 한다면 그만큼 좋은 대답을 들을 수 있습니다.&lt;/p&gt;

&lt;p&gt;토이 프로젝트를 완성하여 오픈 소스화하거나, 직접 운영을 하고 개선해 나간다면 실력도 쌓고 취업에서도 좋은 평가를 받을 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;스터디-모임&quot;&gt;스터디 모임&lt;/h3&gt;

&lt;p&gt;개인적으로 “좋은 스터디” 모임에서 “좋은 사람들”과 함께 학습하는 것만큼 좋은 건 없다고 생각합니다.&lt;/p&gt;

&lt;p&gt;한참 새로운 기술에 목마르던 꼬꼬마 시절, “데브 스터디”라는 스터디 모임을 페이스북을 통해 접했는데, 혼자서는 알 수 없던 최신 프론트 개발 트랜드를 익히고 또 다른 스터디(도커, 쿠버네티스)까지 확장할 수 있던 너무 소중한 시간이었습니다. (그때 처음 스터디한 Grunt, Yeoman, Bower는 이제 사라진 기술이 되었네요 😅)&lt;/p&gt;

&lt;p&gt;스터디 모임의 장점은 혼자 하면 학습하기 어려운 것들을 빠르게 습득할 수 있다는 것과 여러 사람의 노하우를 자연스레 습득할 수 있다는 점입니다. 내가 우물 안 개구리였다는 것도 알게 되고 이렇게 잘하는 분들이 많구나 하는 자극을 받아 더 열심히 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;제가 속했던 스터디 모임은 우연히 다음과 같은 공통점이 있었습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;개발에 대한 열정 🔥
    &lt;ol&gt;
      &lt;li&gt;스터디 모임이 끝나도 커피를 마시며 몇 시간 동안 개발 얘기 함&lt;/li&gt;
      &lt;li&gt;지하철 타고 가면서도 개발 얘기 함;&lt;/li&gt;
      &lt;li&gt;단톡방에서도 개발 얘기 함;;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;스터디 방식 📖
    &lt;ol&gt;
      &lt;li&gt;약 10회 분량의 주제를 정하거나 한 권의 책을 정함&lt;/li&gt;
      &lt;li&gt;1주일 동안 다 같이 공부하고 노션에 정리 (공동 편집)&lt;/li&gt;
      &lt;li&gt;당일 발표자 선정 - 내가 발표할 수도 있다는 부담감으로 열심히..!&lt;/li&gt;
      &lt;li&gt;발표 중 막히는 부분은 서로서로 도와주고 더 자세히 아는 내용이 있으면 추가 공유&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;모각코&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;모각코는 “모여서 각자 코딩”의 약자로 약간 가벼운 버전의 스터디 모임입니다.&lt;del&gt;만 코로나 때문에…&lt;/del&gt; 부담 없이 참석하여 질문/답변을 할 수 있고 좋은 분을 만날 수도 있으니 스터디가 부담스러우면 추천합니다.&lt;/p&gt;

&lt;p&gt;다음은 스터디 모임/모각코를 찾을 수 있는 서비스입니다.&lt;/p&gt;

&lt;p align=&quot;center&quot; style=&quot;padding-bottom: 0&quot;&gt;
    &lt;a href=&quot;https://okky.kr/articles/gathering&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/okky_study_bookmark.png&quot; style=&quot;width: 420px&quot; alt=&quot;OKKY - 정기모임/스터디&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;p align=&quot;center&quot; style=&quot;padding-bottom: 0&quot;&gt;
    &lt;a href=&quot;https://www.facebook.com/search/top/?q=%EB%AA%A8%EA%B0%81%EC%BD%94&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/fb_study_bookmark.png&quot; style=&quot;width: 420px&quot; alt=&quot;페이스북 - 모각코&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;h3 id=&quot;온라인-강의&quot;&gt;온라인 강의&lt;/h3&gt;

&lt;p&gt;요즘 학습 환경의 가장 큰 특징은 고품질의 온라인 강의를 쉽게 접할 수 있다는 것입니다. 예전에는 돈 주고도 들을 수 없던 여러 가지 노하우를 고오오급 개발자분들이 틈틈이 시간을 내어 강의를 만들어주신 덕분에 집에서 편하게 들을 수 있게 되었습니다.&lt;/p&gt;

&lt;p&gt;온라인 강의는 제한된 시간에 핵심적인 내용 위주로 설명하는 경우가 많기 때문에 빠르게 무언가를 익히기엔 좋지만 깊게 이해하기엔 부족할 수 있습니다. 온라인 강의로 감을 잡고 공식문서와 관련 책을 학습하여 좀 더 깊게 이해하는 것이 좋습니다.&lt;/p&gt;

&lt;p&gt;요즘 부쩍 온라인 강의 서비스들이 많아졌는데, 경험했던 서비스 위주로 소개합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot; style=&quot;padding-bottom: 0&quot;&gt;
    &lt;a href=&quot;https://opentutorials.org/course/1&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/open_bookmark.png&quot; style=&quot;width: 420px&quot; alt=&quot;생활코딩&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;초보자를 대상으로 개발의 기초가 되는 부분을 자세히 설명해줌&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p align=&quot;center&quot; style=&quot;padding-bottom: 0&quot;&gt;
    &lt;a href=&quot;https://tacademy.skplanet.com&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/tacademy_bookmark.png&quot; style=&quot;width: 420px&quot; alt=&quot;T 아카데미&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;인공지능, 데이터 사이언스, 프로그램 관련 양질의 강의를 무료로 들을 수 있음&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p align=&quot;center&quot; style=&quot;padding-bottom: 0&quot;&gt;
    &lt;a href=&quot;https://www.inflearn.com/&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/inflearn_bookmark.png&quot; style=&quot;width: 420px&quot; alt=&quot;인프런&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;부담 없는 가격에 유명 강사의 고퀄리티 강의가 많음 / 제가 만든 &lt;a href=&quot;https://www.inflearn.com/course/도커-입문?inst=446961aa&quot; target=&quot;_blank&quot;&gt;도커&lt;/a&gt;와 &lt;a href=&quot;https://www.inflearn.com/course/쿠버네티스-입문?inst=bc9bb710&quot; target=&quot;_blank&quot;&gt;쿠버네티스&lt;/a&gt; 강의도 들어보세요 &lt;del&gt;중간광고&lt;/del&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;컨퍼런스&quot;&gt;컨퍼런스&lt;/h3&gt;

&lt;p&gt;컨퍼런스는 최신 트랜드를 알 수 있고 실무를 하면서 고민고민고민했던 내용을 빠르게 습득할 좋은 기회입니다. 예전엔 보통 오프라인으로 컨퍼런스를 열고 &lt;del&gt;맛있는 밥과 기념품도 주고&lt;/del&gt; 관련 업체 부스를 탐방하는 재미가 있었는데 최근엔 코로나의 영향으로 대부분 온라인으로 진행하고 있습니다.&lt;/p&gt;

&lt;p&gt;컨퍼런스는 좋은 내용이 많지만, 너무 전문적이고 광범위한 경우가 많아, 처음부터 끝까지 보는 것보단 고민했던 내용, 지금 하고 있는 것과 관련이 있는 것을 잘 골라서 보는 것이 좋습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2021-06-27-study-guide/kakao_junior.png&quot; alt=&quot;ifkakao - 직장인 VLOG&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;꼭 전문적인 기술만 발표하지 않습니다. 초보 개발자를 위한 내용도 많이 있어요~&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;🤔 그런데 말입니다… 이상하게도 지나간 컨퍼런스는 잘 안 보게됩니다 ㅠㅠ. (왜 그런지 아시는 분?) 그래서 컨퍼런스를 한다고 하면 가급적 시간을 내어 라이브로 참석하는 것을 추천합니다. 그래야 더 집중해서 보고 참석률도 높은 것 같습니다.&lt;/p&gt;

&lt;p&gt;주요 컨퍼런스는 다음 링크에서 확인하세요!&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;a href=&quot;https://www.44bits.io/ko/post/replay-2020-korea-it-conferences&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/44bits_conf_bookmark.png&quot; style=&quot;width: 420px&quot; alt=&quot;2020 한국의 주요 IT 컨퍼런스 다시 보기&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;h3 id=&quot;책&quot;&gt;책&lt;/h3&gt;

&lt;p&gt;책의 인기가 예전보다 많이 시들해진 것 같지만, 훌륭한 선배들의 생각과 노하우를 익히기엔 역시 책만한게 없습니다. 개인적으로 추천하는 책은 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;기본 소양&lt;/strong&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot; style=&quot;padding-bottom: 0&quot;&gt;
    &lt;a href=&quot;http://naver.me/x9JEa3oM&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/book_grow.jpeg&quot; style=&quot;width: 200px&quot; alt=&quot;함께 자라기 - 애자일로 가는 길 (김창준/인사이트)&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;성장, 협업, 학습에 대한 나의 태도를 바꿀 수 있는 영향력 있는 책&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p align=&quot;center&quot; style=&quot;padding-bottom: 0&quot;&gt;
    &lt;a href=&quot;http://naver.me/xC6bAhpf&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/book_pragmatic.jpeg&quot; style=&quot;width: 200px&quot; alt=&quot;실용주의 프로그래머 (앤드류 헌트 외/인사이트)&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그냥 개발자에서 뼛속까지 개발자가 될 수 있는 여러가지 팁 소개&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p align=&quot;center&quot; style=&quot;padding-bottom: 0&quot;&gt;
    &lt;a href=&quot;http://naver.me/GUv7ZV1t&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/book_refactoring.jpeg&quot; style=&quot;width: 200px&quot; alt=&quot;리팩터링 (마틴 파울러/한빛미디어)&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;더 나은 코드를 작성하고 싶다면 반드시 읽어야 하는 필독서&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p align=&quot;center&quot; style=&quot;padding-bottom: 0&quot;&gt;
    &lt;a href=&quot;http://naver.me/FOvDgE7f&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/book_pattern.jpg&quot; style=&quot;width: 200px&quot; alt=&quot;Head First Design Patterns (에릭 프리먼/한빛미디어)&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;입문자를 위한 디자인 패턴 교과서&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;자기개발&lt;/strong&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot; style=&quot;padding-bottom: 0&quot;&gt;
    &lt;a href=&quot;http://naver.me/xcKZRRzU&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/book_craftsmanship.jpg&quot; style=&quot;width: 200px&quot; alt=&quot;소프트웨어 장인 - 프로페셔널리즘, 실용주의, 자부심 (산드로 만쿠소/길벗)&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;소프트웨어 장인의 실용적인 조언&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p align=&quot;center&quot; style=&quot;padding-bottom: 0&quot;&gt;
    &lt;a href=&quot;http://naver.me/FOvDgE7f&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/book_softskill.jpg&quot; style=&quot;width: 200px&quot; alt=&quot;소프트 스킬 (존 손메즈/길벗)&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;개발자로 사는 데 도움이 되는 정보와 조언을 집약적으로 담은 안내서&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p align=&quot;center&quot; style=&quot;padding-bottom: 0&quot;&gt;
    &lt;a href=&quot;http://naver.me/x8lS0YKj&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/book_joel.jpg&quot; style=&quot;width: 200px&quot; alt=&quot;조엘 온 소프트웨어 (조엘 스폴스키/에이콘)&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;조엘의 블로그에서 인기글만 뽑아 엮은 책. 우리회사는 조엘 테스트 몇점일까?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p align=&quot;center&quot; style=&quot;padding-bottom: 0&quot;&gt;
    &lt;a href=&quot;http://naver.me/5HSi9BL9&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/book_unix.jpeg&quot; style=&quot;width: 200px&quot; alt=&quot;유닉스의 탄생 (브라이언 커니핸/한빛미디어)&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;유닉스가 무엇인지, 어떤 이유로 개발 되었는지, 어떤 과정을 거쳐 발전했는지 정말 생생하게 느낄 수 있는 책&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p align=&quot;center&quot; style=&quot;padding-bottom: 0&quot;&gt;
    &lt;a href=&quot;http://naver.me/FEJTzTMe&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/book_painter.jpg&quot; style=&quot;width: 200px&quot; alt=&quot;해커와 화가 (폴 그레이엄/한빛미디어)&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Y Combinator의 폴 그레이엄의 에세이 형식의 프로그래밍 이야기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p align=&quot;center&quot; style=&quot;padding-bottom: 0&quot;&gt;
    &lt;a href=&quot;http://naver.me/GROTg4au&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/book_founder.jpg&quot; style=&quot;width: 200px&quot; alt=&quot;세상을 바꾼 32개의 통찰 (제시카 리빙스턴/크리에디트)&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;지금은 사라진 서비스도 있지만, 21세기를 바꾼 서비스가 어떻게 만들어졌는지 알 수 있는 책&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p align=&quot;center&quot; style=&quot;padding-bottom: 0&quot;&gt;
    &lt;a href=&quot;http://naver.me/GZAryBoT&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/book_http.jpeg&quot; style=&quot;width: 200px&quot; alt=&quot;HTTP 완벽 가이드 (데이빗 고울리 외/인사이트)&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;HTTP 규약이 어떻게 작동하고 웹 기반 애플리케이션을 개발하는 데 어떻게 사용하는지 소개하는 책&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p align=&quot;center&quot; style=&quot;padding-bottom: 0&quot;&gt;
    &lt;a href=&quot;http://naver.me/5mYNQ5sJ&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/book_test.jpg&quot; style=&quot;width: 200px&quot; alt=&quot;테스트 주도 개발 (켄트 벡/인사이트)&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;테스트 주도 개발의 교과서&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p align=&quot;center&quot; style=&quot;padding-bottom: 0&quot;&gt;
    &lt;a href=&quot;http://naver.me/F7C0TKU5&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/book_extreme.jpg&quot; style=&quot;width: 200px&quot; alt=&quot;익스트림 프로그래밍 (켄트 벡/인사이트)&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;XP의 소개와 철학 안내&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 외에도 좋은 책이 많지만, 너무 길어지는 것 같아 별도 페이지로 공유합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;a href=&quot;https://mysetting.io/books&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/mysetting_book_bookmark.png&quot; style=&quot;width: 420px&quot; alt=&quot;mysetting - 책소개&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;h3 id=&quot;유투브&quot;&gt;유투브&lt;/h3&gt;

&lt;p&gt;유투브는 많이 안보지만.. 알고 있는 몇 가지 채널을 추천합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot; style=&quot;padding-bottom: 0&quot;&gt;
    &lt;a href=&quot;https://www.youtube.com/channel/UC-TpdzGorF3igglmjCWQhMA&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/youtube_44bits.png&quot; style=&quot;width: 420px&quot; alt=&quot;44bits - 인프라 전문 방송&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;p align=&quot;center&quot; style=&quot;padding-bottom: 0&quot;&gt;
    &lt;a href=&quot;https://www.youtube.com/channel/UCSEOUzkGNCT_29EU_vnBYjg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/youtube_gae.png&quot; style=&quot;width: 420px&quot; alt=&quot;개발바닥 - 본격 개발자 토크쇼&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;p align=&quot;center&quot; style=&quot;padding-bottom: 0&quot;&gt;
    &lt;a href=&quot;https://www.youtube.com/channel/UCSqtYUDXgy7RmpMazTMFSHQ&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/youtube_john.png&quot; style=&quot;width: 420px&quot; alt=&quot;존잡생각 - 솔직담백 실리콘벨리 이야기&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;p align=&quot;center&quot; style=&quot;padding-bottom: 0&quot;&gt;
    &lt;a href=&quot;https://www.youtube.com/channel/UCUpJs89fSBXNolQGOYKn0YQ&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/youtube_nomad.png&quot; style=&quot;width: 420px&quot; alt=&quot;노마드코더&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;h3 id=&quot;팟캐스트&quot;&gt;팟캐스트&lt;/h3&gt;

&lt;p&gt;이동 중일 때 편하게 들으세요. 개발 팟캐스트는 44bit를 추천합니다 :)&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;a href=&quot;http://stdout.fm/&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/podcast_44bits.png&quot; style=&quot;width: 420px&quot; alt=&quot;44BITS 팟캐스트 - 클라우드, 개발, 가젯&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;h3 id=&quot;트위터&quot;&gt;트위터&lt;/h3&gt;

&lt;p&gt;가장 핫한 트랜드 소식을 빠르게 접할 수 있는 트위터입니다. 막상 팔로우하면 개발 이야기 말고 잡담을 많이 들을 수도 있습니다만…&lt;/p&gt;

&lt;p align=&quot;center&quot; style=&quot;padding-bottom: 0&quot;&gt;
    &lt;a href=&quot;https://twitter.com/subicura&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/twitter_subicura.png&quot; style=&quot;width: 420px&quot; alt=&quot;@subicura - 저에요 🙋‍♂️ 팔로우~&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;p align=&quot;center&quot; style=&quot;padding-bottom: 0&quot;&gt;
    &lt;a href=&quot;https://twitter.com/i/lists/1391902781192110080&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/twitter_korean_developer.png&quot; style=&quot;width: 420px&quot; alt=&quot;Korean Developers List&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;h2 id=&quot;디테일을-높이자&quot;&gt;디테일을 높이자&lt;/h2&gt;

&lt;p&gt;마지막으로 조금만 더 디테일을 높여봅니다. 이왕 공부하는 거 조금 다른 시각으로 살펴볼까요?&lt;/p&gt;

&lt;h3 id=&quot;차별화하기&quot;&gt;차별화하기&lt;/h3&gt;

&lt;p&gt;취업/이직을 준비 중이라면 내가 가진 능력을 잘 포장하고 표현하는 것도 중요합니다. 면접관은 독심술사가 아니기 때문에; 표현하지 않으면 모르지 않겠습니까?&lt;/p&gt;

&lt;p&gt;이력서에 적을 수 있는 내용은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;학력 및 학과&lt;/li&gt;
  &lt;li&gt;IT 관련 직무나 IT 회사에서 일한 경력 (인턴 등)&lt;/li&gt;
  &lt;li&gt;진행한 프로젝트 소개 (포트폴리오 및 토이 프로젝트)&lt;/li&gt;
  &lt;li&gt;블로그&lt;/li&gt;
  &lt;li&gt;오픈소스 경력&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여기서 학력 및 학과, 경력은 쉽게 바꿀 수 없지만, 나머지는 노오오력으로 차별화 할 수 있습니다. 2가지 이력서가 있을 때 어느 쪽이 더 인상 깊을까요?&lt;/p&gt;

&lt;table class=&quot;table&quot;&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;항목&lt;/td&gt;
      &lt;td&gt;A 이력서&lt;/td&gt;
      &lt;td&gt;B 이력서&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;프로젝트 경력&lt;/td&gt;
      &lt;td&gt;TODO 앱 개발&lt;br /&gt;- React+Redux 사용&lt;/td&gt;
      &lt;td&gt;TODO 앱 개발&lt;br /&gt;- https://todo.subicura.com&lt;br /&gt;- AWS lightsail 배포&lt;br /&gt;- 완료 날짜를 입력하고 날짜가 다가오면 web push 전송&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;블로그&lt;/td&gt;
      &lt;td&gt;https://subicura.tistory.com&lt;br /&gt;- 단순 지식 정리 (링크소개?)&lt;br /&gt;- 글이 거의 없음&lt;/td&gt;
      &lt;td&gt;https://blog.subicura.com&lt;br /&gt;- 왜? 어떻게?와 같은 과정이 담긴 글들&lt;br /&gt;- 최근 까지 꾸준히 작성&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;오픈소스&lt;/td&gt;
      &lt;td&gt;(없음)&lt;/td&gt;
      &lt;td&gt;nodejs web push xx 이슈 수정&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;프로젝트 경력을 보면 B는 토이 프로젝트 개발 후 직접 배포하고, 개인 도메인을 구매하여 연결한 것을 알 수 있습니다. web push라는 새로운 기술을 시도한 것도 보입니다. 블로그를 보니 B는 GitHub Page에 Gatsby로 정적페이지를 생성해서 만들었네요. &lt;del&gt;(지금 상황극 하는 겁니다)&lt;/del&gt; 내용을 보니 프로젝트를 진행하면서 고민했던 내용과 해결책이 어떤 건지 잘 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;사실 A도 프로젝트 배포할 줄 아는데 귀찮아서 안 했던 거고, 개인 도메인도 몇 번 클릭하면 연결되는 걸 알지만 귀찮아서 안 했던 것일 수 있습니다. 평가하는 입장에서는 그런 속사정을 모르기 때문에 드러나는 것으로 평가하게 되고 일단은 B에 호감을 가지고 면접을 시작하게 될 것입니다.&lt;/p&gt;

&lt;p&gt;같은 작업을 하더라도 조금만 더 신경 쓰면 남과 다른 내용을 추가할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;기록하기&quot;&gt;기록하기&lt;/h3&gt;

&lt;p&gt;블로깅이나 노트 정리를 하세요. 공부한 걸 기록하는 과정을 통해 잘 이해되지 않은 부분을 한 번 더 찾게 되고 나중에 같은 삽질을 반복하는 것을 줄여줍니다.&lt;/p&gt;

&lt;p&gt;블로그는 내가 이런 걸 공부하고 있고 이렇게 성장하고 있다는 걸 보여주는 도구로 활용할 수 있기 때문에 잘 정리된 블로그는 평가에서 엄청나게 유리합니다.&lt;/p&gt;

&lt;p&gt;이해하기 쉽게 블로그 내용을 점수로 표현해보면 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;제목 한 줄 + 링크 한 줄 (0점)&lt;/li&gt;
  &lt;li&gt;공부한 내용 블로그에 정리하기 (+1점)&lt;/li&gt;
  &lt;li&gt;관심 있는 항목을 좀 더 깊이 공부하고 장/단점과 실제 사용 후기 정리하기 (+5점)&lt;/li&gt;
  &lt;li&gt;각각의 기술을 조합하여 무언가를 만들고 내용 정리하기 (+10점)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;다른 사람이 작성한 글을 찾고 싶다면 &lt;a href=&quot;https://velog.io&quot;&gt;velog&lt;/a&gt;를 추천합니다. 좋은 글이 가득~&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;추가-팁&quot;&gt;추가 팁&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;잘 물어보세요.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;생각보다 질문은 어렵습니다. 그렇기 때문에 잘 물어보는 것이 중요합니다. 좋은 질문은 좋은 답변을 들을 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.2dal.com/2020/04/01/%EB%B9%A0%EB%A5%B4%EA%B3%A0-%EC%A0%95%ED%99%95%ED%95%98%EA%B2%8C-%EB%8B%B5%EB%B3%80%EC%9D%84-%EB%B0%9B%EC%9D%84-%EC%88%98-%EC%9E%88%EB%8A%94-%EC%A7%88%EB%AC%B8%ED%95%98%EB%8A%94-%EB%B2%95&quot;&gt;빠르고 정확하게 답변을 받을 수 있는 질문하는 법&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://brunch.co.kr/@codestates/4&quot;&gt;실력이 좋은 개발자는 좋은 질문을 한다&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://jbee.io/essay/good_questionor/&quot;&gt;질문을 잘하는 개발자&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://shinsunyoung.tistory.com/111&quot;&gt;커뮤니케이션과 질문 (질문의 두려움 극복하기)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;목표를 정하자&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;주간 또는 월간으로 명확한 목표와 기간을 정합니다. 대부분의 사람은 일정이 없으면 느슨해지고 오늘 할 수 있는 일을 내일로 미루게 됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;노션이나 사용하는 노트에 목표와 기간을 적고 진행한 내용을 정리하세요.&lt;/li&gt;
  &lt;li&gt;주기적으로 진행한 내용을 확인하고 회고하세요.&lt;/li&gt;
  &lt;li&gt;너무 빡빡한 일정보다는 적당히 할 수 있는 목표를 정하고 조금씩 늘려가세요.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;환경을 바꿔보세요&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;공부가 힘들고 번아웃이 올 수 있습니다. 그럴 때는 환경을 한번 바꿔보세요.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;제주도 / 강원도 등 완전 새로운 공간에서 혼자 여행을 가서 개발해보세요.&lt;/li&gt;
  &lt;li&gt;인터넷이 안 되는 곳에 컴퓨터 없이 책만 들고 가보세요. 새로운 내용을 발견할 수도 있어요.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;회사-선택하기&quot;&gt;회사 선택하기&lt;/h2&gt;

&lt;p&gt;어떤 회사가 좋은 회사일까요?&lt;/p&gt;

&lt;p&gt;만드는 제품이 좋은 회사? 월급 많이 주는 회사? 개발 환경이 좋은 회사? 구성원들이 좋은 회사? 발전 가능성이 높은 회사? 사람마다 좋은 회사의 기준이 달라 명확하게 말하기 어렵지만, 피해야 할 회사는 어느 정도 기준이 있습니다.&lt;/p&gt;

&lt;p&gt;양파님의 &lt;a href=&quot;http://theonion.egloos.com/5768506&quot;&gt;초보 개발자에게 - 이런 데에서 일하지 말자 1&lt;/a&gt; 글을 보면 다음과 같은 내용이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;버전 컨트롤 시스템이 없다&lt;/li&gt;
  &lt;li&gt;Automated deploy system, build system 이 없다&lt;/li&gt;
  &lt;li&gt;모니터링 시스템이 없다&lt;/li&gt;
  &lt;li&gt;테스터가 없거나, 테스팅 environment, staging environment 가 없다&lt;/li&gt;
  &lt;li&gt;유닛 테스트를 안 쓰고, 코드 리뷰가 없다&lt;/li&gt;
  &lt;li&gt;버그 트랙킹 시스템이 없다&lt;/li&gt;
  &lt;li&gt;개발자에게 웹 디자인을 시킨다든지, 하드웨어 서포트를 요구한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;피해야 할 조건이라고 하지만, 위 조건을 하나도 만족하지 않는다면 꽤 괜찮은 개발 회사라고 생각해도 좋을 것 같습니다.&lt;/p&gt;

&lt;p&gt;개인적으로 하나 더 항목을 추가하고 싶습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;새로운 시도를 할 수 없고 문제가 생기면 개인에게 책임을 전가한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;애초에 실수가 생기지 않도록 회사 시스템이 갖추어져 있고 실수가 생기더라도 회고&lt;sup&gt;postmorterm&lt;/sup&gt;를 통해 개선하려는 의지가 있는 회사에서 일하면 더 빨리 성장할 수 있습니다. 개인에게 책임을 묻는 순간, 문제가 생기지 않기 위해 어려운 일은 피하게 되고 잘못을 숨기면서 거짓말하는 문화가 생길 수 있습니다. 비난이 아닌 건설적이고 실용적인 피드백이 필요합니다.&lt;/p&gt;

&lt;p&gt;다니고 있는 회사가 마음에 안 든다면 바로 이직을 고려하는 것보단 내부에서 조금씩 바꾸려는 노오오오력을 하는 것도 좋습니다. 문제가 있다고 느끼는 부분을 고민하고 누구도 반박하지 못할 해결책을 내가 스스로 준비한다면, 나도 발전하고 회사도 성장할 기회가 될 수 있습니다. &lt;del&gt;아니라면.. 탈출..&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;주위에 여러 개발자분들의 이야기를 들어보면, 이상적인 (저 회사 가면 엄청 재밌고 창의적인 작업을 할 수 있겠지?) 회사는 어디에도 없고 지속 가능하지 않다고 느낍니다. 회사와 구성원이 모두 노력하고 계속해서 더 나아진다면 좋은 회사라고 생각합니다.&lt;/p&gt;

&lt;h2 id=&quot;그래서&quot;&gt;그래서&lt;/h2&gt;

&lt;p&gt;사실, 이미 고여있는 개발자라서 초보 개발자의 마음을 100% 이해할 수 없지만, 아무쪼록 도움이 되길 바라며 글을 작성해보았습니다. 요즘 함부로 조언하지 말라는 이야기가 있는데 부디 꼰대처럼 보이지 않았으면 좋겠어요. 👏&lt;/p&gt;

&lt;p&gt;마지막으로, “지금 내가 뭐 하는 거지? 잘하고 있는 건가?” 라고 생각한다면, 지금보다 앞으로 &lt;strong&gt;성장할 수 있다는 것이 중요&lt;/strong&gt;하다는걸 알았으면 좋겠습니다. 멈추지 않고 나아간다면 언젠가는 원하는 바를 이룰 수 있을 거예요.&lt;/p&gt;

&lt;p&gt;마지막으로 한번더, 퍼플아이오에서 적극적으로 채용을 하고 있습니다. 열정 있는 신입/경력 개발자를 찾습니다. 구경 오세요~!&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;a href=&quot;https://purple.io&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/purpleio_bookmark.png&quot; style=&quot;width: 420px&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AD&lt;/code&gt; 기술, 개발 환경, 이력을 모아 나만의 프로필을 만들고 개발 관련 팁을 쉽게 공유하고 널리 알릴 수 있는 개발자들을 위한 서비스는 없을까?&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;a href=&quot;https://mysetting.io&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/assets/article_images/2021-06-27-study-guide/mysetting.png&quot; style=&quot;width: 420px&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;
</description>
        <pubDate>Sun, 27 Jun 2021 00:00:00 +0900</pubDate>
        <link>https://subicura.com/2021/06/27/study-guide.html</link>
        <guid isPermaLink="true">https://subicura.com/2021/06/27/study-guide.html</guid>
        
        <category>Beginner</category>
        
        <category>Developer</category>
        
        <category>Study</category>
        
        
        <category>Talk</category>
        
      </item>
    
      <item>
        <title>2020년 회고</title>
        <description>&lt;p&gt;오랜만에 회고입니다. 2020년은 다른 해보다 여러가지로 특별한 한해였던 것 같습니다.&lt;/p&gt;

&lt;h2 id=&quot;퍼플아이오&quot;&gt;퍼플아이오&lt;/h2&gt;

&lt;p&gt;2020년 “퍼플웍스”를 시작하고 10년만에 새로운 회사인 “퍼플아이오” 소속이 되었습니다. 퍼플아이오&lt;sup&gt;purpleio&lt;/sup&gt;는 퍼플웍스 자회사로 시작하여 코오롱FnC의 투자를 받았고 &lt;a href=&quot;https://kolonmall.com&quot;&gt;코오롱몰&lt;/a&gt;을 중심으로 한 온라인 이커머스 개발을 주로 하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://purple.io&quot;&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2021-01-03-remember-2020/purpleio.jpg&quot; alt=&quot;purpleio&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;하는 일 자체는 크게 달라지지 않았지만, 달라진 점을 찾아보면 각종 계정, 자원을 좀 더 체계적&lt;del&gt;빡빡해짐&lt;/del&gt;으로 관리하고 여러 가지로 면에서 안정된 환경이 되었습니다.&lt;/p&gt;

&lt;p&gt;기존 퍼플웍스 인원 일부와 코오롱FnC 인원 일부, 2020년 신규 입사자 8명까지 총 35명(개발자 31명)으로 조직이 커졌고 아직 준비 단계지만 신규 사업을 준비하다 보니 2020년이 훅 지나갔습니다. 대기업과 스타트업의 장점을 합쳐 시너지를 만들고 혁신적인 프로덕트를 민첩하고 유연하게 만드는 것을 시도하고 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;회사--팀--제품&quot;&gt;회사 / 팀 / 제품&lt;/h2&gt;

&lt;p&gt;관리자 역할을 잘하려고 노력했고 크게 개발 프로세스 개선, 코오롱몰 3.0 개발, 스테이폴리오 3.0 개발이 기억에 남습니다.&lt;/p&gt;

&lt;h3 id=&quot;관리자&quot;&gt;관리자&lt;/h3&gt;

&lt;p&gt;회사의 변화와 함께 관리자로서 역할에 대한 고민이 컸던 한해였습니다. 고민을 해결하기 위해서 주로 책을 많이 읽었는데 다음은 도움이 되었던 책들입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.yes24.com/Product/Goods/67350256&quot;&gt;함께 자라기&lt;/a&gt; - 조직을 위한 실용주의 서적&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://m.yes24.com/goods/detail/23123938&quot;&gt;심플을 생각한다&lt;/a&gt; - 라인 전 CEO가 쓴 무엇에 집중할 것인가?&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://m.yes24.com/goods/detail/7150718&quot;&gt;멀티플라이어&lt;/a&gt; - 팀원의 능력을 극대화하는 방법&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.yes24.com/Product/Goods/90160861&quot;&gt;일을 잘 맡긴다는 것&lt;/a&gt; - 왜 일을 못 맡기는걸까?&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://m.yes24.com/goods/detail/92425227&quot;&gt;팀장의 탄생&lt;/a&gt; - 페이스북 인턴에서 부사장이 된 경험&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.yes24.com/Product/Goods/74259979&quot;&gt;실리콘밸리의 팀장들&lt;/a&gt;  - 솔직하게 소통하세요&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.yes24.com/Product/Goods/87336637&quot;&gt;개발 7년차, 매니저 1일차&lt;/a&gt;  - 팀원에서 팀장으로&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.yes24.com/Product/Goods/69770721&quot;&gt;나는 아마존에서 미래를 다녔다&lt;/a&gt;  - 아마존 살펴보기&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://m.yes24.com/Goods/Detail/91435283&quot;&gt;빌 캠벨, 실리콘밸리의 위대한 코치&lt;/a&gt;  - 좋은 스승이란?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;개발을 최대한 줄이고 많은 일을 위임한다는 건 생각보다 너무너무 어려운 일이었는데, 어느 정도 익숙해졌고 지나고 나니 왜 진작 그렇게 하지 않았을까 하는 생각이 듭니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이거저거 새로운 거 알아보고 적용해보죠?&lt;/code&gt; 라고 했을 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;또요?&lt;/code&gt;라면서 잘 따라와 준 팀원들께 감사의 인사를.. 👏&lt;/p&gt;

&lt;h3 id=&quot;개발-프로세스-개선&quot;&gt;개발 프로세스 개선&lt;/h3&gt;

&lt;p&gt;조직이 커지고 팀원이 많아지면서 한명 한명의 역할이 중요해지고 시간이 소중해졌습니다. 최대한 비효율을 줄이려고 노력했고 자연스레 개발 프로세스를 손보았습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://danger.systems/js/&quot;&gt;Danger JS&lt;/a&gt;도입&lt;/strong&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;/assets/article_images/2021-01-03-remember-2020/bot.jpg&quot; alt=&quot;GitLab danger bot&quot; style=&quot;width: 350px&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;GitHub이나 GitLab에 붙일 수 있는 bot 입니다. PR 제목이나 내용이 규칙에 맞지 않으면 댓글로 알려주고 코드 리뷰할 사람을 랜덤으로 뽑아주는 기능도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;업무 프로세스&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;갑자기 일이 몰리는 걸 방지하고 개발자는 개발에만 집중할 수 있도록 최대한 자동화하고 안정감을 느끼는 개발 패턴을 만드는 게 중요하다고 생각했습니다.&lt;/p&gt;

&lt;p&gt;현재까지 정리된 프로세스는 다음과 같습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;모든 요구사항은 1차로 &lt;a href=&quot;https://asana.com/&quot;&gt;Asana&lt;/a&gt;에 등록&lt;/li&gt;
  &lt;li&gt;팀장이 우선순위 검토 후 할당&lt;/li&gt;
  &lt;li&gt;Asana 프로젝트와 GitLab 프로젝트 Issue 연결 (&lt;a href=&quot;https://unito.io/&quot;&gt;Unito&lt;/a&gt;로 자동화)&lt;/li&gt;
  &lt;li&gt;해당 Issue 번호를 포함한 브랜치 생성 후 작업&lt;/li&gt;
  &lt;li&gt;작업 완료되면 PR 생성&lt;/li&gt;
  &lt;li&gt;PR 생성되면 테스트용 쿠버네티스 클러스터에 배포 후 테스트 도메인 생성 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ex) 1234-fix-bug.test.com&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;QA 테스트&lt;/li&gt;
  &lt;li&gt;GitOps(&lt;a href=&quot;https://argoproj.github.io/argo-cd/&quot;&gt;ArgoCD&lt;/a&gt;)로 배포 이력을 관리하고 운영에 블루/그린 배포&lt;/li&gt;
  &lt;li&gt;최종 확인 후 블루/그린 전환&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;조금 더 효율적인 방법은 없을까..? 고민중입니다.&lt;/p&gt;

&lt;h3 id=&quot;코오롱몰-30&quot;&gt;코오롱몰 3.0&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.kolonmall.com&quot;&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2021-01-03-remember-2020/kolonmall.jpg&quot; alt=&quot;kolonmall&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;코오롱몰 3.0은 2020년 4월에 오픈했는데 사실 너무 부담스러웠습니다. 오픈을 몇 달 앞두고 갑자기 코로나가 터지면서 재택근무가 시작되었고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;과연 이러한 상황에서 제대로 오픈할 수 있을까?&lt;/code&gt; 라는 걱정이 많았습니다.&lt;/p&gt;

&lt;p&gt;사실 더 큰 걱정은 혹시나 프로젝트 일정이 연기되었을 때, “역시 재택근무는 안돼”라는 이야기가 들릴 것 같았고 개인적으로 재택근무를 지지하고 리모트 워크에 관심이 많아 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;재택근무가 업무효율이 좋다&lt;/code&gt;는 가정을 증명하고 싶었습니다.&lt;/p&gt;

&lt;p&gt;RubyOnRails의 DHH가 쓴 &lt;a href=&quot;https://basecamp.com/books/rework&quot;&gt;rework&lt;/a&gt;(번역 - &lt;a href=&quot;http://www.yes24.com/Product/Goods/16483575&quot;&gt;똑바로 일하라&lt;/a&gt;)라는 책이 2011년에 나왔는데 그때 부터 시도만 하고 도입 못 하다가 코로나라는 위기가 오히려 기회가 될 것 같았습니다.&lt;/p&gt;

&lt;p&gt;다행히 걱정했던 문제는 생기지 않았고 눈 뜨면 일하고 출퇴근 시간까지 근무하면서 오히려 재택근무가 출근보다 더 일하는 현상이 생겼습니다. &lt;del&gt;차라리 출근이 낫나..&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;그리고 팀원들도 잘 협조하여 큰 이슈 없이 오픈했습니다.&lt;/p&gt;

&lt;p&gt;이번 프로젝트는 기존에 단일 Java 애플리케이션으로 구성되었던 것을 일부 분리하여 Nextjs와 GraphQL을 도입한 게 큰 성과였습니다. 개발환경 부팅은 10분에서 10초로 줄어들었고 화면의 모든 요소를 컴포넌트화하여 CMS에서 뚝딱 설정하면 페이지가 나옵니다.&lt;/p&gt;

&lt;h3 id=&quot;스테이폴리오-30&quot;&gt;스테이폴리오 3.0&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.stayfolio.com&quot;&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2021-01-03-remember-2020/stayfolio.jpg&quot; alt=&quot;stayfolio&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;스테이폴리오는 오픈 후 새로운 기능과 페이지가 조금씩 추가되었지만, 완전히 리뉴얼한 적은 이번이 처음입니다.&lt;/p&gt;

&lt;p&gt;Nextjs를 도입하여 드디어 Rails + AngularJS + React가 공존하는 프로젝트가 되었습니다. 이번 기회에 AngularJS는 완전히 걷어내려고 하는데 레거시는 여윽시.. 강력합니다. ㅠ_ㅠ&lt;/p&gt;

&lt;p&gt;서버도 기존 KT UCloud에서 AWS로 이관했습니다. 열심히 RI 설정해서 비용을 절약해도 확실히 비싸네요. 고민입니다.&lt;/p&gt;

&lt;p&gt;새로운 개발자들도 많이 합류하였는데, 다들 좋은 분들이고 열정이 있어 앞으로가 기대됩니다.&lt;/p&gt;

&lt;h2 id=&quot;블로그&quot;&gt;블로그&lt;/h2&gt;

&lt;p&gt;2020년 블로그 가장 큰 성과는 쿠버네티스 시작하기 글을 마무리한 점입니다. 여러 가지 고민만 하다가 글을 못 쓰고 있었는데 결국 &lt;a href=&quot;https://subicura.com/k8s/&quot;&gt;쿠버네티스 안내서&lt;/a&gt;로 우회하여 마무리하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2021-01-03-remember-2020/ga.jpg&quot; alt=&quot;PageView&quot; /&gt;&lt;/p&gt;

&lt;p&gt;올 한 해 가장 많이 본 글을 뽑아봤습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://subicura.com/2017/01/19/docker-guide-for-beginners-2.html&quot;&gt;초보를 위한 도커 안내서 2/3 - 설치하고 컨테이너 실행하기&lt;/a&gt; / 162,493 페이지뷰&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html&quot;&gt;초보를 위한 도커 안내서 1/3 - 도커란 무엇인가?&lt;/a&gt; / 142,642 페이지뷰&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://subicura.com/2017/02/10/docker-guide-for-beginners-create-image-and-deploy.html&quot;&gt;초보를 위한 도커 안내서 3/3 - 이미지 만들고 배포하기&lt;/a&gt; / 63,869 페이지뷰&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://subicura.com/2017/11/22/mac-os-development-environment-setup.html&quot;&gt;본격 macOS에 개발 환경 구축하기&lt;/a&gt; / 55,850 페이지뷰&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://subicura.com/2018/02/14/javascript-debugging.html&quot;&gt;크롬 개발자 도구를 이용한 자바스크립트 디버깅&lt;/a&gt; / 54,574 페이지뷰&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://subicura.com/2019/05/19/kubernetes-basic-1.html&quot;&gt;쿠버네티스 시작하기 - Kubernetes란 무엇인가?&lt;/a&gt; / 53,880 페이지뷰&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;전체 트래픽은 다음과 같습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Organic Search / 230,239(79.26%)&lt;/li&gt;
  &lt;li&gt;Direct / 33,273(11.45%)&lt;/li&gt;
  &lt;li&gt;Referral / 16,814(5.79%)&lt;/li&gt;
  &lt;li&gt;Social / 10,176(3.50%)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;글을 자주 쓰진 않지만, 꾸준히 방문자 수가 나오는 이유는 도커와 macOS 설정글 덕분입니다. 그리고 구글 검색의 힘이 얼마나 큰지, SEO가 얼마나 중요한지 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;2021년도엔 좀 더 여유를 가지고 블로그 글을 더 작성할 수 있었으면 좋겠습니다. 우선은 &lt;a href=&quot;https://subicura.com/k8s/&quot;&gt;쿠버네티스 안내서&lt;/a&gt;와 &lt;a href=&quot;https://subicura.com/k8s/archive/&quot;&gt;쿠버네티스 관련 글&lt;/a&gt;을 좀 더 신경 쓸 것 같습니다.&lt;/p&gt;

&lt;h2 id=&quot;유투브&quot;&gt;유투브&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://44bits.tv/&quot;&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2021-01-03-remember-2020/youtube.jpg&quot; alt=&quot;youtube&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;직장인 2대 허언이 “퇴사 할 거다” + “유튜브 할 거다” 라는데 드디어 유튜브를 찍었습니다.&lt;/p&gt;

&lt;p&gt;아무래도 혼자 하기는 부담이 되어서 &lt;a href=&quot;https://www.44bits.io/ko&quot;&gt;44bits&lt;/a&gt;멤버들과 함께 &lt;a href=&quot;http://44bits.tv/&quot;&gt;채널&lt;/a&gt;을 만들었고 보이는 팟캐스트, 쿠버네티스 안내서, 4분코딩, Startup53등 다양한 영상을 만들었습니다. Startup53은 나름 재밌을 것 같았는데 코로나 때문에 잠정 중단되어 많이 아쉽습니다.&lt;/p&gt;

&lt;p&gt;개발 이야기만 해서 구독자와 시청 시간을 모을 수 있을까 걱정했는데 결국 10월 즈음 수익 창출 조건(구독자 1000명과 1년간 4천시간 시청)을 만족했습니다. 아직 광고수익은 거~의 없습니다. 아마 조회 수가 수만~수십만은 되어야 수익이 조금씩 나오지 않을까 생각이 듭니다. &lt;del&gt;자극적인 영상을 올려야 하나..&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;영상을 찍으면서 익힌 스킬은 어색하지 않게 이야기하기, 편집 포인트 잡기, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;음... 어...&lt;/code&gt;같은 말 덜 쓰기이고 프리미어 자르고 붙이기 단축키 입니다.&lt;/p&gt;

&lt;p&gt;참고로, 개인 영상을 찍을 때 사용하는 프로그램은 &lt;a href=&quot;https://www.telestream.net/screenflow/overview.htm&quot;&gt;Screenflow&lt;/a&gt;로 $129인데 중간에 다운되는 일은 아직 없었고 나름 가볍습니다. 캠과 화면이 동시에 따로 녹화되어 편집하기 좋습니다. 편집은 Adobe Premiere Pro를 쓰고 장비는 맥북과 블루 예티 마이크를 사용합니다.&lt;/p&gt;

&lt;h2 id=&quot;강의&quot;&gt;강의&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;a href=&quot;https://www.inflearn.com/instructors/209928/courses&quot; target=&quot;_blank&quot;&gt;
        &lt;img src=&quot;/assets/article_images/2021-01-03-remember-2020/inf.jpg&quot; alt=&quot;인프런&quot; style=&quot;width: 350px&quot; /&gt;
    &lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;계속 고민하던 온라인 강의를 2020년에 드디어 만들었습니다.&lt;/p&gt;

&lt;p&gt;오프라인 강의는 가끔 하고 있었고 온라인 강의는 장비나 형식의 이유로 못하고 있었는데 코로나가 터지고 유튜브를 하면서 자연스레 장비가 셋팅되어 진행하게 되었습니다.&lt;/p&gt;

&lt;p&gt;인프런에 &lt;a href=&quot;https://bit.ly/inflearn-docker&quot;&gt;초보를 위한 도커 안내서&lt;/a&gt;와 &lt;a href=&quot;https://bit.ly/inflearn-k8s-link&quot;&gt;초보를 위한 쿠버네티스 안내서&lt;/a&gt;를 개설하였고 각각 수강생은 460명, 209명, 평점은 4.7, 4.9 입니다.&lt;/p&gt;

&lt;p&gt;처음엔 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;누가 들을까..?&lt;/code&gt; 호기심이 강했는데 많은 분이 들어주시고 좋은 평을 남겨주셔서 잘했다는 생각이 들고 책임감이 커집니다.&lt;/p&gt;

&lt;h2 id=&quot;그래서&quot;&gt;그래서&lt;/h2&gt;

&lt;p&gt;2021년은 2020년의 아쉬움을 보완하고 발전시키려고 합니다.&lt;/p&gt;

&lt;p&gt;기술적으로 부족한 부분을 노력하고 좋은 사람들이 모여 좋은 제품을 만들고 싶습니다.&lt;/p&gt;

&lt;p&gt;2020년은 코로나19의 등장으로 정말 모두 힘들고 어려운 시기였습니다. 빨리 어려움을 극복하고 예전 같은 세상이 왔으면 좋겠습니다.&lt;/p&gt;

&lt;p&gt;새해 복 많이 받으세요.&lt;/p&gt;
</description>
        <pubDate>Sun, 03 Jan 2021 00:00:00 +0900</pubDate>
        <link>https://subicura.com/2021/01/03/remember-2020.html</link>
        <guid isPermaLink="true">https://subicura.com/2021/01/03/remember-2020.html</guid>
        
        <category>Blog</category>
        
        
        <category>Talk</category>
        
      </item>
    
      <item>
        <title>쿠버네티스 시작하기 - 설치부터 배포까지</title>
        <description>&lt;p&gt;“쿠버네티스 설치부터 배포”는 &lt;a href=&quot;#왜-블로그가-아닌가요&quot;&gt;여러가지 고민&lt;/a&gt; 끝에 &lt;a href=&quot;https://subicura.com/k8s/&quot;&gt;새로운 페이지&lt;/a&gt;로 작성하였습니다.&lt;/p&gt;

&lt;p&gt;👇 하단 링크를 클릭해 주세요!&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;a href=&quot;https://subicura.com/k8s/&quot; target=&quot;_blank&quot;&gt;
        &lt;img src=&quot;/assets/article_images/2020-12-14-kubernetes-basic-2/subicura-k8s.png&quot; alt=&quot;초보를 위한 쿠버네티스 안내서&quot; style=&quot;width: 350px&quot; /&gt;
    &lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;그리고 실습 영상과 함께 자세한 설명을 들을 수 있는 &lt;a href=&quot;https://bit.ly/inflearn-k8s-link&quot;&gt;온라인 강의&lt;/a&gt;도 준비되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://bit.ly/inflearn-k8s-link&quot;&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2020-12-14-kubernetes-basic-2/inflearn-k8s.png&quot; alt=&quot;초보를 위한 쿠버네티스 안내서 - 인프런&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/2020/12/13/kubernetes-basic-2.html&quot;&gt;쿠버네티스 시작하기 - 쿠버네티스란 무엇인가?&lt;/a&gt; &lt;span class=&quot;series&quot;&gt;SERIES 1/2&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;쿠버네티스 시작하기 - 설치부터 배포까지 ✓&lt;/strong&gt; &lt;span class=&quot;series&quot;&gt;SERIES 2/2&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot; class=&quot;googleads googleads-content&quot;&gt;
                &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-2468713653725581&quot; data-ad-slot=&quot;8649023787&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
            &lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;왜-블로그가-아닌가요&quot;&gt;왜 블로그가 아닌가요?&lt;/h2&gt;

&lt;p&gt;&lt;del&gt;왜 이렇게 늦었죠?&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;원래 계획은 &lt;a href=&quot;/2020/12/13/kubernetes-basic-2.html&quot;&gt;쿠버네티스 시작하기 - 쿠버네티스란 무엇인가?&lt;/a&gt; 글을 작성하고 설치, 배포, 스토리지, 설정, 비밀정보에 대해 시리즈를 작성하는 것이었습니다.&lt;/p&gt;

&lt;p&gt;하지만, 1년&lt;del&gt;하고도 6개월&lt;/del&gt;이 넘게 2번째 글을 작성하지 못했는데.. 가장 큰 이유는 생각보다 &lt;strong&gt;쿠버네티스가 더 크고 방대&lt;/strong&gt;했던 것입니다.&lt;/p&gt;

&lt;p&gt;2번째 시리즈 “쿠버네티스 설치”에 대해서 초기에 정리한 내용입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;개발 환경 vs 운영 환경&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;개발 환경은 Docker for desktop, minikube, kind, k3s가 있고 운영환경은…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;일반서버(On-Premise) vs 클라우드(Cloud)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;회사에서 직접 서버를 관리하는 경우는 kubeadm, kubespray, rancher, openshift가 있고 클라우드는..&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;AWS vs Google Cloud vs Azure&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;대표적인 3사 클라우드가 있지만 ncloud, digital ocean도 많이 쓰는거 같고 AWS를 대표로 설명한다면..&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;AWS - KOPS vs EKS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;AWS의 관리형 k8s서비스 EKS가 좋긴한데 컨트롤 플레인을 직접 제어할 수 없으니 KOPS도 필요할 것 같고 EKS를 쓴다면…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;AWS EKS - Self Managed Nodes vs Managed Node Group vs Fargate&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;EKS에서 노드를 관리하는 방법을 골라야 하는데 직접 관리하거나 관리형 서비스를 쓰거나 fargate를 쓰거나..? 근데 설치는 terraform이 나을지 eksctl이 나을지..&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;CNI(Container Network Interface) - Kube Router vs Weave Net vs Calico vs Cillium vs …&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;쿠버네티스의 장점은 원하는대로 인프라를 구성하는건데 네트워크 플러그인도 각자 특성이 있는데..&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;CRI(Container Runtime Interface) - docker vs containerd vs CRI-O vs …&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;도커는 곧 deprecated된다고 하고 containerd도 알고 CRI-O를 사용하는 법도 알아야 하지 않을까?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Ingress Controller - nginx vs haproxy vs traefik vs alb vs …&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Ingress 설명할 때 어떤 컨트롤러를 설명하는게 좋을지.. 다 장단이 있는것 같은데..&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Single Cluster vs Multi Cluster vs Anthos&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;처음 한번 클러스터를 구성하면 변경이 어려워서 바로 적용하진 않더라도 다중 클러스터나 anthos 개념은 알아두는게 좋을것 같고..&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;no service mesh vs istio vs linked&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;이왕 쿠버네티스 시작하는거 서비스 메시 기술을 적용하면 좋을 것 같은데..&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;무중단 클러스터 업데이트&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;쿠버네티스는 설치가 끝이 아니고 주기적(3개월)으로 업데이트를 해야 하는데 무중단 업데이트하는 방법과 주의점도 소개해야 하지 않을까?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;음… 설치만 이정도? 🤔&lt;/p&gt;

&lt;p&gt;보통 어떤 기술은 널리 쓰이는 대표적인 방법이 1~2개 있기 마련인데 쿠버네티스는 그런게 없습니다. 설치부터 그 종류가 너무너무너무 다양합니다. 여러가지 요구사항에 따라, 각자의 환경에 따라 설치 방법이 다르고 심지어 업데이트 속도도 빨라서 어제 작성한글이 내일 쓸모 없는 일이 벌어졌습니다.&lt;/p&gt;

&lt;p&gt;그렇게 고민고민 하다가 최대한 간단하게 “초보를 위한 입문용 글을 쓰자!”라고 결론을 내렸지만, 또 다른 문제가 있었습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;쿠버네티스 생태계는 변화가 빠름 (꾸준히 업데이트가 필요함)&lt;/li&gt;
  &lt;li&gt;쿠버네티스 설정(YAML) 내용이 복잡함 (설정 코드만 한페이지가 넘어감)&lt;/li&gt;
  &lt;li&gt;쿠버네티스는 리소스 중심으로 설명이 필요한데 글로 내용을 구성하기 어려움&lt;/li&gt;
  &lt;li&gt;사용중인 OS나 클라우드 환경에 따라 필요한 내용이 다름&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 문제를 어떻게 잘 풀 수 있을까 또 다시 고민을 했고 2020년 12월이 가까워지면서 어떻게든 해가 넘어가기 전에 정리를 하고 싶었습니다.&lt;/p&gt;

&lt;p&gt;그때 발견한 것이 &lt;a href=&quot;https://vuepress.vuejs.org/&quot;&gt;VuePress&lt;/a&gt; 입니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;/assets/article_images/2020-12-14-kubernetes-basic-2/vuepress.png&quot; style=&quot;width: 350px&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;VuePress는 지금 이 블로그에서 사용하고 있는 &lt;a href=&quot;https://jekyllrb-ko.github.io/&quot;&gt;Jekyll&lt;/a&gt;처럼 마크다운 문서를 이용하여 정적인 웹 페이지를 만들 수 있고 &lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Page&lt;/a&gt;로 배포할 수 있습니다. (vue를 전혀 몰라도 사용할 수 있습니다) 차이점은 블로그보다는 문서화에 초점을 맞췄다는 점입니다.&lt;/p&gt;

&lt;p&gt;몇가지 기능을 살펴보고 지금까지 고민했던 것을 해결해 줄 것 같았습니다. 메뉴를 이용하여 구조적으로 문서를 관리할 수 있고 확장도 손쉬운 구조입니다. 강력한 코드 문법 하이라이팅기능과 필요하면 vue 컴포넌트를 그대로 사용할 수 있어 새로운 기능도 자유롭게 추가할 수 있습니다. 블로그 형식으로 설명하기 어려운 걸 해결!&lt;/p&gt;

&lt;p&gt;그렇게 기본적인 실습 내용을 작성했고 앞으로 꾸준하게 관리할 예정입니다. 쿠버네티스를 정복하는 그날까지.. &lt;del&gt;영원히라는 뜻&lt;/del&gt; 많이 애용해주세요!&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/2020/12/13/kubernetes-basic-2.html&quot;&gt;쿠버네티스 시작하기 - 쿠버네티스란 무엇인가?&lt;/a&gt; &lt;span class=&quot;series&quot;&gt;SERIES 1/2&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;쿠버네티스 시작하기 - 설치부터 배포까지 ✓&lt;/strong&gt; &lt;span class=&quot;series&quot;&gt;SERIES 2/2&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
</description>
        <pubDate>Sun, 13 Dec 2020 00:00:00 +0900</pubDate>
        <link>https://subicura.com/2020/12/13/kubernetes-basic-2.html</link>
        <guid isPermaLink="true">https://subicura.com/2020/12/13/kubernetes-basic-2.html</guid>
        
        <category>Kubernetes</category>
        
        <category>Docker</category>
        
        <category>DevOps</category>
        
        <category>Server</category>
        
        
        <category>Kubernetes</category>
        
      </item>
    
      <item>
        <title>알아두면 유익한 2019 개발이야기</title>
        <description>&lt;p&gt;2020년에 작성하는 2019년 개발 이야기입니다. 2019년을 회고하면서 어떤 이야기를 할까 고민하다가 3년 전에 작성했던 &lt;a href=&quot;https://subicura.com/2016/05/30/likehs-develop-log.html&quot;&gt;홈쇼핑처럼 개발후기&lt;/a&gt;가 생각났고 퍼플웍스에서 그동안 도입했던 기술과 유용한 개발 내용을 정리해 보았습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2020-01-07-2019-dev-summary/2019_stack.png&quot; alt=&quot;2019&quot; /&gt;&lt;/p&gt;

&lt;p&gt;React와 Docker는 &lt;del&gt;신기술 나올 때가 됐는데..&lt;/del&gt; 여전히 잘 사용 중이고 프론트엔드, 백엔드, 인프라, 개발 프로세스에 소소한(?) 변화가 있었습니다. 공감이 가거나 괜찮은 대안이 있다면 편하게 알려주세요!&lt;/p&gt;

&lt;p&gt;참고로 홈쇼핑처럼은 &lt;a href=&quot;https://flavr.co.kr/&quot;&gt;FLAVR&lt;/a&gt;라는 이름으로 서비스를 변경하여 간편 조리식과 고기를 판매 중이고 최근에는 &lt;a href=&quot;https://www.kolonmall.com/&quot;&gt;KOLONMALL&lt;/a&gt;과 &lt;a href=&quot;https://www.stayfolio.com/&quot;&gt;스테이폴리오&lt;/a&gt; 작업을 주로 하고 있습니다. &lt;del&gt;👈 예쁜 옷과 예쁜 장소가 궁금하다면 클릭!!&lt;/del&gt;&lt;/p&gt;

&lt;div align=&quot;center&quot; class=&quot;googleads googleads-content&quot;&gt;
                &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-2468713653725581&quot; data-ad-slot=&quot;8649023787&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
            &lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;타입스크립트의-시대로&quot;&gt;타입스크립트의 시대로&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;/assets/article_images/2020-01-07-2019-dev-summary/conversion.png&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;타입스크립트&lt;sub&gt;TypeScript&lt;/sub&gt;는 마이크로소프트에서 개발한 자바스크립트(ES6)의 슈퍼셋&lt;sub&gt;superset&lt;/sub&gt; 언어입니다. 자바스크립트 문법을 그대로 사용하면서 타입을 추가하여 엄격하게 문법을 체크합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-typescript&quot; data-lang=&quot;typescript&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// 아주 간단한 타입스크립트 샘플&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;greeter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Hello, &lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;타입을 변수 뒤에 선언합니다. 간단하죠?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;타입스크립트 장점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;쉬운 도입
    &lt;ul&gt;
      &lt;li&gt;모든 자바스크립트 코드는 곧 타입스크립트 코드&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정적 타입
    &lt;ul&gt;
      &lt;li&gt;컴파일 타임 타입 체크&lt;/li&gt;
      &lt;li&gt;IDE에서 실시간으로 에러를 발견하고 고칠 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;자동완성 기능
    &lt;ul&gt;
      &lt;li&gt;사용할 수 있는 함수, 변수를 제안&lt;/li&gt;
      &lt;li&gt;타이핑이 줄고 생산성이 좋아짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;안전한 리팩토링
    &lt;ul&gt;
      &lt;li&gt;함수 이름이나 변수명을 쉽게 바꿀 수 있음&lt;/li&gt;
      &lt;li&gt;더 이상 전체 파일 검색 안 해도 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;새로운 문법 사용
    &lt;ul&gt;
      &lt;li&gt;ES6/ESNext 문법을 대부분 지원&lt;/li&gt;
      &lt;li&gt;타입스크립트 3.7에 추가된  &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining&quot;&gt;Optional chaining&lt;/a&gt;과 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator&quot;&gt;Nullish coalescing operator&lt;/a&gt; 짱짱맨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;거대한 커뮤니티&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;도입시 고려할점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;높은 러닝 커브
    &lt;ul&gt;
      &lt;li&gt;시작은 쉽지만 프로젝트 적용은 어려움&lt;/li&gt;
      &lt;li&gt;체감 난이도: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hello World&lt;/code&gt; &amp;lt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;React&lt;/code&gt; &amp;lt; (넘사벽) &amp;lt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Redux&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;레거시 자바스크립트 코드랑 같이 사용하기 어려움&lt;/li&gt;
      &lt;li&gt;빨간색 밑줄(오류)이 잘 안 사라짐 &lt;del&gt;any 쓸까…?&lt;/del&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;복잡한 설정
    &lt;ul&gt;
      &lt;li&gt;babel? webpack? awesome-typescript-loader? ts-loader? ts-node? d.ts? tsconfig? 어느정도 다 알아야 함&lt;/li&gt;
      &lt;li&gt;설정이 안 되면 시작을 못함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;관련 생태계
    &lt;ul&gt;
      &lt;li&gt;테스트 프레임워크와 정적분석도구도 타입스크립트를 지원해야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;참고링크&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript - JavaScript that scales.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tslint에-prettier-끼얹기&quot;&gt;TSLint에 Prettier 끼얹기&lt;/h2&gt;

&lt;p&gt;프로젝트에서 코드의 품질을 높이기 위해선 일관된 규칙이 필요합니다. 규칙을 하나하나 검사하기 어렵기 때문에 자동화 도구를 사용합니다. 예전엔 주로 ESLint를 사용했는데 타입스크립트를 도입하고 TSLint로 변경했습니다. &lt;del&gt;(큰 실수를 했어..)&lt;/del&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;TSLint 프로젝트는 deprecated 되었습니다. ESLint도 타입스크립트를 잘 지원합니다. ESLint 사용하세요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;TSLint&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;타입스크립트용 정적분석도구
    &lt;ul&gt;
      &lt;li&gt;코딩 스타일과 코드 퀄리티를 위한 다양한 규칙 제공&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;플러그인 지원
    &lt;ul&gt;
      &lt;li&gt;Google, Airbnb(추천) 등 내부에서 사용하는 규칙을 플러그인으로 공개&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;IDE 지원
    &lt;ul&gt;
      &lt;li&gt;실시간 규칙 검사&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Prettier&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2020-01-07-2019-dev-summary/prettier.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;코드 스타일 도구
    &lt;ul&gt;
      &lt;li&gt;TSLint와 비슷한 역할을 하지만 코딩 스타일만 집중&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다양한 언어 지원
    &lt;ul&gt;
      &lt;li&gt;js, jsx, angular, view, flow, typescript, css, less, scss, html, json, GraphQL, markdown, yaml, …&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기본으로 제공하는 스타일과 가독성이 꽤 좋음&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;대충 막 짜고&lt;/del&gt; 저장(ctrl+s)하면 코드를 이쁘게 정리해줌&lt;/li&gt;
  &lt;li&gt;ESLint/TSLint와 함께 사용할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;사용 팁&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;에디터에 “저장 시 자동 포멧팅” 옵션을 켜면 저장할 때마다 스타일을 자동으로 적용함&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git pre-commit hook&lt;/code&gt;에 스타일 검사 스크립트 추가
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.git/hooks/pre-commit.sample&lt;/code&gt; 파일을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.git/hooks/pre-commit&lt;/code&gt;로 복사하고 다음과 같이 수정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;...&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;생략&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;...

&lt;span class=&quot;c&quot;&gt;# 다음 2줄 추가&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt;
npm run lint

&lt;span class=&quot;c&quot;&gt;# If there are whitespace errors, print the offending file names and fail.&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;git diff-index &lt;span class=&quot;nt&quot;&gt;--check&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--cached&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$against&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;참고링크&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://eslint.org/&quot;&gt;ESLint - Pluggable JavaScript linter&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://palantir.github.io/tslint/&quot;&gt;TSLint&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://prettier.io/&quot;&gt;Prettier · Opinionated Code Formatter&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;visual-studio-code---최고의-타입스크립트-에디터&quot;&gt;Visual Studio Code - 최고의 타입스크립트 에디터&lt;/h2&gt;

&lt;p&gt;예전엔 VSCode를 소소하게 사용했지만, 타입스크립트를 도입하고 주력 에디터로 사용 중입니다. 무료면서 가볍고 맥, 윈도우, 리눅스, 심지어 서버에 띄우고 &lt;a href=&quot;https://coder.com/&quot;&gt;브라우저로 사용&lt;/a&gt;할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;VSCode는 숨겨진(?) 기능이 많은데 적절히 활용하면 좀 더 편하게 개발할 수 있습니다. 프로젝트 설정과 관련해서 잘 사용하고 있는 팁을 공유합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;프로젝트 설정&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;프로젝트 폴더 하위에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.vscode&lt;/code&gt;폴더를 만들고 각종 설정 파일을 작성하여 팀과 공유할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.vscode/settings.json&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;settings.json&lt;/code&gt; VSCode 기본설정&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;{
  &amp;quot;editor.tabSize&amp;quot;: 2,
  &amp;quot;editor.formatOnSave&amp;quot;: true,  
  &amp;quot;editor.formatOnPaste&amp;quot;: true,
  &amp;quot;editor.codeActionsOnSave&amp;quot;: {
    &amp;quot;source.fixAll.tslint&amp;quot;: true,
    &amp;quot;source.fixAll.eslint&amp;quot;: true
  },
  &amp;quot;typescript.tsdk&amp;quot;: &amp;quot;node_modules/typescript/lib&amp;quot;
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/041f1ae908aa687eb1fb893f45977a17.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;탭 사이즈를 2칸으로 설정하고 저장하거나 붙여넣기 할 때 자동으로 TSLint와 Prettier 규칙을 적용합니다. VSCode는 기본적으로 에디터에 내장된 타입스크립트를 사용하는데 별도의 SDK 경로를 지정하면 최신 버전을 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.vscode/extensions.json&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;extentions.json&lt;/code&gt; VSCode 확장기능 설정&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;{
  &amp;quot;recommendations&amp;quot;: [
    &amp;quot;esbenp.prettier-vscode&amp;quot;,
    &amp;quot;ms-vscode.vscode-typescript-tslint-plugin&amp;quot; 
  ]
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/184ae0f46bcb0898ce4164db921657a9.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;위와 같이 설정하면 VSCode가 실행될 때 확장기능이 설치되어 있는지 체크하고 없으면 설치를 유도합니다. 이거 설치해라 저거 설치해라 따로 이야기하지 않아도 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.vscode/react.code-snippets&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xxxx.code-snippets&lt;/code&gt; VSCode Snippet 설정&lt;/p&gt;

&lt;p&gt;VSCode에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;insert snippet&lt;/code&gt;이라는 기능이 있는데 자주 사용하는 코드 패턴을 만들면 편합니다. 다음은 리엑트 컴포넌트를 만들 때 항상 하는 작업을 스니펫으로 작성한 예제입니다. &lt;a href=&quot;https://snippet-generator.app/&quot;&gt;snippet generator&lt;/a&gt;에서 쉽게 만들 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-jsx&quot; data-lang=&quot;jsx&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// 항상 작성하는 React 코드&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;react&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IHelloProps&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;FunctionComponent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;IHelloProps&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&amp;gt;&amp;lt;/&amp;gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;파일명을 보고 자동으로 코드를 작성하려면 다음과 같이 설정합니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;{
  &amp;quot;Default React Function Component&amp;quot;: {
    &amp;quot;prefix&amp;quot;: &amp;quot;function-component&amp;quot;,
    &amp;quot;body&amp;quot;: [
      &amp;quot;import React from &amp;#39;react&amp;#39;;&amp;quot;,
      &amp;quot;&amp;quot;,
      &amp;quot;interface I${TM_FILENAME_BASE/(^[a-z])|\\-([0-9a-z])/${1:/capitalize}${2:/capitalize}/g}Props {}&amp;quot;,
      &amp;quot;&amp;quot;,
      &amp;quot;const ${TM_FILENAME_BASE/(^[a-z])|\\-([0-9a-z])/${1:/capitalize}${2:/capitalize}/g}: React.FunctionComponent&amp;lt;I${TM_FILENAME_BASE/(^[a-z])|\\-([0-9a-z])/${1:/capitalize}${2:/capitalize}/g}Props&amp;gt; = () =&amp;gt; {&amp;quot;,
      &amp;quot;  return &amp;lt;&amp;gt;&amp;lt;/&amp;gt;;&amp;quot;,
      &amp;quot;};&amp;quot;,
      &amp;quot;&amp;quot;,
      &amp;quot;export default ${TM_FILENAME_BASE/(^[a-z])|\\-([0-9a-z])/${1:/capitalize}${2:/capitalize}/g};&amp;quot;,
      &amp;quot;&amp;quot;
    ],
    &amp;quot;description&amp;quot;: &amp;quot;Default React Function Component&amp;quot;
  }
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/fbbb905f6e46b3c98b2e3d5027476be9.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;&lt;strong&gt;참고링크&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;Visual Studio Code&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/cdr/code-server&quot;&gt;Code server&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://snippet-generator.app/&quot;&gt;snippet generator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;jest--enzyme로-react-테스트하기&quot;&gt;Jest &amp;amp; Enzyme로 React 테스트하기&lt;/h2&gt;

&lt;p&gt;타입스크립트와 린터는 개발 생산성을 향상하고 코드 퀄리티를 높이지만 버그를 줄이는 가장 좋은 방법은 테스트 코드를 작성하는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Jest&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;공식 홈페이지 소개 - 간단하고&lt;sub&gt;simplicity&lt;/sub&gt; 즐거운&lt;sub&gt;delightful&lt;/sub&gt; 자바스크립트 테스트 프레임워크&lt;/li&gt;
  &lt;li&gt;Babel, 타입스크립트, Node, React 지원&lt;/li&gt;
  &lt;li&gt;Matchers 사용 - toBe, toBeNull, toEqual, toBeGreaterThan, toContain, … 등등&lt;/li&gt;
  &lt;li&gt;스냅샷 테스팅 지원 - Jest 완소기능 😍&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;스냅샷 테스팅&lt;sub&gt;snapshot testing&lt;/sub&gt;이란?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;UI가 의도하지 않게 변경되었는지 검사&lt;/li&gt;
  &lt;li&gt;스냅샷 - React가 렌더링 한 결과를 스크린샷 찍듯이 텍스트로 저장&lt;/li&gt;
  &lt;li&gt;스냅샷 테스트 - 이전에 저장한 스냅샷과 테스트 시점의 스냅샷을 비교&lt;/li&gt;
  &lt;li&gt;스냅샷 업데이트가 필요한 경우
    &lt;ul&gt;
      &lt;li&gt;의도적으로 컴포넌트 UI를 변경한 경우&lt;/li&gt;
      &lt;li&gt;개발이 한창일 땐 스냅샷을 자주 업데이트하는 것이 정상&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스냅샷 테스트가 실패하는 경우
    &lt;ul&gt;
      &lt;li&gt;의도하지 않게 컴포넌트가 변경되는 경우&lt;/li&gt;
      &lt;li&gt;사용 중인 라이브러리 버전이 변경되면서 호환성이 깨질 때&lt;/li&gt;
      &lt;li&gt;배포 직전 CI 서버에서 빌드한 코드가 개발 환경과 다를 때&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Enzyme&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Airbnb에서 만든 React 테스트 도구&lt;/li&gt;
  &lt;li&gt;컴포넌트 렌더링, 탐색 테스트, 이벤트 시뮬레이션 테스트 지원&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Enzyme와 Jest를 사용한 스냅샷 테스트는 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nx&quot;&gt;describe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;lt;Coupon /&amp;gt;&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;matches snapshot with mount&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;component&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;mount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;MockedCoupon&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;component&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;expect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;component&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toMatchSnapshot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;참고링크&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://jestjs.io/&quot;&gt;Jest · 🃏 Delightful JavaScript Testing&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://jestjs.io/docs/en/snapshot-testing&quot;&gt;Snapshot Testing · Jest&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://airbnb.io/enzyme/&quot;&gt;Introduction · Enzyme&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;styled-component---자바스크립트로-만드는-css&quot;&gt;Styled Component - 자바스크립트로 만드는 CSS&lt;/h2&gt;

&lt;p&gt;React를 본격적으로 사용하면서 여러 컴포넌트를 만들었고 자연스레 컴포넌트 재사용에 관심이 생겼습니다. React 컴포넌트에 &lt;a href=&quot;https://en.wikipedia.org/wiki/CSS-in-JS&quot;&gt;CSS-in-JS&lt;/a&gt;기능을 이용하면 마크업과 스크립트, 스타일까지 한 번에 관리할 수 있습니다.&lt;/p&gt;

&lt;p&gt;자바스크립트로 CSS를 어떻게 관리할까요? CSS-in-JS방식의 여러 가지 라이브러리 중 styled components 예제입니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-jsx&quot; data-lang=&quot;jsx&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;LinkButton&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;styled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`
  border-radius: 3px;
  border: 2px solid palevioletred;
  color: palevioletred;
  padding: 0.25em 1em;

  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;props&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;primary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;css&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`
    background: palevioletred;
    color: white;
  `&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;
`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Container&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;styled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`
  text-align: center;
`&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;LinkButton&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;href&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://github.com/styled-components/styled-components&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;primary&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
      Styled Components
    &lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;LinkButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;blockquote&gt;
  &lt;p&gt;Styled components 문법은 독특합니다. 괄호 없이  `(backtick, &lt;del&gt;숫자 1 왼쪽 위 그거&lt;/del&gt; )으로 스타일 코드를 감싸고 있는데 ES6에 추가된 &lt;a href=&quot;https://mxstbr.blog/2016/11/styled-components-magic-explained/&quot;&gt;Tagged Template Literal 기능&lt;/a&gt;입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;웹 개발에선 전통적으로 마크업과 스타일, 스크립트를 분리하기 때문에 CSS-in-JS 기술은 논란을 불러왔습니다. 사실 지금 사용하면서도 이래도 되나 싶은 부분이 있기는 합니다. &lt;del&gt;머리로는 이해가 되지만 마음은 불편&lt;/del&gt; 웹 개발이 점점 더 복잡해지고 컴포넌트 기술이 발전하면서 CSS-in-JS기술은 필수라고 생각하지만 장/단점을 정확히 알고 사용하는 것이 좋아 보입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CSS를 좀 해본(?) 사람들이 겪는 문제&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CSS 클래스 이름 중복 문제&lt;/li&gt;
  &lt;li&gt;스타일 상속에 의한 중복 문제&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;!important&lt;/code&gt; 문제&lt;/li&gt;
  &lt;li&gt;코드 최적화 문제 - 지우기 찝찝해서 남아 있는 코드들&lt;/li&gt;
  &lt;li&gt;자바스크립트와 변수를 공유할 수 없는 문제&lt;/li&gt;
  &lt;li&gt;격리하여 관리하기 어려운 문제&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Styled components의 특징&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;컴포넌트
    &lt;ul&gt;
      &lt;li&gt;컴포넌트별로 스타일을 분리해서 관리&lt;/li&gt;
      &lt;li&gt;클래스 이름을 자동으로 생성하고 중복 문제가 해결됨&lt;/li&gt;
      &lt;li&gt;여기를 고치면 저기가 망가지고 저기를 고치면 거기가 망가지는 일 없음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CSS 코드 최적화
    &lt;ul&gt;
      &lt;li&gt;페이지에서 사용하는 컴포넌트의 스타일만 사용&lt;/li&gt;
      &lt;li&gt;불필요한 스타일은 제거&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;자바스크립트 사용
    &lt;ul&gt;
      &lt;li&gt;CSS를 &lt;strong&gt;코딩&lt;/strong&gt;할 수 있음&lt;/li&gt;
      &lt;li&gt;변수나 함수를 만들고 자바스크립트 코드와 상수를 공유할 수 있음&lt;/li&gt;
      &lt;li&gt;테스트 코드 작성 가능&lt;/li&gt;
      &lt;li&gt;타입스크립트를 이용한 자동완성 지원&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Vendor prefix
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-moz&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-webkit&lt;/code&gt; 같은거 자동으로 붙여줌&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;CSS-in-JS 기술의 단점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;페이지 로드 시 자바스크립트를 분석하여 CSS 생성
    &lt;ul&gt;
      &lt;li&gt;CSS 생성 오버헤드 - 규모가 클수록 영향 -&amp;gt; Styled components는 새로 업데이트될 때마다 속도가 이전보다 xx% 빨라졌다고 광고함. (그만큼 현재는 느리다는 뜻 아닐까?)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;렌더링 되는 시점에 스타일 코드가 추가됨
    &lt;ul&gt;
      &lt;li&gt;CSS 파일을 캐시 할 수 없음 (파일 자체가 없음)&lt;/li&gt;
      &lt;li&gt;Head영역이 아닌 Body영역에서 렌더링 됨 -&amp;gt; 스타일 없는 컴포넌트가 렌더링 되고 스타일이 뒤늦게 적용됨 (안 이쁨) -&amp;gt; SSR 설정으로 해결 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;러닝커브
    &lt;ul&gt;
      &lt;li&gt;이미 CSS를 잘 쓰고 있는 사람들의 불만&lt;del&gt;(또 뭐 새로 나왔어?)&lt;/del&gt;이지만 경험상 러닝 커브 매우 낮음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;고려할 점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;일반 CSS파일과 사용
    &lt;ul&gt;
      &lt;li&gt;CSS-in-JS와 일반 CSS를 같이 사용할 수 있음&lt;/li&gt;
      &lt;li&gt;기본 + 공통 레이아웃은 기존처럼 CSS파일로 작성하고 컴포넌트와 혼용해서 사용&lt;/li&gt;
      &lt;li&gt;컴포넌트 스타일을 최소화하여 오버헤드를 줄임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;자바스크립트 코드에서 스타일 코드 감추기
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;//#region style&lt;/code&gt; 과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;//#endregion&lt;/code&gt;으로 스타일 코드의 시작과 끝을 감싸면 VSCode에서 코드를 접었다 폈다 할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;참고링크&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.styled-components.com/&quot;&gt;styled-components&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.vjeux.com/2014/javascript/react-css-in-js-nationjs.html&quot;&gt;Vjeux » React: CSS in JS – NationJS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;atomic-design---컴포넌트를-구조화하자&quot;&gt;Atomic Design - 컴포넌트를 구조화하자&lt;/h2&gt;

&lt;p&gt;React를 사용하는 프로젝트가 많아지고 공통 컴포넌트가 생기면서 컴포넌트에 계층구조가 필요하게 되었습니다.&lt;/p&gt;

&lt;p&gt;작은 컴포넌트가 모여 큰 컴포넌트가 되고 큰 컴포넌트가 모여 더 큰 컴포넌트가 된다는 개념을 잘 정리한 것이 Atomic Design 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2020-01-07-2019-dev-summary/atomic-design.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림만 봐도 직관적으로 계층 구조가 이해되지만 문제는 영어였습니다. atoms, template, pages는 익숙한데 molecule, organism은 입에 붙지 않았던 거죠. 그래서 개념을 살짝 바꿔 다음과 같이 사용 중입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;atom - atoms + molecule을 포함하는 계층&lt;/li&gt;
  &lt;li&gt;block - organism 대체&lt;/li&gt;
  &lt;li&gt;component - template 대체&lt;/li&gt;
  &lt;li&gt;pages - pages 동일&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;참고링크&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://bradfrost.com/blog/post/atomic-web-design&quot;&gt;Atomic Design | Brad Frost&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.muz.li/building-design-systems-with-atomic-design-93a13286f676&quot;&gt;Building Design Systems with Atomic Design - Muzli - Design Inspiration&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;storybook---공통-컴포넌트-개발환경&quot;&gt;Storybook - 공통 컴포넌트 개발환경&lt;/h2&gt;

&lt;p&gt;공통 컴포넌트를 개발하기 위해선 임의의 페이지를 만들어야 합니다. 뭔가 보면서 하려면 해당 컴포넌트만 덩그러니 렌더링 되는 페이지가 필요한 거죠.&lt;/p&gt;

&lt;p&gt;Storybook은 컴포넌트를 위한 개발환경입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2020-01-07-2019-dev-summary/storybook-intro.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;디자인이 깔끔하고 사용법이 쉬워 공통 컴포넌트를 개발하거나 갤러리 용도로 사용하기 좋습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;유용한 플러그인&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addon-knobs&lt;/code&gt; props를 변경할 수 있는 UI 컨트롤 제공&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addon-viewport&lt;/code&gt; phone, tablet, pc 해상도 테스트&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;참고링크&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://storybook.js.org/&quot;&gt;Storybook: UI component explorer for frontend developers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ant-design---어드민을-위한-react-프레임워크&quot;&gt;Ant Design - 어드민을 위한 React 프레임워크&lt;/h2&gt;

&lt;p&gt;React를 이용하여 관리자 화면을 만들 때 한동안 &lt;a href=&quot;https://getbootstrap.com/&quot;&gt;Bootstrap&lt;/a&gt;을 사용했습니다. Bootstrap은 jQuery 기반이지만 React용 라이브러리도 있고 오랫동안 써봐서 빠르게 만들 수 있었습니다.&lt;/p&gt;

&lt;p&gt;시간이 흘러 더 이쁘고 사용하기 편리한 React UI Kit들이 등장했습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://elemental-ui.com/&quot;&gt;Elemental UI&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.microsoft.com/en-us/fabric&quot;&gt;Home - Office UI Fabric&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://atlaskit.atlassian.com/&quot;&gt;Atlaskit by Atlassian&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://evergreen.segment.com/&quot;&gt;Evergreen&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://polaris.shopify.com/&quot;&gt;Shopify Polaris&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여러가지 고민 끝에 최종적으로 선택한 것이 &lt;a href=&quot;https://ant.design/&quot;&gt;Ant Design&lt;/a&gt; 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2020-01-07-2019-dev-summary/antd-component.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ant Design&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;타입스크립트 지원&lt;/li&gt;
  &lt;li&gt;잘 정리된 문서&lt;/li&gt;
  &lt;li&gt;다양한 폼 컨트롤 - Cascader 좋음&lt;/li&gt;
  &lt;li&gt;폼 서브밋, 유효성 검사, 에러 처리&lt;/li&gt;
  &lt;li&gt;고급 기능을 가진 테이블 컴포넌트&lt;/li&gt;
  &lt;li&gt;GitHub Star 수 55K&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;참고링크&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://ant.design/&quot;&gt;Ant Design - The world’s second most popular React UI framework&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;nextjs---간단하고-강력한-react-프레임워크&quot;&gt;Next.js - 간단하고 강력한 React 프레임워크&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2020-01-07-2019-dev-summary/black-nextjs.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;React는 코딩보다 설정이 어렵다는 전설이 있습니다. 타입스크립트를 쓰거나 페이지별로 스크립트 파일을 분리하는 것, SSR 설정하기, CSS 프레임워크 설정은 숙련된 개발자도 고생입니다.
모두 다 같은 고생을 하고 있었고 no configuration 컨셉을 사용한 여러 가지 프레임워크가 나왔습니다. 최근 즐겨 쓰고 있는 프레임워크는 Next.js 입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Next.js 특징&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;운영 환경 검증
    &lt;ul&gt;
      &lt;li&gt;Hulu, Tencent News, Twitch, AT&amp;amp;T, Auth0 등 다양한 곳에서 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파일 기반 라우팅 제공
    &lt;ul&gt;
      &lt;li&gt;/pages/index.js -&amp;gt; /&lt;/li&gt;
      &lt;li&gt;/pages/about.js -&amp;gt; /about&lt;/li&gt;
      &lt;li&gt;/pages/posts/[id].js -&amp;gt; /posts/:id (고민의 흔적 캬 👍)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정적페이지 생성 기능
    &lt;ul&gt;
      &lt;li&gt;빌드 후 html 파일 생성&lt;/li&gt;
      &lt;li&gt;동적인 페이지 지원 (/posts/1 -&amp;gt; posts/1.html, /posts/2 -&amp;gt; posts/2.html, …)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;API 전용 라우팅 지원
    &lt;ul&gt;
      &lt;li&gt;/pages/&lt;strong&gt;api&lt;/strong&gt;/myApi.js&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;수십 가지 다양한 라이브러리 &lt;a href=&quot;https://github.com/zeit/next.js/tree/canary/examples&quot;&gt;연동 예제&lt;/a&gt; (redux, apollo, …) 제공&lt;/li&gt;
  &lt;li&gt;Server Side Rendering(SSR) 지원&lt;/li&gt;
  &lt;li&gt;타입스크립트 지원&lt;/li&gt;
  &lt;li&gt;Babel, webpack 커스터마이징 지원&lt;/li&gt;
  &lt;li&gt;Express, Koa, Micro 등 다양한 커스텀 웹서버 지원&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 모든 기능을 별다른 설정 없이 바로 사용할 수 있습니다. 설정이 간편하면서 확장성을 고려하기는 쉽지 않은데 그 어려운걸 &lt;a href=&quot;https://zeit.co/&quot;&gt;ZEIT&lt;/a&gt;가 해냅니다! &lt;del&gt;칭찬해&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;참고링크&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://nextjs.org/&quot;&gt;Next.js - The React Framework&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zeit.co/&quot;&gt;World-Class Static Hosting - ZEIT&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;headless-cms---머리없는-컨텐츠-관리-시스템&quot;&gt;Headless CMS - 머리없는 컨텐츠 관리 시스템&lt;/h2&gt;
&lt;p&gt;Next.js를 본격적으로 도입하기 전에 작은 규모의 브랜드 소개 사이트를 만들었습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;새로운 기술을 사용했을 때 발생하는 리스크를 줄이기 위해 작은, 중간 사이즈의 프로젝트에서 시범 적용을 합니다. Next.js의 경우 약 5개의 작은 프로젝트에서 6개월 정도 사용하고 메인 프로젝트에 적용했습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;브랜드 소개 사이트는 복잡한 비지니스 로직은 없지만 소개, 이미지 갤러리, 매장같은 정보가 수시로 변경되었습니다. 컨텐츠 관리를 좀 더 쉽게 하는 방법 &lt;del&gt;일 안 하는 방법&lt;/del&gt; 을 찾다가 Headless CMS를 발견했습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Headless CMS란&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2020-01-07-2019-dev-summary/prismic.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;백엔드 온리 시스템
    &lt;ul&gt;
      &lt;li&gt;프론트엔드와 분리된 순수 컨텐츠 관리에 최적화된 백엔드 시스템&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;REST API / GraphQL
    &lt;ul&gt;
      &lt;li&gt;프론트엔드는 API를 이용하여 HeadlessCMS 조회&lt;/li&gt;
      &lt;li&gt;정렬, 페이징, 검색 기능 제공&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;테이블과 컬럼 관리
    &lt;ul&gt;
      &lt;li&gt;손쉬운 컨텐츠 관리 화면 제공&lt;/li&gt;
      &lt;li&gt;문자열, 텍스트, 셀렉트 박스, 라디오 박스, 이미지 같은 범용 타입 제공&lt;/li&gt;
      &lt;li&gt;테이블 간 1:N 설계 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;협업, 버전 관리, 스케줄링, 다국어 기능 제공&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Headless CMS를 검색하면 &lt;del&gt;너무&lt;/del&gt; 다양한 서비스와 설치형 프로그램이 나오는데 대동소이한 기능을 제공합니다. 그중에 설치형으로 괜찮았던 것은 directus였고 서비스로 괜찮았던 것은 prismic 이었습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Directus&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;오픈소스 &amp;amp; 설치형&lt;/li&gt;
  &lt;li&gt;MySql과 S3 파일 업로드&lt;/li&gt;
  &lt;li&gt;사용자별 권한 관리&lt;/li&gt;
  &lt;li&gt;다양한 기능을 제공하는 API&lt;/li&gt;
  &lt;li&gt;단점은 소소한 버그들. 개발이 빠른 편이여서 이미 다 해결되었을지도..?&lt;/li&gt;
  &lt;li&gt;마이그레이션 귀찮음 (설치형은 어쩔 수 없음)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Prismic&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;유료 서비스지만 관리자 1명은 무료&lt;/li&gt;
  &lt;li&gt;트래픽 과금 있지만 기본 제공 넉넉한 편&lt;/li&gt;
  &lt;li&gt;GraphQL 인터페이스 제공&lt;/li&gt;
  &lt;li&gt;다양한 언어별 라이브러리 제공. 사용하기 편리함&lt;/li&gt;
  &lt;li&gt;예약 발행 기능, 레이아웃 기능, A/B 테스트, 웹 훅 기능&lt;/li&gt;
  &lt;li&gt;자바스크립트 한 줄로 가능한 In-website preview 기능 (이건.. 직접 써봐야 감이 옴. 이렇게 편하게 구현할 수도 있구나.. 살짝 감동)&lt;/li&gt;
  &lt;li&gt;아주 가~끔 API 호출을 실패할 때가 있음. 요청 실패를 대비하여 cache와 fallback 정책 필수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;참고링크&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://directus.io/&quot;&gt;Open-Source Headless CMS &amp;amp; API — Directus&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://prismic.io/&quot;&gt;Make your website editable for the whole team - Prismic&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;graphqlfeat-hasura-도입&quot;&gt;GraphQL(feat. hasura) 도입&lt;/h2&gt;

&lt;p&gt;GraphQL은 페이스북에서 만든 쿼리&lt;sub&gt;Query&lt;/sub&gt; 언어입니다. 언젠가부터 개발자 커뮤니티에서 자주 이야기가 되고 있었는데 REST API 방식을 별문제 없이 쓰고 있었기에 특별히 도입할 생각은 없었습니다. 그러던 어느 날 GraphQL이 운명처럼 다가왔습니다.&lt;/p&gt;

&lt;p&gt;위에서 언급한 Prismic을 한창 사용하고 있을 때, 페이스북에서 우연히 Prisma 설치 글을 봤습니다. “Prismic은 설치형이 없는 줄 알았는데 뭐지?” 하고 들어갔다가 글자를 해갈렸다는 걸 알았지만 내용이 괜찮았고 특히 관리자가 이뻤습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2020-01-07-2019-dev-summary/prisma.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그 당시에 새로운 CMS를 만들고 있었는데 우연이 발견한 Prisma가 좋은 해결책이 될 것 같았고 분석 결과 빠르게 요구사항을 대응하고, 확장 가능한 구조를 만들 수 있다는 걸 확인했습니다.&lt;/p&gt;

&lt;p&gt;그렇게 2주 정도 프로토타입을 만들다가 치명적인 단점을 발견합니다. Prisma 기본 기능으로는 전체 데이터 개수와 같은 aggregate 데이터를 가져올 수 없었습니다. SQL을 사용하여 별도로 구현할까 고민하다가 또 우연히 GraphQL 엔진의 끝판왕 Hasura를 만납니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hasura&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Haskell 기반의 가볍고 빠른 오픈소스 GraphQL 엔진&lt;/li&gt;
  &lt;li&gt;Postgres 지원. jsonb 타입 사용 가능&lt;/li&gt;
  &lt;li&gt;강력한 Admin 기능
    &lt;ul&gt;
      &lt;li&gt;조회, 추가, 수정, 삭제 화면 제공&lt;/li&gt;
      &lt;li&gt;인증, 인가, 이벤트 트리거 등 각종 기능 웹 콘솔 제공&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;강력한 Query 기능
    &lt;ul&gt;
      &lt;li&gt;기본 Query + filter, sort, aggregate, paginate, distinct 지원&lt;/li&gt;
      &lt;li&gt;filter - eq, neq, gt, lt, Ute, lte, in, min, like, contains, has_key, and, or, .. 지원&lt;/li&gt;
      &lt;li&gt;aggregate -  count, sum, avg, max, min 지원&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;강력한 Mutation 기능
    &lt;ul&gt;
      &lt;li&gt;Insert, Update, Delete 외에 Upsert 지원&lt;/li&gt;
      &lt;li&gt;Upsert - key가 있으면 Update하고 없으면 Insert. 은근 유용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이벤트 트리거&lt;/li&gt;
  &lt;li&gt;JWT 기반 인증 &amp;amp; 인가&lt;/li&gt;
  &lt;li&gt;Table View 연동 기능&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hasura는 GraphQL의 유연한 인터페이스를 이용하여 강력한 기본 기능을 제공합니다. 마치 예전 Ruby on rails의 15분 만에 블로그 만들기를 보는 것 같은 느낌입니다.&lt;/p&gt;

&lt;p&gt;실제 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;좋아요 기능&lt;/code&gt;을 하루 만에 만들었는데, 대부분의 시간은 프론트엔드를 만드는데 걸렸고 백엔드는 테이블 설계가 전부였습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;참고링크&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://hasura.io/&quot;&gt;Instant realtime GraphQL on Postgres | Hasura GraphQL Engine&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;apollo---최고의-graphql-라이브러리&quot;&gt;Apollo - 최고의 GraphQL 라이브러리&lt;/h2&gt;

&lt;p&gt;Apollo는 Nodejs기반으로 GraphQL과 관련된 다양한 도구를 제공합니다. Client(React), Server뿐 아니라 Cache, Manager(분석도구)를 제공하고 다양한 플러그인을 붙여 생산성을 높여줍니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Apollo Client&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;선언적 데이터 조회
    &lt;ul&gt;
      &lt;li&gt;React가 렌더링 될 때 데이터를 로드하고 쿼리에서 사용하는 변수가 바뀌면 다시 로드함&lt;/li&gt;
      &lt;li&gt;데이터, 로딩, 에러를 상태로 관리 -&amp;gt; React hook과 잘 어울림&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;개발환경
    &lt;ul&gt;
      &lt;li&gt;타입스크립트 지원, 크롬 개발자 도구 지원, VSCode 플러그인 지원&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;캐시
    &lt;ul&gt;
      &lt;li&gt;타입별 ID 기반 캐시 사용 (데이터에 식별자가 꼭 있어야 함)&lt;/li&gt;
      &lt;li&gt;페이지가 렌더링 되면 캐시에 있는 데이터를 먼저 로드한 후 네트워크로 조회한 데이터로 갱신&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FetchPolicy&lt;/code&gt;에서 캐시와 네트워크 설정을 할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;로컬 상태 관리
    &lt;ul&gt;
      &lt;li&gt;로컬 상태를 GraphQL로 관리&lt;/li&gt;
      &lt;li&gt;Redux, MobX 대체&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SSR 지원
    &lt;ul&gt;
      &lt;li&gt;컴포넌트에서 사용할 쿼리를 뽑아 호출하고 페이지 렌더링 할 때 로컬 캐시로 제공&lt;/li&gt;
      &lt;li&gt;SSR을 적용할 쿼리와 아닌 쿼리 구분 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Batch 기능
    &lt;ul&gt;
      &lt;li&gt;여러 번 나눠서 호출하는 쿼리를 하나로 합쳐줌&lt;/li&gt;
      &lt;li&gt;요청이 최적화되는 장점이 있지만, 가장 느린 쿼리가 응답할 때까지 기다린다는 단점이 있음&lt;/li&gt;
      &lt;li&gt;TIP - SSR에서는 batch를 사용하고 CSR에서는 batch를 끔&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;PersistedQueries 기능
    &lt;ul&gt;
      &lt;li&gt;GraphQL Query의 특징은 단일 엔드포인트에 POST방식으로 필요한 &lt;del&gt;거대한&lt;/del&gt; 쿼리를 매번 요청함&lt;/li&gt;
      &lt;li&gt;이 방식은 유연하고 편리하지만 캐시와 오버헤드가 문제 - POST는 네트워크 캐시를 사용할 수 없고 거대한 쿼리는 매번 오버헤드임&lt;/li&gt;
      &lt;li&gt;PersistedQueries는 요청을 hash key로 치환하고 GET 방식을 사용. 캐시 사용 가능하고 거대한 쿼리를 사용하지 않아도 됨 - 서버 지원 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Mock 지원
    &lt;ul&gt;
      &lt;li&gt;GraphQL은 요청하는 사람이 응답할 데이터를 정의할 수 있다는 특징 때문에 mock을 작성하는 것도 굉장히 유연함&lt;/li&gt;
      &lt;li&gt;필요한 데이터를 mock 데이터로 미리 만들어 작업하고 백엔드 개발이 완료되면 타입스크립트의 리팩토링 기능으로 변수명을 맞춰주면 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Apollo Server&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2020-01-07-2019-dev-summary/apollo-server.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;다양한 데이터 소스 지원
    &lt;ul&gt;
      &lt;li&gt;GraphQL, REST API, 데이터베이스 등 다양한 백엔드 연동&lt;/li&gt;
      &lt;li&gt;스무스하게 의도한 데로 잘 동작함 &lt;del&gt;이게 돼?&lt;/del&gt;&lt;/li&gt;
      &lt;li&gt;클라이언트는 Apollo Server를 단일 엔드포인트로 바라보고 Apollo Server가 여러 서비스를 조합하는 Gateway 형식을 사용할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;GraphQL Playground 지원 - GraphQL 쿼리를 실행하고 테스트할 수 있는 페이지 제공. 이쁨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Apollo Graph Manager&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2020-01-07-2019-dev-summary/apollo-engine.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Apollo Server와 연동해서 사용하는 분석 도구 - API Key만 입력하면 됨&lt;/li&gt;
  &lt;li&gt;GraphQL에 특화됨
    &lt;ul&gt;
      &lt;li&gt;GraphQL은  모든 요청이 단일 엔드포인트를 바라보고 있어 일반 APM 분석도구를 사용하기에 적합하지 않음 -&amp;gt; 어떤 쿼리가 이슈가 있는지 파악하기 어려움&lt;/li&gt;
      &lt;li&gt;쿼리를 분석하고 단계별로 추적해줌&lt;/li&gt;
      &lt;li&gt;쿼리 별로 평균 응답 시간, 느린 응답 시간, 요청 횟수 등을 분석할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;GraphQL 스키마 관리 기능 제공&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;참고링크&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.apollographql.com/&quot;&gt;Apollo GraphQL | Apollo Data Graph Platform— unify APIs, microservices, and databases into a data graph that you can query with GraphQL&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;정적페이지-만들기---html의-귀환&quot;&gt;정적페이지 만들기 - HTML의 귀환&lt;/h2&gt;

&lt;p&gt;최근 개발 스택이 복잡해지면서 하나의 페이지를 만드는데 많은 기술이 들어가고 서버 응답은 점점 느려집니다. 다행히 서버 성능이 좋아지고 비용은 저렴해지면서 돈으로 해결 가능하지만 그것도 한계가 있습니다. 💸&lt;/p&gt;

&lt;p&gt;최근에 가장 관심을 많이 가지고 있는 것은 정적페이지 생성입니다. 렌더링 된 결과를 HTML 정적페이지로 만들고 CDN으로 배포하는 거죠.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;정적페이지?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;서버, 데이터베이스를 거치지 않고 완성된 HTML을 제공하기 때문에 굉장히 빠름&lt;/li&gt;
  &lt;li&gt;접속자 수가 많거나 갑자기 몰려도 안정적&lt;/li&gt;
  &lt;li&gt;서버 코드가 없기 때문에 에러도 없음&lt;/li&gt;
  &lt;li&gt;비용이 저렴함 (작은 규모는 무료도 가능)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정적페이지라고 하면 Jekyll이 떠오릅니다. 지금 이 블로그도 Jekyll을 이용하여 정적페이지를 만들고 GitHub을 통해 무료로 제공하고 있습니다.&lt;/p&gt;

&lt;p&gt;작은 블로그나 티저 사이트에서 정적페이지를 사용하는 건 가능하지만, E-커머스나 큰 규모의 프로젝트에서도 사용할 수 있을까요?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;동적인 데이터 연동하기&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Static Site Generation (SSG) &lt;del&gt;신세계쓱&lt;/del&gt;
    &lt;ul&gt;
      &lt;li&gt;시간별 배너나, 새로운 상품 목록이 포함된 페이지는 데이터가 바뀌면 정적 페이지도 변경해야 함&lt;/li&gt;
      &lt;li&gt;특정 주기(5분에 한번)나 관리자가 업데이트 버튼을 눌렀을 때 페이지를 갱신하면 어떨까?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Client Side Rendering (CSR)
    &lt;ul&gt;
      &lt;li&gt;로그인 상태나 관리자페이지처럼 정적페이지 제공이 불가능한 경우 동적인 데이터가 필요한 영역을 CSR로 처리&lt;/li&gt;
      &lt;li&gt;해당 영역은 빈값(또는 기본값)으로 로드하고 클라이언트에서 API를 호출하여 추가로 렌더링&lt;/li&gt;
      &lt;li&gt;네이버 메인등 접속자 수가 엄청나게 많은 페이지에서 이미 사용중인 방법&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;아이디어는 심플합니다. 정적페이지를 최대한 활용하고 공통으로 적용하기 어려운 영역을 스크립트로 처리하는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2020-01-07-2019-dev-summary/ssr-csr.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;구현하기&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Next.js Export 기능
    &lt;ul&gt;
      &lt;li&gt;Export는 SSR을 이용하여 각 페이지를 HTML 파일로 출력함&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/posts/[id]&lt;/code&gt;와 같은 동적인 링크도 적용 가능 (API로 목록을 가져와서 구성)&lt;/li&gt;
      &lt;li&gt;제약사항 - 일부 서버 로직은 처리할 수 없음. User-Agent에 따라 페이지를 분기하거나 Cookie를 사용한다던가&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Apollo SSR 기능
    &lt;ul&gt;
      &lt;li&gt;SSG가 가능한 영역은 SSR 옵션을 켜고 그렇지 않은 부분은 끔&lt;/li&gt;
      &lt;li&gt;SSR 옵션을 켠 부분은 정적인 페이지로 제공하고 끈 부분은 페이지 로드 후 요청&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;AWS Lambda Edge 활용
    &lt;ul&gt;
      &lt;li&gt;Lambda Edge는 CDN 호출 앞뒤로 사용할 수 있는 작고 가벼운 API&lt;/li&gt;
      &lt;li&gt;Export의 제약사항 일부 해결&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위에서 언급한 기술은 정적인 마크업, 자바스크립트, API로 요약할 수 있습니다. 이 기술을 사용한 스택을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Jamstack&lt;/code&gt;이라고 하고 2020년에 뜨지 않을까? 예측해봅니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;참고링크&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://rauchg.com/2020/2019-in-review&quot;&gt;2019 in Review&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://jamstack.org/&quot;&gt;Jamstack | JavaScript, APIs, and Markup&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;배포-프로세스-개선---google-next-2019-sf&quot;&gt;배포 프로세스 개선 - Google Next 2019 SF&lt;/h2&gt;
&lt;p&gt;Google Next는 구글에서 진행하는 클라우드 컨퍼런스입니다. 2019년엔 샌프란시스코, 도쿄, 영국에서 열렸고 2020년도 샌프란시스코에서 열릴 예정입니다.&lt;/p&gt;

&lt;p&gt;2019년 4월 샌프란시스코에서 열린 컨퍼런스에 참가하여 많은 세션을 들었고 가장 기억에 남은 건 CI/CD와 빠른 배포 주기에 대한 내용이었습니다.&lt;/p&gt;

&lt;p&gt;보통 개발팀의 규모가 커질수록 배포는 어려울 꺼라고 생각했는데 우리보다 수십, 수백 배 규모의 회사에서 하루에도 몇 번씩 운영 배포를 하는 것에 큰 충격😱을 받고 한동안 배포 프로세스 개선을 진행했습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;개선내용&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AWS ECR 도입
    &lt;ul&gt;
      &lt;li&gt;설치형 도커 레지스트리 -&amp;gt; 은근히 용량이 빨리 참 -&amp;gt; ECR은 사실상 무제한!&lt;/li&gt;
      &lt;li&gt;설치가 단순한 서비스라도 가급적 매니지드 서비스를 이용하기로 결심&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CI와 CD를 분리하자
    &lt;ul&gt;
      &lt;li&gt;기존엔 빌드와 배포가 한 번에 이루어졌음 - 롤백이나 확장이 느림&lt;/li&gt;
      &lt;li&gt;CI는 도커 이미지를 만들어 저장소에 올리고 CD는 도커 컨테이너를 배포하도록 변경&lt;/li&gt;
      &lt;li&gt;개발 브랜치를 푸시하면 CI가 이미지를 만들어 놓고 테스트할 땐 만들어 놓은 이미지를 활용하여 테스트 효율을 높임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Feature Flag 도입
    &lt;ul&gt;
      &lt;li&gt;기존엔 새로운 기능을 만들면서 기존 기능을 지웠음&lt;/li&gt;
      &lt;li&gt;Feature Flag로 새로운 기능과 기존 기능을 껐다 킬 수 있게 함&lt;/li&gt;
      &lt;li&gt;기능이 완성되는 데로 배포 먼저 하고 원하는 시점에 기능을 오픈할 수 있음. 문제 생기면 배포 없이 끄는 것도 가능&lt;/li&gt;
      &lt;li&gt;일부 사용자를 대상으로 조금씩 오픈하는 것도 고려&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;참고링크&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://cloud.withgoogle.com/next/sf/&quot;&gt;Google Cloud Next ’20 | April 6-8&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://engineering.fb.com/web/rapid-release-at-massive-scale/&quot;&gt;Rapid release at massive scale - Facebook Engineering&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://launchdarkly.com/&quot;&gt;Feature Flag and Toggle Management For Continuous Delivery | LaunchDarkly&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.thoughtworks.com/radar/techniques/decoupling-deployment-from-release&quot;&gt;Decoupling deployment from release | Technology Radar | ThoughtWorks&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/@thysniu/coding-with-feature-flags-how-to-guide-and-best-practices-3f9637f51265&quot;&gt;Coding with Feature Flags: How-to Guide and Best Practices&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;cloud-run---가장-쉬운-컨테이너-배포-방법&quot;&gt;Cloud Run - 가장 쉬운 컨테이너 배포 방법&lt;/h2&gt;

&lt;p&gt;Google Next 2019에서 발표한 것 중 가장 기대했던 건 Cloud Run이었습니다. AWS 람다처럼 사용하기 쉽고 컨테이너를 사용하기 때문에 언어나 환경에 제한이 없는 환상적인 기술입니다.&lt;/p&gt;

&lt;p&gt;Cloud Run 자체도 좋았지만 Google Cloud를 이용하여 Cloud Run에 배포하는 과정이 더 좋았습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cloud Run 배포하기&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cloud Source Repository
    &lt;ul&gt;
      &lt;li&gt;Git 저장소인데 뭔가 구글스러운(안 이쁜) UI&lt;/li&gt;
      &lt;li&gt;메인 저장소가 아니라 배포를 위한 저장소로 사용
        &lt;ul&gt;
          &lt;li&gt;origin - 기존 git 원격 저장소&lt;/li&gt;
          &lt;li&gt;google - cloud source repository&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Google Cloud Build
    &lt;ul&gt;
      &lt;li&gt;Cloud Source Repository에 소스가 푸시되면 트리거 발생&lt;/li&gt;
      &lt;li&gt;Dockerfile이 있으면 모든 게 자동화 - Commit ID로 도커 이미지를 빌드하고 Container Registry에 이미지를 저장&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Cloud Run
    &lt;ul&gt;
      &lt;li&gt;애플리케이션을 만들 때 Container Regsitry에 등록된 이미지를 선택&lt;/li&gt;
      &lt;li&gt;커스텀 도메인 연결은 도메인 관리자에서 CNAME만 추가하면 됨&lt;/li&gt;
      &lt;li&gt;Google Cloud SQL(MySQL) 연동 가능&lt;/li&gt;
      &lt;li&gt;HTTPS 기본 지원&lt;/li&gt;
      &lt;li&gt;사용한 만큼만 비용 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;소스 저장소만 만들면 배포까지 5분도 걸리지 않습니다. 역시 구글!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;참고링크&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://cloud.google.com/run/&quot;&gt;Cloud Run   |  Google Cloud&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;kubernetes---eks-도입&quot;&gt;Kubernetes - EKS 도입&lt;/h2&gt;

&lt;p&gt;쿠버네티스는 구글이 만든 컨테이너 오케스트레이션 도구입니다. 도커를 사용하고 어느 정도 규모가 있는 곳에서는 거의 필수적으로 사용하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;쿠버네티스 개선&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;KOPS -&amp;gt; EKS
    &lt;ul&gt;
      &lt;li&gt;기존에 KOPS로 구축한 클러스터를 EKS로 변경 - On demand와 Spot 인스턴스 사용&lt;/li&gt;
      &lt;li&gt;EKS는 마스터 서버를 알아서 관리해줌&lt;/li&gt;
      &lt;li&gt;마스터 서버에 직접 접근이 안되기 때문에 몇 가지 제약이 있음 -&amp;gt; 일반적인 상황에서는 크게 문제가 없고, 시간이 지나면서 하나둘 제약이 없어지고 있음&lt;/li&gt;
      &lt;li&gt;KOPS를 잘 사용하고 있다면 굳이 옮길 필요는 없어 보임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;쿠버네티스 배포
    &lt;ul&gt;
      &lt;li&gt;Helm과 ArgoCD 사용&lt;/li&gt;
      &lt;li&gt;GitOps 방식 완소🥰&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Istio
    &lt;ul&gt;
      &lt;li&gt;1년째 테스트만.. 적용할까 말까&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;클러스터 업데이트 시 주의점
    &lt;ul&gt;
      &lt;li&gt;노드를 업데이트할 때 기존 컨테이너를 다른 노드에 생성하지 않고 노드가 삭제됨 -&amp;gt; 복제개수가 1개라면 잠시 서비스 중단 발생 (예상은 컨테이너를 옮기고 노드를 지우는 건데..)&lt;/li&gt;
      &lt;li&gt;컨테이너를 2개 이상 띄우거나 Taint + Drain 조합으로 한 땀 한 땀 옮기는 작업 필요&lt;/li&gt;
      &lt;li&gt;혹시 쉽게 하는 법 아시는 분..?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;참고링크&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://subicura.com/2019/05/19/kubernetes-basic-1.html&quot;&gt;쿠버네티스 시작하기 - Kubernetes란 무엇인가?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.slideshare.net/subicura/gitops-cicd-156402754&quot;&gt;쿠버네티스를 이용한 기능 브랜치별 테스트 서버 만들기 (GitOps CI/CD)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://helm.sh/&quot;&gt;Helm Docs | Helm&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://argoproj.github.io/argo-cd/&quot;&gt;Argo CD - Declarative GitOps CD for Kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;terraform-드디어-도입&quot;&gt;Terraform 드디어 도입&lt;/h2&gt;

&lt;p&gt;테라폼은 하시코프에서 만든 인프라를 코드로 관리해주는 도구입니다. 인프라는 관리자 화면에서 클릭클릭으로 관리할 수 있지만 규모가 커질수록 관리가 어려워집니다. 그리고 문제가 생겨 복구를 하거나 비슷한 환경을 하나 더 만들려면 테라폼 같은 도구가 필요합니다.&lt;/p&gt;

&lt;p&gt;테라폼은 공부만 하고 있었는데 EKS를 도입하면서 적극적으로 사용하고 있습니다. &lt;del&gt;eksctl을 공부하느니 테라폼을 배우겠다&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;간단한(?) 테라폼 사용방법&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;리소스 선언&lt;/li&gt;
  &lt;li&gt;리소스 적용이 가능한지 테스트 (Plan)&lt;/li&gt;
  &lt;li&gt;테스트 후 실제 적용하기 (Apply)&lt;/li&gt;
  &lt;li&gt;1번으로 돌아감 (반복)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;참 쉽죠? 기본적인 사용법은 쉽지만, 문제는 &lt;strong&gt;리소스 선언&lt;/strong&gt; 입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;어려운 테라폼 리소스 선언&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;리소스를 선언하려면 해당 인프라에 대해 자세히 알아야 함
    &lt;ul&gt;
      &lt;li&gt;첫 시도에 적용은 사실상 어려움&lt;/li&gt;
      &lt;li&gt;관리자 화면에서 몇 번 만들면서 감을 잡고 코드로 옮김&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;인프라를 잘 안다고 하더라도 별도의 언어로 표현하는 건 다른 이야기
    &lt;ul&gt;
      &lt;li&gt;HCL 문법을 익혀야 함&lt;/li&gt;
      &lt;li&gt;보이지 않는 영역 (왜 리소스가 나누어져 있지?) 을 이해하고 여러 가지 팁을 알고 있어야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;레거시
    &lt;ul&gt;
      &lt;li&gt;기존에 만들어진 리소스를 테라폼 코드로 옮기기 어려움 &lt;del&gt;귀찮음&lt;/del&gt;&lt;/li&gt;
      &lt;li&gt;테라포밍이라는 도구를 쓰면 좋은데 전체 리소스를 지원하진 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;자유로운 구조
    &lt;ul&gt;
      &lt;li&gt;디렉토리부터 파일명까지 정해진 구조가 없음&lt;/li&gt;
      &lt;li&gt;상태 데이터를 로컬에 저장할지 S3에 저장할지 테라폼 엔터프라이즈에 저장할지 고민됨&lt;/li&gt;
      &lt;li&gt;어디까지 테라폼으로 관리하는 게 맞는지 고민됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;테라폼 팁&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;하나의 디렉토리에 많은 리소스가 있으면 Plan이 오래 걸리고 관리도 어려움&lt;/li&gt;
  &lt;li&gt;디렉토리를 나누고 작은 단위로 관리&lt;/li&gt;
  &lt;li&gt;서로 다른 디렉토리의 상태를 공유하는 방법
    &lt;ul&gt;
      &lt;li&gt;backend를 s3로 하고 각각의 키를 분리 ex) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpc/terraform.tfstate&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eks/terraform.tfstate&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;vpc에 output 선언 ex) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpc_id&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;public_subnet_a_id&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;eks에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform_remote_state&lt;/code&gt; data 선언 ex)  vpc/terraform.tfstate를 바라봄&lt;/li&gt;
      &lt;li&gt;eks에서 Plan을 하면 vpc와 관련된 데이터는 s3에서 가져오고 eks 관련 리소스만 체크함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;참고링크&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.terraform.io/&quot;&gt;Terraform by HashiCorp&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.44bits.io/ko/post/terraform_introduction_infrastrucute_as_code&quot;&gt;테라폼(Terraform) 기초 튜토리얼: AWS로 시작하는 Infrastructure as Code | 44bits.io&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/dtan4/terraforming&quot;&gt;GitHub - dtan4/terraforming: Export existing AWS resources to Terraform style (tf, tfstate)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;소중한-shopify-앱-개발-경험&quot;&gt;소중한 Shopify 앱 개발 경험&lt;/h2&gt;

&lt;p&gt;2019년 프로젝트 중에 Shopify를 사용한 것이 있습니다. Shopify는 글로벌 최대 E-커머스 플랫폼으로 플러그인이 굉장히 발달되어 있습니다. 플러그인이 페이스북 앱 같은 형태로 제공되는데 원하는 앱을 찾고 추가하면 OAuth 인증을 하고 필요한 권한을 요청합니다.&lt;/p&gt;

&lt;p&gt;가장 놀라고 많이 배운 점은 앱 개발 환경입니다. 기존 소스를 건드리지 않고 앱을 이용한 확장 방식은 굉장히 심플하고 강력합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Shopify 앱 개발하기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2020-01-07-2019-dev-summary/shopify-app.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;쇼핑몰에 등록된 상품 정보를 가져오는 앱을 한 시간 내에 만들 수 있음 - Nodejs기반의 쉬운 개발환경 + 튜토리얼&lt;/li&gt;
  &lt;li&gt;Shopify는 핵심 기능만 제공 - OAuth와 API, Webhook&lt;/li&gt;
  &lt;li&gt;기존 관리 화면에 앱을 포함 -&amp;gt; 별도의 앱이 아닌 하나의 앱처럼 보임&lt;/li&gt;
  &lt;li&gt;Shopify 관리자 UI를 React 컴포넌트로 제공 -&amp;gt; UI 가이드를 준수하면 기존 관리 화면과 이질감 없음. 모바일 지원 잘됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;참고링크&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://shopify.com/&quot;&gt;Ecommerce Software - Best Ecommerce Platform Made for You - Free Trial&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developers.shopify.com/tutorials/build-a-shopify-app-with-node-and-react&quot;&gt;Build a Shopify App with Node.js and React&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;업무-프로세스-개선&quot;&gt;업무 프로세스 개선&lt;/h2&gt;

&lt;p&gt;업무 프로세스 개선은 최애 관심사 중 하나입니다. 다양한 방법을 시도하고 괜찮은 방법을 선택하려고 노력하지만 모든 사람을 만족시킬 순 없어 고민 중입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;새로 도입한 프로세스 &amp;amp; 도구&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Asana - 새로운 이슈 관리 시스템
    &lt;ul&gt;
      &lt;li&gt;여러 이슈 관리 시스템을 돌고 돌아 &lt;del&gt;다시&lt;/del&gt; Asana로 정착&lt;/li&gt;
      &lt;li&gt;모든 기능이 다 있진 않지만 꼭 필요한 기능은 있는 느낌&lt;/li&gt;
      &lt;li&gt;iOS 한글 버그 언제 고치나..&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Unito - 연동 서비스
    &lt;ul&gt;
      &lt;li&gt;Asana - GitLab 연동 서비스&lt;/li&gt;
      &lt;li&gt;Asana에 이슈를 등록하면 GitLab에 이슈로 등록됨&lt;/li&gt;
      &lt;li&gt;Asana - GitLab Issue - GitLab Merge Request로 연결&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Notion - 쉬운 위키
    &lt;ul&gt;
      &lt;li&gt;간단한 메모부터 회의록, 위키, 개발 문서 정리, 자료 공유, 데이터 정리까지 지원 - 어떻게 화면을 구성하느냐에 따라 무궁무진하게 활용할 수 있음&lt;/li&gt;
      &lt;li&gt;동시에 여러 명이 편집할 수 있고 화면이 이쁨&lt;/li&gt;
      &lt;li&gt;개발 위주의 위키로 사용 중&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Daily Standup Meeting
    &lt;ul&gt;
      &lt;li&gt;직접 만나서 이야기하기 전에 Asana 팀 conversation에 어제 한일/오늘 할 일/이슈를 적음&lt;/li&gt;
      &lt;li&gt;오전에 30분 이내로 이슈를 짧게 공유&lt;/li&gt;
      &lt;li&gt;확실히 직접 얼굴을 보고 얘기해야 제맛 -&amp;gt; 안 보고 잘할 수 있는 방법은?!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;OKR
    &lt;ul&gt;
      &lt;li&gt;목표와 핵심 결과지표를 작성하고 결과를 추적할 수 있도록 도와주는 목표 설정 프레임워크&lt;/li&gt;
      &lt;li&gt;내용은 간단한 것 같은데 실천이 어려움&lt;/li&gt;
      &lt;li&gt;2019년엔 사실상 적용 실패 -&amp;gt; 2020년엔 잘해보자!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;참고링크&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://asana.com/&quot;&gt;Manage your team’s work, projects, &amp;amp; tasks online · Asana&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://unito.io/&quot;&gt;Unito :: Integrate Project Management Tools - Sync Trello, Jira, Asana…&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.notion.so/&quot;&gt;Notion – The all-in-one workspace for your notes, tasks, wikis, and databases.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;그래서&quot;&gt;그래서&lt;/h2&gt;

&lt;p&gt;그동안 사용한 기술을 빠르게 요약, 정리하려고 했는데 해가 넘어갔습니다😭 나중에 기회가 되면 요약 버전 말고 좀 더 심화 내용을 써 볼까 합니다.&lt;/p&gt;

&lt;p&gt;2019년은 유독 바빴던 한해였습니다. 블로그 글은 하나밖에 못썼지만.. &lt;del&gt;반성중 ㅠㅠ&lt;/del&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Next '19 Extended Seoul&lt;/code&gt;과  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Open Infrastructure &amp;amp; Cloud Native Days Korea 2019&lt;/code&gt;에서 발표하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;쿠버네티스 핸즈온&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;도커 워크숍&lt;/code&gt;도 진행했네요. 그리고 &lt;a href=&quot;https://www.imaso.co.kr/archives/5443&quot;&gt;마이크로소프트웨어 398호 클라우드의 어떤 것&lt;/a&gt;에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GitOps&lt;/code&gt;라는 주제로 기고를 했습니다.&lt;/p&gt;

&lt;p&gt;회사에선 조직이 커지면서 코딩하는 시간보다 팀을 정비하고 생산성을 높이기 위해 부수적인 노력을 많이 한 것 같습니다. 앞으로 많은 부분에서 고민이 깊어질 것 같습니다.&lt;/p&gt;

&lt;p&gt;2020년도 다 같이 성장하고 즐거운 한 해가 되기를 바랍니다. 🔥&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;비슷한 기술에 관심이 있으신가요? &lt;a href=&quot;http://m.me/purpleworks.co.kr&quot;&gt;이야기하기 ☕️&lt;/a&gt; &lt;a href=&quot;http://bit.ly/purpleworks-want-you&quot;&gt;채용공고 👋&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 07 Jan 2020 00:00:00 +0900</pubDate>
        <link>https://subicura.com/2020/01/07/2019-dev-summary.html</link>
        <guid isPermaLink="true">https://subicura.com/2020/01/07/2019-dev-summary.html</guid>
        
        <category>Typescript</category>
        
        <category>TSLint</category>
        
        <category>ESLint</category>
        
        <category>Prettier</category>
        
        <category>VSCode</category>
        
        <category>StyledComponent</category>
        
        <category>AtomicDesign</category>
        
        <category>Storybook</category>
        
        <category>AntDesign</category>
        
        <category>Nextjs</category>
        
        <category>GraphQL</category>
        
        <category>Apollo</category>
        
        <category>SSG</category>
        
        <category>GoogleNext</category>
        
        <category>CloudRun</category>
        
        <category>Kubernetes</category>
        
        <category>Terraform</category>
        
        <category>Shopify</category>
        
        
        <category>Development</category>
        
      </item>
    
      <item>
        <title>쿠버네티스 시작하기 - Kubernetes란 무엇인가?</title>
        <description>&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;/assets/article_images/2019-05-19-kubernetes-basic-1/docker-logo.png&quot; alt=&quot;docker logo&quot; style=&quot;width: 450px&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;2013년 등장한 도커&lt;sub&gt;docker&lt;/sub&gt;는 인프라 세계를 컨테이너&lt;sub&gt;container&lt;/sub&gt; 세상으로 바꿔버렸습니다. 수많은 애플리케이션이 컨테이너로 배포되고 도커파일을 만들어 이미지를 빌드하고 컨테이너를 배포하는 게 흔한 개발 프로세스가 되었습니다. 2019년 DockerCon 발표에선 무려 &lt;a href=&quot;https://twitter.com/ajeetsraina/status/1123258872443990017&quot;&gt;1052억번의 컨테이너 image pull&lt;/a&gt;이 발생했다고 합니다.&lt;/p&gt;

&lt;p&gt;이러한 도커의 인기와 함께 쿠버네티스&lt;sub&gt;kubernetes&lt;/sub&gt;의 인기도 엄청나게 치솟고 있습니다. 클라우드와 관련된 행사에 가면 여기저기서 다음과 같은 이야기를 들을 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;쿠버네티스 클러스터에 Deployment를 배포하고 Ingress를 연결하자. &lt;a href=&quot;https://github.com/kubernetes/ingress-nginx&quot;&gt;Nginx&lt;/a&gt;말고 &lt;a href=&quot;https://docs.traefik.io/user-guide/kubernetes/&quot;&gt;Traefik Ingress&lt;/a&gt;도 좋다던데?&lt;/li&gt;
  &lt;li&gt;AWS에 설치할 땐 &lt;a href=&quot;https://github.com/kubernetes/kops&quot;&gt;kops&lt;/a&gt;가 좋고 요즘엔 &lt;a href=&quot;https://aws.amazon.com/eks/&quot;&gt;EKS&lt;/a&gt;도 많이 쓰더라.&lt;/li&gt;
  &lt;li&gt;on-prem에 설치할 때 &lt;a href=&quot;https://github.com/kubernetes-sigs/kubespray&quot;&gt;kubespray&lt;/a&gt;, &lt;a href=&quot;https://github.com/kubernetes/kubeadm&quot;&gt;kubeadm&lt;/a&gt;, &lt;a href=&quot;https://rancher.com/&quot;&gt;rancher&lt;/a&gt;, &lt;a href=&quot;https://www.openshift.com/&quot;&gt;openshift&lt;/a&gt; 중에 뭐가 나을까?&lt;/li&gt;
  &lt;li&gt;쿠버네티스에 &lt;a href=&quot;https://istio.io/&quot;&gt;istio&lt;/a&gt;나 &lt;a href=&quot;https://linkerd.io/&quot;&gt;linkerd&lt;/a&gt; 설치해서 서비스메시 적용하고 &lt;a href=&quot;https://zipkin.io/&quot;&gt;zipkin&lt;/a&gt;으로 추적하자.&lt;/li&gt;
  &lt;li&gt;컨테이너 서버리스&lt;sub&gt;Serverless&lt;/sub&gt; &lt;a href=&quot;https://cloud.google.com/run/&quot;&gt;Cloud Run&lt;/a&gt;이 &lt;a href=&quot;https://cloud.google.com/knative/&quot;&gt;Knative&lt;/a&gt; 기반이라던데?&lt;/li&gt;
  &lt;li&gt;컨테이너 시대에 빌드, 배포는 &lt;a href=&quot;https://www.spinnaker.io/&quot;&gt;Spinnaker&lt;/a&gt;나 &lt;a href=&quot;https://jenkins.io/projects/jenkins-x/&quot;&gt;Jenkins X&lt;/a&gt; &lt;del&gt;(Jenkins와는 다름!)&lt;/del&gt; 써야지.&lt;/li&gt;
  &lt;li&gt;설정 파일은 &lt;a href=&quot;https://helm.sh/&quot;&gt;helm&lt;/a&gt;으로 만들고 &lt;a href=&quot;https://chartmuseum.com/&quot;&gt;ChartMuseum&lt;/a&gt;으로 관리하자.&lt;/li&gt;
  &lt;li&gt;클러스터 하나는 불안한데 멀티 클러스터 구성해야 하지 않을까? &lt;a href=&quot;https://cloud.google.com/anthos/&quot;&gt;Anthos&lt;/a&gt;?&lt;/li&gt;
  &lt;li&gt;클라우드 네이티브&lt;sub&gt;Cloud Native&lt;/sub&gt; 애플리케이션 만들어서 쿠버네티스에 배포하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2019-05-19-kubernetes-basic-1/i-dont-know.png&quot; alt=&quot;무슨 이야기인지..&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 모든 것들이 불과 2~3년 이내에 나온 것들로 인프라 세계가 이렇게 빨리 변한적이 있었나 싶습니다. 예전에는 일부 고오오급 회사에서만 썼던 것 같은데 이제 여기저기서 &lt;del&gt;나만 빼고&lt;/del&gt; 다 쓰는 거 같고 뭔가 좀 해보고 싶어도 설치부터 어렵고 내용이 복잡해서 배우기가 쉽지 않습니다.&lt;/p&gt;

&lt;p&gt;이 글은 쿠버네티스가 무엇인지 궁금한 엔지니어를 대상으로 쿠버네티스 세계의 입구까지 안내해 드립니다. 쿠버네티스의 세계는 너무 크고 광활하기 때문에 입구에 도착해서 어디로 갈지는 나중에 정하면 됩니다. 일단 쿠버네티스의 기본적인 개념과 구성을 알아보고 다음 글에서 클러스터 설치와 기본 사용법을 익혀보겠습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/2017/01/19/docker-guide-for-beginners-1.html&quot;&gt;도커에 대해 모른다면 → 초보를 위한 도커 안내서&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;쿠버네티스 시작하기 - 쿠버네티스란 무엇인가? ✓&lt;/strong&gt; &lt;span class=&quot;series&quot;&gt;SERIES 1/2&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2020/12/13/kubernetes-basic-2.html&quot;&gt;쿠버네티스 시작하기 - 설치부터 배포까지&lt;/a&gt; &lt;span class=&quot;series&quot;&gt;SERIES 2/2&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot; class=&quot;googleads googleads-content&quot;&gt;
                &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-2468713653725581&quot; data-ad-slot=&quot;8649023787&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
            &lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;쿠버네티스의-과거-현재-미래&quot;&gt;쿠버네티스의 과거, 현재, 미래&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;/assets/article_images/2019-05-19-kubernetes-basic-1/container-orchestration.png&quot; alt=&quot;container orchestration&quot; style=&quot;width: 450px&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;쿠버네티스는 다른 컨테이너 오케스트레이션 도구보다 비교적 늦게 등장했습니다. &lt;a href=&quot;https://docs.docker.com/engine/swarm/&quot;&gt;도커 스웜&lt;/a&gt;이 쉽고 간단한 사용법&lt;del&gt;끼워팔기&lt;/del&gt;을 앞세워 세력을 넓히고 있었고 AWS에서 &lt;a href=&quot;https://aws.amazon.com/ecs/&quot;&gt;ECS&lt;/a&gt;, 하시코프에서 &lt;a href=&quot;https://www.nomadproject.io/&quot;&gt;Nomad&lt;/a&gt;, 전통의 강호 &lt;a href=&quot;http://mesos.apache.org/&quot;&gt;Mesos&lt;/a&gt;에서 &lt;a href=&quot;https://mesosphere.github.io/marathon/&quot;&gt;Marathon&lt;/a&gt;을 발표했습니다.&lt;/p&gt;

&lt;p&gt;컨테이너 오케스트레이션이 하는 일은 여러 개의 서버에 컨테이너를 배포하고 운영하면서 서비스 디스커버리&lt;sub&gt;Service discovery&lt;/sub&gt;같은 기능을 이용하여 서비스 간 연결을 쉽게 해주는 것입니다. 서버마다 app01, db01, cache01 같은 이름을 지어주고 하나하나 접속하여 관리하는 것이 아니라 server1, 2, 3, 4..를 하나로 묶어 적당한 서버를 자동으로 선택해 애플리케이션을 배포하고 부하가 생기면 컨테이너를 늘리고 일부 서버에 장애가 발생하면 정상 동작 중인 서버에 다시 띄워 장애를 방지합니다. 위에서 이야기한 도구들은 대동소이한 기능을 제공했고 절대 강자 없이 한동안 컨테이너 오케스트레이션 춘추전국시대가 열렸습니다.&lt;/p&gt;

&lt;p&gt;이런 상황은 쿠버네티스가 등장하고 1~2년 정도 지나면서 완전히 바뀌었고 현재 쿠버네티스는 사실상의 표준&lt;del&gt;원픽&lt;/del&gt;이 되었습니다. (&lt;a href=&quot;https://www.cncf.io/blog/2018/08/29/cncf-survey-use-of-cloud-native-technologies-in-production-has-grown-over-200-percent/&quot;&gt;CNCF Survey&lt;/a&gt; 참고) 대규모 컨테이너를 관리했던 구글의 노하우와 강력한 확장성, 마이크로소프트, Red Hat, IBM 등 수많은 기업의 참여, 잘 짜인 설계가 쿠버네티스를 왕좌에 오르게 했습니다.&lt;/p&gt;

&lt;p&gt;Rancher 2.0, OpenShift(Red Hat), Tectonic(CoreOS), Docker Enterprise Edition등이 쿠버네티스를 기반으로 플랫폼을 만들어 대세임을 증명하고 있고 AWS, Google Cloud, Azure, Digital Ocean, IBM Cloud, Oracle Cloud 등에서 관리형&lt;sub&gt;Managed&lt;/sub&gt;서비스를 내놓음으로써 클라우드 컨테이너 시장을 평정하였습니다. 심지어 &lt;a href=&quot;http://www.ciokorea.com/column/40283&quot;&gt;어떤 칼럼&lt;/a&gt;에서는 더는 운영체제가 무엇인지 중요하지 않다며 쿠버네티스가 새로운 운영체제처럼 쓰일 것이라고 얘기했습니다. OS에 접속해서 프로그램을 한 땀 한 땀 설치하는 것이 아니라 쿠버네티스에 컨테이너를 배포하고 네트워크와 스토리지 설정을 하면 되는 거죠. &lt;del&gt;클라우드계의 리눅스&lt;/del&gt;&lt;/p&gt;

&lt;h2 id=&quot;쿠버네티스란&quot;&gt;쿠버네티스란?&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;/assets/article_images/2019-05-19-kubernetes-basic-1/kubernetes-logo.png&quot; alt=&quot;kubernetes logo&quot; style=&quot;width: 450px&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;쿠버네티스는 컨테이너를 쉽고 빠르게 배포/확장하고 관리를 자동화해주는 오픈소스 플랫폼입니다.&lt;/strong&gt; 몇 가지 수식어로 “운영환경에서 사용 가능한(production ready)”, “de facto(사실상 표준)”, “조타수(helmsman)”, “조종사(pilot)”, “행성 스케일(Planet Scale)”, “&lt;del&gt;갓(god)&lt;/del&gt;” 등을 가지고 있습니다. 쿠버네티스&lt;sub&gt;kubernetes&lt;/sub&gt;가 너무 길어서 &lt;del&gt;오타가 많아서&lt;/del&gt; 흔히 케이(에이)츠&lt;sub&gt;k8s&lt;/sub&gt; 또는 큐브&lt;sub&gt;kube&lt;/sub&gt;라고 줄여서 부릅니다.&lt;/p&gt;

&lt;p&gt;1주일에 수십억 개의 컨테이너를 생성하는 구글이 내부 배포시스템으로 사용하던 &lt;a href=&quot;https://kubernetes.io/blog/2015/04/borg-predecessor-to-kubernetes/&quot;&gt;borg&lt;/a&gt;를 기반으로 2014년 프로젝트를 시작했고 여러 커뮤니티의 아이디어와 좋은 사례를 모아 빠르게 발전하고 있습니다.&lt;/p&gt;

&lt;p&gt;단순한 컨테이너 플랫폼이 아닌 마이크로서비스, 클라우드 플랫폼을 지향하고 컨테이너로 이루어진 것들을 손쉽게 담고 관리할 수 있는 그릇 역할을 합니다. 서버리스, CI/CD, 머신러닝 등 다양한 기능이 쿠버네티스 플랫폼 위에서 동작합니다.&lt;/p&gt;

&lt;h2 id=&quot;쿠버네티스-특징&quot;&gt;쿠버네티스 특징&lt;/h2&gt;

&lt;p&gt;컨테이너 오케스트레이션의 기본 기능 외에 쿠버네티스가 가지는 차별화된 특징은 다음과 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;갓구글--고오오오급-회사들의-참여-eco-system&quot;&gt;갓구글 + 고오오오급 회사들의 참여 &lt;sub&gt;ECO System&lt;/sub&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://landscape.cncf.io/&quot;&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2019-05-19-kubernetes-basic-1/cncf-map.png&quot; alt=&quot;Cloud Native Landscape&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;전 세계적 스케일의 경험과 기술이 고스란히 녹아들어 있습니다. 거대한 커뮤니티와 생태계가 있어 잘 안 되는 건 찾아보면 되고 이런 거 만들어 볼까 하면 누군가 만들어 놨습니다. 서비스메시(Istio, linkerd), CI(Tekton, Spinnaker), 컨테이너 서버리스(Knative), 머신러닝(kubeflow)이 모두 쿠버네티스 환경에서 돌아갑니다. 클라우드 네이티브 애플리케이션 대부분이 쿠버네티스와 찰떡궁합입니다.&lt;/p&gt;

&lt;h3 id=&quot;다양한-배포-방식&quot;&gt;다양한 배포 방식&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2019-05-19-kubernetes-basic-1/workload.png&quot; alt=&quot;쿠버네티스 배포 방식&quot; /&gt;&lt;/p&gt;

&lt;p&gt;컨테이너와 관련된 많은 예제가 웹(프론트엔드+백엔드) 애플리케이션을 다루고 있지만, 실제 세상엔 더 다양한 형태의 애플리케이션이 있습니다. 쿠버네티스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Deployment&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StatefulSets&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DaemonSet&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Job&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CronJob&lt;/code&gt;등 다양한 배포 방식을 지원합니다. Deployment는 새로운 버전의 애플리케이션을 다양한 전략으로 무중단 배포할 수 있습니다. StatefulSets은 실행 순서를 보장하고 호스트 이름과 볼륨을 일정하게 사용할 수 있어 순서나 데이터가 중요한 경우에 사용할 수 있습니다. 로그나 모니터링 등 모든 노드에 설치가 필요한 경우엔 DaemonSet을 이용하고 배치성 작업은 Job이나 CronJob을 이용하면 됩니다. &lt;del&gt;무슨 기능을 원하는지 몰라서 다 준비해놨어&lt;/del&gt;&lt;/p&gt;

&lt;h3 id=&quot;ingress-설정&quot;&gt;Ingress 설정&lt;/h3&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;/assets/article_images/2019-05-19-kubernetes-basic-1/ingress.png&quot; alt=&quot;Ingress&quot; style=&quot;width: 550px&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;다양한 웹 애플리케이션을 하나의 로드 밸런서로 서비스하기 위해 Ingress&lt;del&gt;입장&lt;/del&gt;기능을 제공합니다. 웹 애플리케이션을 배포하는 과정을 보면 외부에서 직접 접근할 수 없도록 애플리케이션을 내부망에 설치하고 외부에서 접근이 가능한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ALB&lt;/code&gt;나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nginx&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Apache&lt;/code&gt;를 프록시 서버로 활용합니다. 프록시 서버는 도메인과 Path 조건에 따라 등록된 서버로 요청을 전달하는데 서버가 바뀌거나 IP가 변경되면 매번 설정을 수정해줘야 합니다. 쿠버네티스의 Ingress는 이를 자동화하면서 기존 프록시 서버에서 사용하는 설정을 거의 그대로 사용할 수 있습니다. 새로운 도메인을 추가하거나 업로드 용량을 제한하기 위해 일일이 프록시 서버에 접속하여 설정할 필요가 없습니다.&lt;/p&gt;

&lt;p&gt;하나의 클러스터에 여러 개의 Ingress 설정을 할 수 있어 관리자 접속용 Ingress와 일반 접속용 Ingress를 따로 관리할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;클라우드-지원&quot;&gt;클라우드 지원&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2019-05-19-kubernetes-basic-1/cloud-company.png&quot; alt=&quot;Cloud&quot; /&gt;&lt;/p&gt;

&lt;p&gt;쿠버네티스는 부하에 따라 자동으로 서버를 늘리는 기능&lt;sub&gt;AutoScaling&lt;/sub&gt;이 있고 IP를 할당받아 로드밸런스&lt;sub&gt;LoadBalancer&lt;/sub&gt;로 사용할 수 있습니다. 외부 스토리지를 컨테이너 내부 디렉토리에 마운트하여 사용하는 것도 일반적인데 이를 위해 클라우드 별로 적절한 API를 사용하는 모듈이 필요합니다. 쿠버네티스는 Cloud Controller를 이용하여 클라우드 연동을 손쉽게 확장할 수 있습니다. AWS, 구글 클라우드, 마이크로소프트 애저는 물론 수십 개의 클라우드 업체에서 모듈을 제공하여 관리자는 동일한 설정 파일을 서로 다른 클라우드에서 동일하게 사용할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;namespace--label&quot;&gt;Namespace &amp;amp; Label&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2019-05-19-kubernetes-basic-1/namespace-label.png&quot; alt=&quot;Namespace &amp;amp; Label&quot; /&gt;&lt;/p&gt;

&lt;p&gt;하나의 클러스터를 논리적으로 구분하여 사용할 수 있습니다. 하나의 클러스터에 다양한 프레임워크와 애플리케이션을 설치하기 때문에 기본(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;system&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default&lt;/code&gt;)외에 여러 개의 네임스페이스를 사용하는 것이 일반적입니다. 더 세부적인 설정으로 라벨 기능을 적극적으로 사용하여 유연하면서 확장성 있게 리소스를 관리할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;rbac-role-based-access-control&quot;&gt;RBAC (role-based access control)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2019-05-19-kubernetes-basic-1/rbac.png&quot; alt=&quot;Role based access control&quot; /&gt;&lt;/p&gt;

&lt;p&gt;접근 권한 시스템입니다. 각각의 리소스에 대해 유저별로 CRUD스런 권한을 손쉽게 지정할 수 있습니다. 클러스터 전체에 적용하거나 특정 네임스페이스에 적용할 수 있습니다. AWS의 경우 IAM을 &lt;a href=&quot;https://docs.aws.amazon.com/eks/latest/userguide/add-user-role.html&quot;&gt;연동&lt;/a&gt;해서 사용할 수도 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;crd-custom-resource-definitaion&quot;&gt;CRD (Custom Resource Definitaion)&lt;/h3&gt;

&lt;p&gt;쿠버네티스가 제공하지 않는 기능을 기본 기능과 동일한 방식으로 적용하고 사용할 수 있습니다. 예를 들어, 쿠버네티스는 기본적으로 SSL 인증서 관리 기능을 제공하지 않지만, &lt;a href=&quot;https://github.com/jetstack/cert-manager&quot;&gt;cert-manager&lt;/a&gt;를 설치하고 Certificate 리소스를 이용하면 익숙한 쿠버네티스 명령어로 인증서를 관리할 수 있습니다. 또 다른 도구, 방식을 익힐 필요 없이 다양한 기능을 손쉽게 확장할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;auto-scaling&quot;&gt;Auto Scaling&lt;/h3&gt;

&lt;p&gt;CPU, memory 사용량에 따른 확장은 기본이고 현재 접속자 수와 같은 값을 사용할 수도 있습니다. 컨테이너의 개수를 조정하는 Horizontal Pod Autoscaler(HPA), 컨테이너의 리소스 할당량을 조정하는 Vertical Pod Autoscaler(VPA), 서버 개수를 조정하는 Cluster Autosclaer(CA) 방식이 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;federation-multi-cluster&quot;&gt;Federation, Multi Cluster&lt;/h3&gt;

&lt;p&gt;클라우드에 설치한 쿠버네티스 클러스터와 자체 서버에 설치한 쿠버네티스를 묶어서 하나로 사용할 수 있습니다. 구글에서 발표한 Anthos를 이용하면 한 곳에서 여러 클라우드의 여러 클러스터를 관리할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;

&lt;p&gt;쿠버네티스는 확실히 복잡하고 초반에 개념을 이해하기 어렵습니다. YAML 설정 파일은 너무 많고 클러스터를 만드는 것도 쉽지 않습니다. 하지만 여러 클라우드에서 관리형 서비스를 제공하고 &lt;del&gt;클릭 몇번으로 만들자&lt;/del&gt; &lt;a href=&quot;https://cloud.google.com/code&quot;&gt;Cloud Code&lt;/a&gt; 같은 플러그인을 이용하거나 helm 같은 패키지 매니저를 사용하면 비교적 편리하게 설정파일을 관리할 수 있습니다. 쿠버네티스가 어려운건.. 이 글에서 최대한 쉽게 설명해 보도록 하겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;쿠버네티스-기본-개념&quot;&gt;쿠버네티스 기본 개념&lt;/h2&gt;

&lt;p&gt;쿠버네티스가 어떻게 동작하는지, 설치는 왜 이리 어려운지, 설정 파일은 왜 그렇게 복잡한지 이해하기 위해 쿠버네티스의 디자인과 구성 요소, 각각의 동작 방식을 알아보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;desired-state&quot;&gt;Desired State&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2019-05-19-kubernetes-basic-1/desired-state.png&quot; alt=&quot;Desired state&quot; /&gt;&lt;/p&gt;

&lt;p&gt;쿠버네티스에서 가장 중요한 것은 &lt;strong&gt;desired state - 원하는 상태&lt;/strong&gt; 라는 개념입니다. 원하는 상태라 함은 관리자가 바라는 환경을 의미하고 좀 더 구체적으로는 얼마나 많은 웹서버가 떠 있으면 좋은지, 몇 번 포트로 서비스하기를 원하는지 등을 말합니다.&lt;/p&gt;

&lt;p&gt;쿠버네티스는 복잡하고 다양한 작업을 하지만 자세히 들여다보면 &lt;strong&gt;현재 상태&lt;sub&gt;current state&lt;/sub&gt;&lt;/strong&gt;를 모니터링하면서 관리자가 설정한 &lt;strong&gt;원하는 상태&lt;/strong&gt;를 유지하려고 내부적으로 이런저런 작업을 하는 단순한(?) 로직을 가지고 있습니다.&lt;/p&gt;

&lt;p&gt;이러한 개념 때문에 관리자가 서버를 배포할 때 직접적인 동작을 명령하지 않고 상태를 선언하는 방식을 사용합니다. 예를 들어 “nginx 컨테이너를 실행해줘. 그리고 80 포트로 오픈해줘.”는 현재 상태를 원하는 상태로 바꾸기 위한 &lt;strong&gt;명령&lt;sub&gt;imperative&lt;/sub&gt;&lt;/strong&gt;이고 “80 포트를 오픈한 nginx 컨테이너를 1개 유지해줘”는 원하는 상태를 &lt;strong&gt;선언&lt;sub&gt;declarative&lt;/sub&gt;&lt;/strong&gt; 한 것입니다. &lt;del&gt;더 이해가 안 된다&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;언뜻 똑같은 요청을 단어를 살짝 바꿔 말장난하는 게 아닌가 싶은데, 이런 차이는 CLI 명령어에서도 드러납니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;c&quot;&gt;# 명령&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl create &lt;span class=&quot;c&quot;&gt;# 상태 생성 (물론 kubectl run 명령어도 있지만 잘 사용하지 않습니다)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;쿠버네티스의 핵심은 상태이며 쿠버네티스를 사용하려면 어떤 상태가 있고 어떻게 상태를 선언하는지를 알아야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;kubernetes-object&quot;&gt;Kubernetes Object&lt;/h3&gt;

&lt;p&gt;쿠버네티스는 상태를 관리하기 위한 대상을 오브젝트로 정의합니다. 기본으로 수십 가지 오브젝트를 제공하고 새로운 오브젝트를 추가하기가 매우 쉽기 때문에 확장성이 좋습니다. 여러 오브젝트 중 주요 오브젝트는 다음과 같습니다.&lt;/p&gt;

&lt;h4 id=&quot;pod&quot;&gt;Pod&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;/assets/article_images/2019-05-19-kubernetes-basic-1/pod.png&quot; alt=&quot;Pod&quot; style=&quot;width: 350px&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;쿠버네티스에서 배포할 수 있는 가장 작은 단위로 한 개 이상의 컨테이너와 스토리지, 네트워크 속성을 가집니다. Pod에 속한 컨테이너는 스토리지와 네트워크를 공유하고 서로 localhost로 접근할 수 있습니다. 컨테이너를 하나만 사용하는 경우도 반드시 Pod으로 감싸서 관리합니다.&lt;/p&gt;

&lt;h4 id=&quot;replicaset&quot;&gt;ReplicaSet&lt;/h4&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;/assets/article_images/2019-05-19-kubernetes-basic-1/replicaset.png&quot; alt=&quot;ReplicaSet&quot; style=&quot;width: 350px&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Pod을 여러 개(한 개 이상) 복제하여 관리하는 오브젝트입니다. Pod을 생성하고 개수를 유지하려면 반드시 ReplicaSet을 사용해야 합니다. ReplicaSet은 복제할 개수, 개수를 체크할 라벨 선택자, 생성할 Pod의 설정값(템플릿)등을 가지고 있습니다. 직접적으로 ReplicaSet을 사용하기보다는 Deployment등 다른 오브젝트에 의해서 사용되는 경우가 많습니다.&lt;/p&gt;

&lt;h4 id=&quot;service&quot;&gt;Service&lt;/h4&gt;

&lt;p&gt;네트워크와 관련된 오브젝트입니다. Pod을 외부 네트워크와 연결해주고 여러 개의 Pod을 바라보는 내부 로드 밸런서를 생성할 때 사용합니다. 내부 DNS에 서비스 이름을 도메인으로 등록하기 때문에 서비스 디스커버리 역할도 합니다.&lt;/p&gt;

&lt;h4 id=&quot;volume&quot;&gt;Volume&lt;/h4&gt;

&lt;p&gt;저장소와 관련된 오브젝트입니다. 호스트 디렉토리를 그대로 사용할 수도 있고 EBS 같은 스토리지를 동적으로 생성하여 사용할 수도 있습니다. 사실상 인기 있는 대부분의 저장 방식을 &lt;a href=&quot;https://kubernetes.io/docs/concepts/storage/#types-of-volumes&quot;&gt;지원&lt;/a&gt;합니다.&lt;/p&gt;

&lt;h3 id=&quot;object-spec---yaml&quot;&gt;Object Spec - YAML&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Pod&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;example&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;busybox&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;busybox:1.25&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;오브젝트의 명세&lt;sub&gt;Spec&lt;/sub&gt;는 YAML 파일(JSON도 가능하다고 하지만 잘 안 씀)로 정의하고 여기에 오브젝트의 종류와 원하는 상태를 입력합니다. 이러한 명세는 생성, 조회, 삭제로 관리할 수 있기 때문에 REST API로 쉽게 노출할 수 있습니다. 접근 권한 설정도 같은 개념을 적용하여 누가 어떤 오브젝트에 어떤 요청을 할 수 있는지 정의할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;쿠버네티스-배포방식&quot;&gt;쿠버네티스 배포방식&lt;/h3&gt;

&lt;p&gt;쿠버네티스는 애플리케이션을 배포하기 위해 원하는 상태(desired state)를 다양한 오브젝트(object)에 라벨&lt;sub&gt;Label&lt;/sub&gt;을 붙여 정의(yaml)하고 API 서버에 전달하는 방식을 사용합니다.&lt;/p&gt;

&lt;p&gt;“컨테이너를 2개 배포하고 80 포트로 오픈해줘”라는 간단한 작업을 위해 다음과 같은 구체적인 명령을 전달해야 합니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;“컨테이너를 Pod으로 감싸고 type=app, app=web이라는 라벨을 달아줘. type=app, app=web이라는 라벨이 달린 Pod이 2개 있는지 체크하고 없으면 Deployment Spec에 정의된 템플릿을 참고해서 Pod을 생성해줘. 그리고 해당 라벨을 가진 Pod을 바라보는 가상의 서비스 IP를 만들고 외부의 80 포트를 방금 만든 서비스 IP랑 연결해줘.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;음.. “정말 뭐 하나 배포할 때마다 저렇게 복잡하게 설정한다고?”라는 의구심이 들 수 있지만 이건 모두 사실입니다. &lt;del&gt;&lt;a href=&quot;https://www.google.co.kr/search?hl=en-kr&amp;amp;q=%EB%AF%B8%EC%B9%9C+%EC%96%98%EA%B8%B0+%EA%B0%99%EC%A7%80%EB%A7%8C+%EC%A0%84%EB%B6%80+%EC%82%AC%EC%8B%A4%EC%9D%B4%EC%97%90%EC%9A%94&amp;amp;oq=%EB%AF%B8%EC%B9%9C+%EC%96%98%EA%B8%B0+%EA%B0%99%EC%A7%80%EB%A7%8C+%EC%A0%84%EB%B6%80+%EC%82%AC%EC%8B%A4%EC%9D%B4%EC%97%90%EC%9A%94&quot;&gt;미친 얘기 같지만 전부 사실이에요.&lt;/a&gt;&lt;/del&gt; Cloud code, Helm, Knative를 사용하면 조금 편해지긴 하지만 기본적으로 너무 복잡하고 러닝 커브가 높은 편입니다.&lt;/p&gt;

&lt;p&gt;어쩌다 이렇게 되었을까.. 관리가 쉬워지면서 일자리가 없어지는 걸 걱정한 서버 관리자의 고도의 전략인가 잘 짜인 설계 문제인가. 쿠버네티스의 개념을 어떻게 구현했는지 구체적인 아키텍처를 살펴보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;쿠버네티스-아키텍처&quot;&gt;쿠버네티스 아키텍처&lt;/h2&gt;

&lt;p&gt;컨테이너는 아주 심플하고 우아하게 동작합니다. run을 하면 실행되고 stop을 하면 멈춥니다. 서버-클라이언트 구조를 안다면 컨테이너를 관리하는 에이전트를 만들고 중앙에서 API를 이용하여 원격으로 관리하는 모습을 쉽게 그려볼 수 있습니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;/assets/article_images/2019-05-19-kubernetes-basic-1/server-agent.png&quot; alt=&quot;Server - Agent&quot; style=&quot;width: 350px&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;쿠버네티스 또한 중앙(Master)에 API 서버와 상태 저장소를 두고 각 서버(Node)의 에이전트(kubelet)와 통신하는 단순한 구조입니다. 하지만, 앞에서 얘기한 개념을 여러 모듈로 쪼개어 구현하고 다양한 오픈소스를 사용하기 때문에 설치가 까다롭고 언뜻 구성이 복잡해 보입니다.&lt;/p&gt;

&lt;h3 id=&quot;마스터---노드-구조&quot;&gt;마스터 - 노드 구조&lt;/h3&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;/assets/article_images/2019-05-19-kubernetes-basic-1/master-node.png&quot; alt=&quot;Master - Node&quot; style=&quot;width: 600px&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;쿠버네티스는 전체 클러스터를 관리하는 &lt;strong&gt;마스터&lt;/strong&gt;와 컨테이너가 배포되는 &lt;strong&gt;노드&lt;/strong&gt;로 구성되어 있습니다. 모든 명령은 마스터의 API 서버를 호출하고 노드는 마스터와 통신하면서 필요한 작업을 수행합니다. 특정 노드의 컨테이너에 명령하거나 로그를 조회할 때도 노드에 직접 명령하는 게 아니라 마스터에 명령을 내리고 마스터가 노드에 접속하여 대신 결과를 응답합니다.&lt;/p&gt;

&lt;h4 id=&quot;master&quot;&gt;Master&lt;/h4&gt;

&lt;p&gt;마스터 서버는 다양한 모듈이 확장성을 고려하여 기능별로 쪼개져 있는 것이 특징 &lt;del&gt;고통&lt;/del&gt; 입니다. 관리자만 접속할 수 있도록 보안 설정을 해야 하고 마스터 서버가 죽으면 클러스터를 관리할 수 없기 때문에 보통 3대를 구성하여 안정성을 높입니다. AWS EKS 같은 경우 마스터를 AWS에서 자체 관리하여 안정성을 높였고(마스터에 접속 불가) 개발 환경이나 소규모 환경에선 마스터와 노드를 분리하지 않고 같은 서버에 구성하기도 합니다.&lt;/p&gt;

&lt;h4 id=&quot;node&quot;&gt;Node&lt;/h4&gt;

&lt;p&gt;노드 서버는 마스터 서버와 통신하면서 필요한 Pod을 생성하고 네트워크와 볼륨을 설정합니다. 실제 컨테이너들이 생성되는 곳으로 수백, 수천대로 확장할 수 있습니다. 각각의 서버에 라벨을 붙여 사용목적(GPU 특화, SSD 서버 등)을 정의할 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;kubectl&quot;&gt;Kubectl&lt;/h4&gt;

&lt;p&gt;API 서버는 json 또는 protobuf 형식을 이용한 http 통신을 지원합니다. 이 방식을 그대로 쓰면 불편하므로 보통 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl&lt;/code&gt;이라는 명령행 도구를 사용합니다. 앞으로 엄청나게 많이 &lt;del&gt;지겹게&lt;/del&gt; 사용할 예정입니다.
어떻게 읽어야 할지 난감한데 &lt;a href=&quot;https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.9.md#kubectl&quot;&gt;공식적&lt;/a&gt;으로 큐브컨트롤(cube control)이라고 읽지만 큐브씨티엘, 쿱컨트롤, 쿱씨티엘등도 많이 쓰입니다.&lt;/p&gt;

&lt;h3 id=&quot;master-구성-요소&quot;&gt;Master 구성 요소&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2019-05-19-kubernetes-basic-1/kubernetes-master.png&quot; alt=&quot;Master Component&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;api-서버-kube-apiserver&quot;&gt;API 서버 kube-apiserver&lt;/h4&gt;

&lt;p&gt;API 서버는 모오오든 요청을 처리하는 마스터의 핵심 모듈입니다. kubectl의 요청뿐 아니라 내부 모듈의 요청도 처리하며 권한을 체크하여 요청을 거부할 수 있습니다. 실제로 하는 일은 원하는 상태를 key-value 저장소에 저장하고 저장된 상태를 조회하는 매우 단순한 작업입니다. Pod을 노드에 할당하고 상태를 체크하는 일은 다른 모듈로 분리되어 있습니다. 노드에서 실행 중인 컨테이너의 로그를 보여주고 명령을 보내는 등 디버거 역할도 수행합니다.&lt;/p&gt;

&lt;h4 id=&quot;분산-데이터-저장소-etcd&quot;&gt;분산 데이터 저장소 etcd&lt;/h4&gt;

&lt;p&gt;RAFT 알고리즘을 이용한 key-value 저장소입니다. 여러 개로 분산하여 복제할 수 있기 때문에 안정성이 높고 속도도 빠른 편입니다. 단순히 값을 저장하고 읽는 기능뿐 아니라 watch 기능이 있어 어떤 상태가 변경되면 바로 체크하여 로직을 실행할 수 있습니다.&lt;/p&gt;

&lt;p&gt;클러스터의 모든 설정, 상태 데이터는 여기 저장되고 나머지 모듈은 stateless하게 동작하기 때문에 etcd만 잘 백업해두면 언제든지 클러스터를 복구할 수 있습니다. etcd는 오직 API 서버와 통신하고 다른 모듈은 API 서버를 거쳐 etcd 데이터에 접근합니다. &lt;a href=&quot;https://k3s.io/&quot;&gt;k3s&lt;/a&gt; 같은 초경량 쿠버네티스 배포판에서는 etcd대신 sqlite를 사용하기도 합니다.&lt;/p&gt;

&lt;h4 id=&quot;스케줄러-컨트롤러&quot;&gt;스케줄러, 컨트롤러&lt;/h4&gt;

&lt;p&gt;API 서버는 요청을 받으면 etcd 저장소와 통신할 뿐 실제로 상태를 바꾸는 건 스케줄러와 컨트롤러 입니다. 현재 상태를 모니터링하다가 원하는 상태와 다르면 각자 맡은 작업을 수행하고 상태를 갱신합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;스케줄러&lt;/strong&gt; kube-scheduler&lt;/p&gt;

&lt;p&gt;스케줄러는 할당되지 않은 Pod을 여러 가지 조건(필요한 자원, 라벨)에 따라 적절한 노드 서버에 할당해주는 모듈입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;큐브 컨트롤러&lt;/strong&gt; kube-controller-manager&lt;/p&gt;

&lt;p&gt;큐브 컨트롤러는 다양한 역할을 하는 아주 바쁜 모듈입니다. 쿠버네티스에 있는 거의 모든 오브젝트의 상태를 관리합니다. 오브젝트별로 철저하게 분업화되어 Deployment는 ReplicaSet을 생성하고 ReplicaSet은 Pod을 생성하고 Pod은 스케줄러가 관리하는 식입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;클라우드 컨트롤러&lt;/strong&gt; cloud-controller-manager&lt;/p&gt;

&lt;p&gt;클라우드 컨트롤러는 AWS, GCE, Azure 등 클라우드에 특화된 모듈입니다. 노드를 추가/삭제하고 로드 밸런서를 연결하거나 볼륨을 붙일 수 있습니다. 각 클라우드 업체에서 인터페이스에 맞춰 구현하면 되기 때문에 확장성이 좋고 많은 곳에서 자체 모듈을 만들어 제공하고 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;node-구성-요소&quot;&gt;Node 구성 요소&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2019-05-19-kubernetes-basic-1/kubernetes-node.png&quot; alt=&quot;Node Component&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;큐블릿-kubelet&quot;&gt;큐블릿 kubelet&lt;/h4&gt;

&lt;p&gt;노드에 할당된 Pod의 생명주기를 관리합니다. Pod을 생성하고 Pod 안의 컨테이너에 이상이 없는지 확인하면서 주기적으로 마스터에 상태를 전달합니다. API 서버의 요청을 받아 컨테이너의 로그를 전달하거나 특정 명령을 대신 수행하기도 합니다.&lt;/p&gt;

&lt;h4 id=&quot;프록시-kube-proxy&quot;&gt;프록시 kube-proxy&lt;/h4&gt;

&lt;p&gt;큐블릿이 Pod을 관리한다면 프록시는 Pod으로 연결되는 네트워크를 관리합니다. TCP, UDP, SCTP 스트림을 포워딩하고 여러 개의 Pod을 라운드로빈 형태로 묶어 서비스를 제공할 수 있습니다. 초기에는 kube-proxy 자체가 프록시 서버로 동작하면서 실제 요청을 프록시 서버가 받고 각 Pod에 전달해 주었는데 시간이 지나면서 iptables를 설정하는 방식으로 변경되었습니다. iptables에 등록된 규칙이 많아지면 느려지는 문제 때문에 최근 IPVS를 지원하기 시작했습니다.&lt;/p&gt;

&lt;h3 id=&quot;추상화&quot;&gt;추상화&lt;/h3&gt;

&lt;p&gt;컨테이너는 도커고 도커가 컨테이너라고 생각해도 무리가 없는 상황이지만 쿠버네티스는 CRI(Container runtime interface)를 구현한 다양한 컨테이너 런타임을 지원합니다. &lt;a href=&quot;https://containerd.io/&quot;&gt;containerd&lt;/a&gt;(사실상 도커..), &lt;a href=&quot;https://coreos.com/rkt/&quot;&gt;rkt&lt;/a&gt;, &lt;a href=&quot;https://cri-o.io/&quot;&gt;CRI-O&lt;/a&gt; 등이 있습니다.&lt;/p&gt;

&lt;p&gt;CRI 외에 CNI(네트워크), CSI(스토리지)를 지원하여 인터페이스만 구현한다면 쉽게 확장하여 사용할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;하나의-pod이-생성되는-과정&quot;&gt;하나의 Pod이 생성되는 과정&lt;/h2&gt;

&lt;p&gt;위에서 이야기한 조각을 하나하나 모아서 전체적인 흐름을 살펴보겠습니다. 관리자가 애플리케이션을 배포하기 위해 ReplicaSet을 생성하면 다음과 같은 과정을 거쳐 Pod을 생성합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2019-05-19-kubernetes-basic-1/create-replicaset.png&quot; alt=&quot;ReplicaSet 만들기&quot; /&gt;&lt;/p&gt;

&lt;p&gt;흐름을 보면 각 모듈은 서로 통신하지 않고 오직 API Server와 통신하는 것을 알 수 있습니다. API Server를 통해 etcd에 저장된 상태를 체크하고 현재 상태와 원하는 상태가 다르면 필요한 작업을 수행합니다. 각 모듈이 하는 일을 보면 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;kubectl&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;i class=&quot;nf nf-fa-play_circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; ReplicaSet 명세를 yml파일로 정의하고 kubectl 도구를 이용하여 API Server에 명령을 전달&lt;/li&gt;
  &lt;li&gt;&lt;i class=&quot;nf nf-fa-play_circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; API Server는 새로운 ReplicaSet Object를 etcd에 저장&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Kube Controller&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;i class=&quot;nf nf-fa-refresh&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; Kube Controller에 포함된 ReplicaSet Controller가 ReplicaSet을 감시하다가 ReplicaSet에 정의된 Label Selector 조건을 만족하는 Pod이 존재하는지 체크&lt;/li&gt;
  &lt;li&gt;&lt;i class=&quot;nf nf-fa-play_circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; 해당하는 Label의 Pod이 없으면 ReplicaSet의 Pod 템플릿을 보고 새로운 Pod(no assign)을 생성. 생성은 역시 API Server에 전달하고 API Server는 etcd에 저장&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Scheduler&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;i class=&quot;nf nf-fa-refresh&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; Scheduler는 할당되지 않은(no assign) Pod이 있는지 체크&lt;/li&gt;
  &lt;li&gt;&lt;i class=&quot;nf nf-fa-play_circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; 할당되지 않은 Pod이 있으면 조건에 맞는 Node를 찾아 해당 Pod을 할당&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Kubelet&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;i class=&quot;nf nf-fa-refresh&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; Kubelet은 자신의 Node에 할당되었지만 아직 생성되지 않은 Pod이 있는지 체크&lt;/li&gt;
  &lt;li&gt;&lt;i class=&quot;nf nf-fa-play_circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; 생성되지 않은 Pod이 있으면 명세를 보고 Pod을 생성&lt;/li&gt;
  &lt;li&gt;&lt;i class=&quot;nf nf-fa-play_circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; Pod의 상태를 주기적으로 API Server에 전달&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이제 복잡했던 그림이 이해되시나요? 위의 예제는 ReplicaSet에 대해 다뤘지만 모든 노드에 Pod을 배포하는 DaemonSet도 동일한 방식으로 동작합니다. DaemonSet controller와 Scheduler가 전체 노드에 대해 Pod을 할당하면 kubelet이 자기 노드에 할당된 Pod을 생성하는 식입니다.&lt;/p&gt;

&lt;p&gt;각각의 모듈이 각자 담당한 상태를 체크하고 독립적으로 동작하는 것을 보면서 참 잘 만든 마이크로서비스 구조라는 생각이 듭니다.&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;p&gt;이번 글에서 쿠버네티스의 특징과 기본 개념, 개념을 구현한 아키텍처에 대해 알아보았습니다. 쿠버네티스는 아키텍처와 설치가 반, 설정 파일 작성이 나머지 반입니다. 그러니까 벌써 1/4 정도 했네요. 조금 &lt;del&gt;많이&lt;/del&gt; 복잡한 것이 사실이지만 예전에 어떤 걸 배울지 선택조차 어렵고 배워도 금방 옛날 지식이 되는 것보단 상황이 낫습니다. 이제 쿠버네티스만 배우면 되니까요.&lt;/p&gt;

&lt;p&gt;쿠버네티스와 관련된 생태계는 빠르게 변하고 발전하고 있습니다. Cloud controller는 원래 Kube controller에 포함되어 있었는데 최근 분리되었고 Node의 모니터링을 위해 cAdvisor라는 것을 기본으로 사용했지만 선택 가능하게 제거되었습니다. 사용법이 바뀌고 계속해서 새로운 기능이 추가되지만 기본 적인 구성과 핵심 아키텍처는 크게 바뀌지 않습니다. 기본 적인 동작 원리를 이해하고 있다면 새로운 버전이 나오고 새로운 프레임워크가 등장해도 쉽게 이해하고 확장하여 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이제 기본적인 구조를 살펴보았으니 클러스터를 설치하고 사용해봅시다!&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;실습은 👇 하단 링크를 클릭해 주세요!&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;a href=&quot;https://subicura.com/k8s/&quot; target=&quot;_blank&quot;&gt;
        &lt;img src=&quot;/assets/article_images/2020-12-14-kubernetes-basic-2/subicura-k8s.png&quot; alt=&quot;초보를 위한 쿠버네티스 안내서&quot; style=&quot;width: 350px&quot; /&gt;
    &lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;그리고 실습 영상과 함께 자세한 설명을 들을 수 있는 &lt;a href=&quot;https://bit.ly/inflearn-k8s-link&quot;&gt;온라인 강의&lt;/a&gt;도 준비되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://bit.ly/inflearn-k8s-link&quot;&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2020-12-14-kubernetes-basic-2/inflearn-k8s.png&quot; alt=&quot;초보를 위한 쿠버네티스 안내서 - 인프런&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 19 May 2019 00:00:00 +0900</pubDate>
        <link>https://subicura.com/2019/05/19/kubernetes-basic-1.html</link>
        <guid isPermaLink="true">https://subicura.com/2019/05/19/kubernetes-basic-1.html</guid>
        
        <category>Kubernetes</category>
        
        <category>Docker</category>
        
        <category>DevOps</category>
        
        <category>Server</category>
        
        
        <category>Kubernetes</category>
        
      </item>
    
      <item>
        <title>크롬 개발자 도구를 이용한 자바스크립트 디버깅</title>
        <description>&lt;p&gt;자바스크립트 디버깅 어떻게 하시나요? 과거의 저를 포함하여 많은 웹 프론트엔드 개발자들이 소스 사이사이에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alert()&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;console.log()&lt;/code&gt;를 사용하여 상태를 출력하고 변수를 모니터링 합니다. 이러한 &lt;del&gt;노가다식&lt;/del&gt; 디버깅 방식이 널리 퍼진 이유는 자바스크립트의 역사와 관련이 있는데 IE&lt;sup&gt;Internet Explorer&lt;/sup&gt;가 인기 있던 시절 IE는 제대로 된 디버그 도구를 제공하지 않았고 로그도 출력할 수 없었기 때문에 어쩔 수 없이 경고창을 사용했습니다. HTML에 스크립트 코드를 입력하는 인라인 방식이 널리 쓰였고 모듈화는 자바스크립트랑 거리가 먼 이야기였습니다.&lt;/p&gt;

&lt;p&gt;척박한 개발환경에서 등장한 Firefox의  &lt;a href=&quot;https://getfirebug.com/&quot;&gt;Firebug&lt;/a&gt; 플러그인은 엄청나게 인기를 끌었고 후에 등장하는 브라우저의 개발자 도구에 많은 영향을 끼쳤습니다. 최근에는 크롬, 파이어폭스, 사파리, IE 등 대부분 브라우저에서 강력한 개발자 도구를 기본으로 제공하고 있습니다.&lt;/p&gt;

&lt;p&gt;웹 브라우저에 내장된 개발자 도구는 웹이라는 특성에 맞게 로그나 라인 중단점&lt;sup&gt;Breakpoint&lt;/sup&gt;을 이용한 디버깅뿐 아니라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;click&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;submit&lt;/code&gt; 이벤트를 체크 할 수 있고 특정 DOM 객체의 class가 변경되는지 감시하다가 변경되는 순간 변경을 유발한 소스에 자동으로 중단점을 걸 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/code_chrome_devtools.gif&quot; alt=&quot;Visual Studio Code + Chrome Devtools 조합&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 글에선 디버깅이란 무엇인지 간단하게 살펴보고 크롬 개발자 도구의 실용적이고 강력한 기능을 3가지 예제와 함께 소개합니다. 그리고 Visual Studio Code(VSCode)와 크롬 브라우저를 연동하는 방법도 알아보겠습니다.&lt;/p&gt;

&lt;div align=&quot;center&quot; class=&quot;googleads googleads-content&quot;&gt;
                &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-2468713653725581&quot; data-ad-slot=&quot;8649023787&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
            &lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;디버깅이란&quot;&gt;디버깅이란&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/google-debug-doodle.gif&quot; alt=&quot;Grace Hopper's 107th Birthday - 나방(버그) 디테일에 주목&quot; /&gt;&lt;/p&gt;

&lt;p&gt;버그란 프로그램 내의 결함이나 문제점을 이야기하는 것으로 프로그래밍 언어 COBOL의 개발을 주도한 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EA%B7%B8%EB%A0%88%EC%9D%B4%EC%8A%A4_%ED%98%B8%ED%8D%BC&quot;&gt;그레이스 호퍼&lt;/a&gt;가 1945년 Mark II의 오작동 원인을 찾다가 컴퓨터에 나방이 껴있는 걸 발견한 것을 최초의 버그라고 기록하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/bug.png&quot; alt=&quot;역사적인 버그 발견 기록&quot; /&gt;&lt;/p&gt;

&lt;p&gt;버그를 해결하는 것을 디버깅&lt;sup&gt;debugging&lt;/sup&gt;이라고 하고 주요 전략으로 인터렉티브 디버깅, 컨트롤 분석, 유닛 테스트, 통합 테스트, 로그 파일 분석, 모니터링, 메모리 덤프, 프로파일링등이 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Debugging tactics can involve interactive debugging, control flow analysis, unit testing, integration testing, log file analysis, monitoring at the application or system level, memory dumps, and profiling.&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;from wikipedia&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;여기선 인터렉티브 디버깅 전략에 대해 알아봅니다.&lt;/p&gt;

&lt;p&gt;디버깅을 하기 위해서는 도구가 필요한데 특정 기기/프로그램의 경우 특별한 하드웨어가 필요한 때도 있지만, 웹 어플리케이션은 크롬 개발자 도구와 같이 브라우저에 내장된 무료 소프트웨어를 사용하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/Xbox-Debug-Console-Set.jpg&quot; alt=&quot;Xbox Debug Kit&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;크롬-개발자-도구-devtools&quot;&gt;크롬 개발자 도구 (DevTools)&lt;/h2&gt;

&lt;p&gt;크롬 개발자 도구는 크롬 브라우저에 내장된 개발 관련 도구입니다. 웹 어플리케이션을 개발하고 수정/최적화하는데 필요한 다양한 기능을 제공합니다. 자바스크립트 디버깅뿐 아니라 모바일 기기 시뮬레이터, 네트워크 분석, 최적화에 대해 검사도 해줍니다. 전체 기능은 &lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/&quot;&gt;공식 홈페이지&lt;/a&gt;에서 확인하세요.&lt;/p&gt;

&lt;h3 id=&quot;개발자-도구-열기&quot;&gt;개발자 도구 열기&lt;/h3&gt;

&lt;p&gt;개발자 도구를 여는 방법은 여러 가지가 있습니다. 단축키를 외우는 걸 추천합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;크롬 브라우저 메뉴에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;More Tools（도구 더보기）&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Developer Tools（개발자 도구）&lt;/code&gt; 선택&lt;/li&gt;
  &lt;li&gt;페이지 빈공간에 오른쪽 버튼 누르고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Inspect(검사)&lt;/code&gt; 선택&lt;/li&gt;
  &lt;li&gt;MacOS - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;⌘&lt;/code&gt;+&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;⌥&lt;/code&gt;+&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;I&lt;/code&gt; 또는 Windows - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctrl&lt;/code&gt;+&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shift&lt;/code&gt;+&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;I&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;MacOS - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;⌘&lt;/code&gt;+&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;⌥&lt;/code&gt;+&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;J&lt;/code&gt; 또는 Windows - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctrl&lt;/code&gt;+&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shift&lt;/code&gt;+&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;J&lt;/code&gt; (Console 패널)&lt;/li&gt;
  &lt;li&gt;MacOS - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;⌘&lt;/code&gt;+&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;⌥&lt;/code&gt;+&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C&lt;/code&gt; 또는 Windows - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctrl&lt;/code&gt;+&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shift&lt;/code&gt;+&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C&lt;/code&gt; (Elements 패널)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;주요-패널-소개&quot;&gt;주요 패널 소개&lt;/h3&gt;

&lt;p&gt;디버깅할 때 자주 사용하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Elements&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sources&lt;/code&gt; 패널을 살펴봅니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Element&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/devtools-elements.png&quot; alt=&quot;Elements&quot; /&gt;&lt;/p&gt;

&lt;p&gt;주로 디자인을 수정하는 용도로 사용하는 패널입니다. DOM을 확인하고 CSS style을 수정합니다. 특정 DOM의 변화에 중단점을 걸 수 있는 기능이 &lt;del&gt;숨겨져&lt;/del&gt; 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Console&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/devtools-console.png&quot; alt=&quot;Console&quot; /&gt;&lt;/p&gt;

&lt;p&gt;로그를 확인하고 스크립트 명령어를 입력하는 패널입니다. 중단점을 건 시점의 변수를 확인할 수 있고 값을 평가하거나 수정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sources&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/devtools-sources-edit.png&quot; alt=&quot;Elements&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자바스크립트 디버깅의 가장 핵심적인 영역입니다. 왼쪽에 파일 관리창과 가운데 소스 에디터, 오른쪽에 디버깅관련 정보창이 있습니다. 창의 크기에 따라 화면 레이아웃이 적절하게 바뀌고 토글 버튼을 누르면 세부창을 열었다 닫았다 할 수 있습니다. 디버깅 정보창 위에 중단점 컨트롤을 이용하여 한땀한땀 코드를 디버깅합니다.&lt;/p&gt;

&lt;h2 id=&quot;본격-자바스크립트-디버깅&quot;&gt;본격 자바스크립트 디버깅&lt;/h2&gt;

&lt;p&gt;예제 소스는 총 3가지 프로젝트(디렉토리)로 구성되어 있고 &lt;a href=&quot;https://github.com/subicura/javascript-debugging-example&quot;&gt;https://github.com/subicura/javascript-debugging-example&lt;/a&gt; 에서 다운로드 할 수 있습니다. &lt;del&gt;좋아요 클릭좀&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js 8.x&lt;/a&gt;를 설치하고 소스를 다운로드 후 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm install&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm start&lt;/code&gt; 명령어를 입력하면 3000번 포트로 웹서버가 실행됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/example-index.png&quot; alt=&quot;예제 화면&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Basic&lt;/strong&gt; 라이브러리를 사용하지 않은 순수 자바스크립트(&lt;a href=&quot;http://vanilla-js.com/&quot;&gt;Vanilla JS&lt;/a&gt;) 사용 예제&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;jQuery&lt;/strong&gt; jQuery 라이브러리 사용 예제&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;React&lt;/strong&gt; React + Redux TODO app 예제&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;basic-example&quot;&gt;Basic Example&lt;/h3&gt;

&lt;p&gt;아무런 라이브러리를 사용하지 않고 순수 자바스크립트로 작성한 매우 간단한 웹 어플리케이션입니다. 버그를 찾고 한땀한땀 디버깅하는 일련의 흐름을 살펴봅니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 버그 찾기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;웹서버를 실행하고 크롬 브라우저로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://localhost:3000/vanilla.html&lt;/code&gt;에 접속한 후 이름과 내용을 입력합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/message-sample.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;내용이 위에 나오고 이름이 밑에 나오는 걸 기대했는데 결과를 보니 이름과 내용이 반대로 출력되었습니다. 이 버그를 수정해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 중단점 걸기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;코드를 실행하는 도중에 일시 정지하고 해당 시점의 변수값을 확인하기 위해 중단점을 걸어보겠습니다. 소스가 익숙하고 어떤 함수가 문제인지 안다면 바로 해당 라인에 중단점을 걸 수 있지만 여기서는 소스가 복잡해서 어디에 중단점을 걸어야 할지 모른다고 가정하고 다른 방식으로 접근해보겠습니다.&lt;/p&gt;

&lt;p&gt;개발자 도구는 특정 라인이 아닌 글로벌한 이벤트에 대해 중단점을 만들 수 있는데 이름과 내용을 입력하고 폼 전송을 하는 순간을 체크하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;submit&lt;/code&gt; 이벤트에 중단점을 생성할 수 있습니다. 이제 submit 관련 이벤트가 발생하면 해당 소스에서 멈출 겁니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/message-submit-breakpoint.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;⌘&lt;/code&gt;+&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;⌥&lt;/code&gt;+&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;I&lt;/code&gt; 또는  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctrl&lt;/code&gt;+&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shift&lt;/code&gt;+&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;I&lt;/code&gt;를 입력해서 개발자 도구를 엽니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sources&lt;/code&gt;탭을 선택합니다.&lt;/li&gt;
  &lt;li&gt;디버깅 정보 창에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Event Listener Breakpoints&lt;/code&gt;섹션을 열고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Control&lt;/code&gt;&amp;gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;submit&lt;/code&gt;을 체크합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이벤트 중단점을 체크했으면 다시 화면으로 돌아와서 이름과 내용을 입력하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Submit&lt;/code&gt; 버튼을 클릭합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/message-submit-debug-edit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vanilla-script.js&lt;/code&gt;파일의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;14line&lt;/code&gt;에 소스가 중단되었습니다. 🙀 어떤 파일의 어떤 함수를 수정해야 할지 몰랐지만, submit 이벤트가 발생한다고 추측하고 접근해서 찾았습니다. &lt;del&gt;만세&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 단계별(step) 코드 실행&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;코드를 한줄 한줄 단계별로 실행하면서 스크립트가 어떻게 실행되는지, 변수가 어떻게 저장되어 있는지 확인해 보겠습니다. 디버깅 정보창 위에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Step over next function call&lt;/code&gt; &lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/step-over.png&quot; width=&quot;20&quot; /&gt;을 클릭하여 한 줄씩 실행합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/message-step-edit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;디버깅 정보창의 Scope 섹션과 소스의 변수명 근처에서 현재 시점의 변수값을 확인할 수 있습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;message&lt;/code&gt;변수는 정상적으로 할당된 것 같으니 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;updatePost&lt;/code&gt; 함수를 살펴봐야겠습니다. updatePost를 호출하는 라인에 디버깅이 멈춰있을 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Step into next function call&lt;/code&gt; &lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/step-into.png&quot; width=&quot;10&quot; /&gt;을 클릭해서 updatePost 함수로 이동합니다.&lt;/p&gt;

&lt;p&gt;updatePost함수를 한 줄씩 실행해보니 postHtml에 이름과 메시지가 반대로 들어간 것을 알 수 있습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;9line&lt;/code&gt;까지 진행합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 콘솔창에서 테스트하기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;콘솔탭을 선택하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;postHtml&lt;/code&gt;을 입력하면 디버깅이 진행 중인 시점의 postHtml 변수값이 출력됩니다. 여기서 변수에 새로운 값을 할당하면 진행 중인 변수의 값이 변하게 됩니다. 원래 있던 값을 복사하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;copy(postHtml)&lt;/code&gt; 명령어를 입력합니다. 마치 텍스트를 드래그하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ctrl(⌘)&lt;/code&gt;+&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c&lt;/code&gt; 한 것처럼 메모리에 내용이 복사됩니다. 다시 내용을 붙여넣고 이름과 내용을 바꿔줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/message-console.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sources&lt;/code&gt;탭으로 돌아와서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Resume script execution&lt;/code&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/resume-script-execution.png&quot; width=&quot;14&quot; /&gt;를 클릭하고 디버깅을 끝까지 실행합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/message-fix.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위에 내용이 나오고 밑에 이름이 나오네요. 이름과 내용이 정상적으로 바뀌어서 출력되었습니다!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. 소스 수정하기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Sources창의 에디터에서 코드를 수정합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;post.name&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;post.message&lt;/code&gt;를 바꿔주면 됩니다. 그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Deactivate breakpoints&lt;/code&gt; &lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/deactivate-breakpoints-button.png&quot; width=&quot;15&quot; /&gt; 버튼을 클릭해서 활성화되어 있는 중단점을 비활성화하고 다시 메시지를 입력해 봅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/message-source-edit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;짜잔!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/message-fix-bug.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;버그를 고쳤습니다. 이제 문제없이 동작하네요! &lt;del&gt;풀리퀘고고&lt;/del&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;방금 살펴본 방식은 수정한 내용을 임시로 저장한다는 점에 유의하세요. 새로 고침을 하면 수정전 소스로 원복됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;크롬 개발자 도구의 워크플레이스&lt;sup&gt;workspace&lt;/sup&gt;기능을 사용하면 수정한 내용을 로컬 소스에 바로 반영할 수 있습니다. 개발자 도구의 에디터도 문법 하이라이팅&lt;sup&gt;Syntax Highlighting&lt;/sup&gt;을 지원하고 자동완성 기능&lt;sup&gt;Auto Completion&lt;/sup&gt;을 제공하지만, 아직 다른 전용 에디터보다는 기능이 부족합니다. 따라서 뒤에 설명할 VSCode와 연동해서 사용하는 걸 추천하지만 간단하게 워크플레이스 기능을 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6. Workspace 사용하기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Workspace는 개발 중인 소스 파일을 개발자 도구에 등록하고 브라우저에서 바라보는 네트워크 상의 파일을 연결하여 수정을 편하게 해주는 기능입니다.&lt;/p&gt;

&lt;p&gt;예를 들면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://localhost:3000/js/vanilla-script.js&lt;/code&gt; 라는 네트워크상의 파일을 로컬의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/Users/subicura/Workspace/js/vanilla-script.js&lt;/code&gt; 와 연결할 수 있습니다.&lt;/p&gt;

&lt;p&gt;Workspace에 폴더를 등록하기 위해 개발자 도구의 Sources탭을 선택합니다. 그리고 왼쪽 파일 네비게이션 창에서 Filesystem 탭을 누르고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+ Add folder to workspace&lt;/code&gt;를 누르거나 소스 폴더를 드래그해서 추가해줍니다. 그러면 접근 권한을 묻는 창이 뜨고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Allow&lt;/code&gt;를 선택해줍니다. 마지막으로 화면을 새로고침하면 맵핑된 파일 아이콘에 연결되었다는 의미의 동그라미가 표시됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/devtools-workspace.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;단지 폴더만 추가했을 뿐인데 개발자 도구가 똘똘하게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vanilla.html&lt;/code&gt; 파일과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vanilla-script.js&lt;/code&gt; 파일을 맵핑 하였습니다. 동일한 파일명이 여러 개 있어 자동으로 맵핑 되지 않으면 Network의 파일에서 오른쪽 버튼을 누르고 따로 맵핑해주면 됩니다. 잘 안된다면 캐시를 비활성화하고 새로고침해 보세요.&lt;/p&gt;

&lt;p&gt;이제 개발자 도구 에디터에서 소스를 수정하면 로컬 개발환경의 소스 파일도 수정됩니다. 새로고침해도 문제없네요!&lt;/p&gt;

&lt;h3 id=&quot;jquery-example&quot;&gt;jQuery Example&lt;/h3&gt;

&lt;p&gt;Basic 예제에서 자바스크립트 디버깅의 가장 기본적인 작업 흐름을 살펴보았습니다. 이번에는 좀더 현실적으로 jQuery라이브러리를 사용한 웹 어플리케이션을 다양한 방법으로 디버깅해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/jquery-example.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;웹서버를 실행하고 크롬 브라우저로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://localhost:3000/jquery.html&lt;/code&gt;에 접속합니다. Github ID를 입력하면 정보를 보여주는 웹 어플리케이션입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Blackboxing&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Basic 예제에서는 라이브러리를 사용하지 않았기 때문에 submit 이벤트를 검사할 때 정상적으로 소스에 중단점이 걸린 것을 확인했습니다. jQuery같은 라이브러리를 쓰면 상황이 좀 달라지는데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$(element).click()&lt;/code&gt;과 같은 코드는 이벤트 생성을 jQuery 라이브러리에 위임하고 실제로  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jquery.js&lt;/code&gt; 파일에서 이벤트가 발생합니다.&lt;/p&gt;

&lt;p&gt;테스트를 위해 Event Listener중에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;click&lt;/code&gt;이벤트에 중단점을 생성합니다. 디버깅 정보 창에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Event Listener Breakpoints&lt;/code&gt;섹션을 열고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mouse&lt;/code&gt;&amp;gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;click&lt;/code&gt;을 체크하면 됩니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fetch Avatar&lt;/code&gt;를 클릭해볼까요?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/jquery-click.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;예상대로(?) jquery 파일에 중단점이 걸렸습니다. minified되어 알아볼 수 없는 코드가 보이고 Scope의 변수 또한 아무 의미가 없어 보입니다. minified된 코드를 좀 더 이쁘게 바꿔보겠습니다. 에디터 왼쪽 하단에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{}&lt;/code&gt; 버튼을 클릭합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/jquery-pretty-code.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;뭔가 한 줄로 복잡했던 소스가 좀 이뻐지긴 했지만.. 큰 도움이 되지 않습니다. 역시 디버깅은 console.log 밖에 없을까요? &lt;del&gt;안돼&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;개발자 도구에선 이렇게 무의미한 파일을 제외하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Blackboxing&lt;/code&gt;이라는 옵션을 제공합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/jquery-blackboxing-edit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;개발자 도구의 설정을 누르고 왼쪽 메뉴에서 Blackboxing을 선택한 다음 Add pattern..을 클릭하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/.*jquery.*\.js$&lt;/code&gt; 패턴을 등록합니다. jquery라는 글자가 들어간 js 파일을 제외합니다.&lt;/p&gt;

&lt;p&gt;새로고침을 하고 다시 클릭해 보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/jquery-jq.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;jquery파일이 제외되어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jq-script.js&lt;/code&gt;파일에 정상적으로 중단점이 걸렸습니다. 이러한 방식으로 react, vue 라이브러리 파일등을 Blackboxing에 등록해서 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Fetch Breakpoint&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이번에는 click 이벤트가 아닌 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;github.com에 네트워크 요청이 있을 때&lt;/code&gt; 중단점을 걸어보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/jquery-fetch-edit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;디버깅 정보 창에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XHR/fetch Breakpoints&lt;/code&gt;섹션을 열고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt; 버튼을 누른 다음에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;github&lt;/code&gt;을 입력합니다. Github ID 입력창에 ID를 입력하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fetch Avatar&lt;/code&gt;를 클릭하면 github이 들어간 주소에 네트워크 요청이 있는 코드에서 중단점이 생성됩니다. 이제 네트워크 요청을 하는 코드가 어디 있는지 고민하지 않아도 되겠죠.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Column Breakpoint&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;fetch함수를 자세히 보면 한 줄로 길게 연결(chain)되어 있는걸 알 수 있습니다. 어떤 응답 데이터가 오는지 궁금한데… 한 줄 내 중간중간열에 중단점을 생성할 수도 있을까요? 일단 디버깅할 라인에 중단점을 체크하면 연결된 함수에 다시 중단점을 걸 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/jquery-inline-edit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;47line&lt;/code&gt;에 중단점을 생성하고 updateGithub 함수 앞에 또 중단점을 생성했습니다. Github ID를 입력하고 Fetch를 하면 중간 중단점에 디버깅이 멈추고 해당 시점의 data 변수값도 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DOM change Breakpoint&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;마지막으로 DOM이 변경되었을 때 중단점을 생성해보겠습니다. 지금 보는 웹 어플리케이션은 Github의 사용자 정보를 조회하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;result&lt;/code&gt;라는 ID를 가진 div에 정보를 출력합니다. result div에 중단점을 생성해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Elements&lt;/code&gt;탭을 누르고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;result&lt;/code&gt; div를 찾은 다음 오른쪽 버튼을 누르면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Break on&lt;/code&gt;메뉴와  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subtree modifications&lt;/code&gt; 항목이 보입니다. 해당 DOM의 하위에 값이 변경되면 멈추겠다는 뜻입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/jquery-dom-break-edit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;DOM 왼쪽에 동그라미 표시가 된 게 보이시죠? 이제 다시 테스트를 해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/jquery-dom-breakpoint-edit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;데이터를 요청하고 화면에 그리는 순간 중단점에 걸립니다. 이제 에디터 전체검색창에 DOM ID를 입력하고 검색결과의 홍수 속에서 원하는 소스를 일일이 찾아보지 않아도 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;react-example&quot;&gt;React Example&lt;/h3&gt;

&lt;p&gt;마지막 예제는 webpack을 이용하여 소스를 번들링한 최신 트랜드를 반영한 예제입니다. 이전까지 예제는 소스 파일과 브라우저에서 보이는 소스 파일이 정확하게 일치했지만 webpack을 사용하면 소스 파일을 bundle.js라는 하나의 파일로 묶기 때문에 소스가 일치하지 않습니다. 이런 경우에도 디버깅이 가능할까요?&lt;/p&gt;

&lt;p&gt;브라우저에서  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://localhost:3000/react.html&lt;/code&gt;에 접속합니다. 개발자 도구를 열고 Sources탭의 파일 네비게이션 창을 봅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/react-sources-edit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;static/js/bundle.js&lt;/code&gt; 파일외에 webpack으로 번들링 된 소스 파일 목록이 보입니다.  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;src/reducers/todos.js&lt;/code&gt;파일의 switch문에 중단점을 걸고 새로운 할 일을 등록하면 정확하게 중단점에 멈추는 걸 확인할 수 있습니다. 어떻게 된걸까요? 정답은 source map입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;source map&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bundle.js&lt;/code&gt; 파일의 최하단을 보면 소스맵과 관련된 주석이 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;//# sourceMappingURL=bundle.js.map&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://localhost:3000/static/js/bundle.js.map&lt;/code&gt;를 주소창에 입력하면 뭔가 복잡한 파일이 나타납니다. 😱 간략하게 표현하면 다음과 같은 구조로 되어 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;version&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;file&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;out.js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;sourceRoot&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;sources&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;foo.js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;bar.js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;names&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;maps&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;are&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;fun&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;mappings&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;AAgBC,SAAQ,CAAEA&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이 파일을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;source map&lt;/code&gt; 이라고 합니다.&lt;/p&gt;

&lt;p&gt;소스맵은 합쳐지거나 minified된 파일과 원본 파일을 연결하기 위해 어떤 소스의 몇번째 줄 몇번째 열이 어떤 소스의 몇번째 줄 몇번째 열과 일치하는지 알려주는 역할을 합니다. &lt;del&gt;너와 나의 연결고리&lt;/del&gt; React와 관련된 파일은 엄청나게 많기 때문에 소스맵파일도 엄청나게 클 수밖에 없습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;소스맵에 대해 더 자세히 알고 싶다면 &lt;a href=&quot;https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/&quot;&gt;Introduction to JavaScript Source Maps - HTML5 Rocks&lt;/a&gt;를 참고하세요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;webpack은 소스맵을 생성할 수 있는 옵션(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;devtool&lt;/code&gt;)이 있어서 설정만으로 손쉽게(?) 사용할 수 있습니다. 이러한 방식은 typescript로 작성한 코드에서도 잘 동작합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Conditional Breakpoint&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Redux에서 reducer는 다양한 action을 처리하는 곳 입니다. 추가/수정/삭제에 대한 action이 들어올 수 있는데 삭제 action만 중단점을 생성해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/devtool-conditional.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;조금 전 생성한 중단점에 오른쪽 버튼을 누르면 중단점을 수정할 수 있고 조건절에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;action.type == 'DELETE_TODO'&lt;/code&gt; 를 입력합니다. 새로운 할일을 등록하면 중단이 안되지만 삭제를 하면 중단점에 걸립니다. 이렇게 중단점에 조건을 걸면 조건에 맞는 요청만 체크할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Store as Global Variable&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;마지막으로 특정 React Component에 존재하는 멤버(지역) 변수를 콘솔창에서 자유롭게 테스트하는 방법을 알아봅니다. 자바스크립트가 모듈화 되면서 콘솔에서 내부에 존재하는 변수에 접근하기 어려워졌지만 다 방법이 있습니다.&lt;/p&gt;

&lt;p&gt;개발자 도구에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;src/components/Header.js&lt;/code&gt;파일을 열고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;handleSave&lt;/code&gt;에 중단점을 만듭니다. 중단점에 걸리면 Scope의 Closure (Header) 섹션에서  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_this&lt;/code&gt; 변수를 오른쪽 버튼 클릭하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Store as global variable&lt;/code&gt;을 선택합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/devtools-global.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;콘솔창을 보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;temp1&lt;/code&gt;이라는 변수가 생성된 것을 알 수 있고 이제 자유롭게 사용할 수 있습니다. 중단점을 제거하고 코드로 할 일을 생성해 보겠습니다. 콘솔에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;temp1.props.addTodo(&quot;Hello world&quot;)&lt;/code&gt;를 입력합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/react-console.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정상적으로 새로운 할 일이 추가되었습니다. 이제 콘솔에서 자유롭게 테스트하세요!&lt;/p&gt;

&lt;h2 id=&quot;visual-studio-code&quot;&gt;Visual Studio Code&lt;/h2&gt;

&lt;p&gt;지금까지 개발자 도구의 다양한 디버깅 기능을 살펴보았습니다. 내장된 에디터도 간단하게 사용하기엔 좋지만, 아직 기능이 많이 부족해 보입니다.  코드 작성은 VSCode에서, 중단점 및 테스트는 크롬 브라우저에서 테스트할 수 있게 설정해보겠습니다.&lt;/p&gt;

&lt;p&gt;VSCode를 실행하고 다운받은 소스 디렉토리를 엽니다.&lt;/p&gt;

&lt;h3 id=&quot;chrome-확장기능-소개&quot;&gt;chrome 확장기능 소개&lt;/h3&gt;

&lt;p&gt;크롬 브라우저와 연동하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Debugger for Chrome&lt;/code&gt; 확장기능을 설치해야 합니다. VSCode의 확장 탭에서 chrome을 검색하고 설치합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/debugger-for-chrome-edit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;설치가 완료되면 디버그 포트를 오픈한 크롬을 실행할 수 있게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.vscode/launch.json&lt;/code&gt; 파일을 작성합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;version&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0.1.0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;configurations&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Launch Js Debug Example&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;chrome&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;request&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;launch&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;url&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:3000/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;webRoot&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;${workspaceFolder}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;pathMapping&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;src&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;${workspaceFolder}/src&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;js/vanilla-script.js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;${workspaceFolder}/public/js/vanilla-script.js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;js/jq-script.js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;${workspaceFolder}/public/js/jq-script.js&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;skipFiles&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;node_modules/*&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;react-dom*.js&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;jquery-3.3.1.min.js&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;disableNetworkCache&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;blockquote&gt;
  &lt;p&gt;설정 파일을 보면 대략 어떤 내용인지 유추할 수 있어 자세히 설명하지 않습니다. 옵션에 대한 설명은 &lt;a href=&quot;https://github.com/Microsoft/vscode-chrome-debug&quot;&gt;GitHub - Microsoft/vscode-chrome-debug: Debug your JavaScript code running in Google Chrome from VS Code.&lt;/a&gt; 여기서 확인할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;vscode-debugger&quot;&gt;VSCode Debugger&lt;/h3&gt;

&lt;p&gt;설정 파일을 저장하면 디버깅 모드의 실행 목록에 자동으로 추가됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/vscode-debug-edit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;플레이 버튼처럼 생긴 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Start Debugging&lt;/code&gt;버튼을 클릭하면 깨끗한 프로필의 크롬 브라우저가 실행됩니다. 디버깅 준비가 완료되었으니 테스트로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vanilla-script.js&lt;/code&gt; 파일을 열고 updatePost 함수에 중단점을 설정해 보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/vscode-debugger.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;내용을 입력하면 크롬 브라우저와 VSCode 동시에 중단점이 걸리는 걸 볼 수 있습니다. 개발자 도구처럼 한줄한줄 실행할 수도 있고 콘솔을 사용할 수도 있습니다. 개발자 도구와 VSCode가 동기화돼서 움직이기 때문에 개발자 도구에 중단점을 생성해도 VSCode에서 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이제 VSCode를 사용하면서 크롬 개발자 도구의 강력한 부가 기능도 같이 사용할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;그래서&quot;&gt;그래서&lt;/h2&gt;
&lt;p&gt;자바스크립트 디버깅에 대한 자료를 찾아보면서 이렇게 개발자 도구가 좋아졌나 하고 많이 놀랐습니다. 크롬 브라우저는 6주에 한 번씩 새로운 버전을 &lt;a href=&quot;https://www.chromium.org/chrome-release-channels&quot;&gt;릴리즈&lt;/a&gt;하는데 매번 새로운 기능을 추가하고 있습니다. &lt;a href=&quot;https://www.youtube.com/playlist?list=PLNYkxOF6rcIBDSojZWBv4QJNoT4GNYzQD&quot;&gt;공식 Youtube 채널&lt;/a&gt;에서 새 릴리즈에 대한 내용을 짧게 요약해주니 관심 있으면 구독하는 걸 추천합니다.&lt;/p&gt;

&lt;p&gt;Visual Studio Code 또한 굉장히 빠르게 업데이트되고 있습니다.(매달 &lt;a href=&quot;https://code.visualstudio.com/updates&quot;&gt;릴리즈&lt;/a&gt;) Node.js와의 궁합도 좋아 서버를 node로 작성한 경우 서버와 클라이언트를 동시에 스무스하게 디버깅하고 작업할 수 있습니다. 특히 터치바가 장착된 맥북 프로를 사용한다면 디버깅 모드에서 컨트롤이 이쁘게 터치바에 표시되는 걸 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;console.log&lt;/code&gt;는 여전히 쓸만하지만 다른 여러 가지 방법을 익혀둔다면 디버깅을 더 효율적으로 할 수 있습니다. 그리고 잘 모듈화된 소스, 이해하기 쉽게 지어진 변수명 or 함수명이 더해지면 더더더욱 효과적일거라 생각합니다. 자바스크립트를 이용한 프레임워크는 더욱 복잡해지고 유지보수는 더 어려워집니다. 오늘도 디버깅하느라 고생하는 많은 개발자에 도움이 되길 바랍니다.&lt;/p&gt;

&lt;p&gt;개발자 상시 모집중입니다. 연락주세요 ㅎㅎ (&lt;a href=&quot;http://www.purpleworks.co.kr/recruit&quot;&gt;http://www.purpleworks.co.kr/recruit&lt;/a&gt;)&lt;/p&gt;
</description>
        <pubDate>Wed, 14 Feb 2018 00:00:00 +0900</pubDate>
        <link>https://subicura.com/2018/02/14/javascript-debugging.html</link>
        <guid isPermaLink="true">https://subicura.com/2018/02/14/javascript-debugging.html</guid>
        
        <category>Chrome</category>
        
        <category>Devtools</category>
        
        <category>javascript</category>
        
        <category>debug</category>
        
        <category>node</category>
        
        
        <category>Javascript</category>
        
      </item>
    
      <item>
        <title>본격 macOS에 개발 환경 구축하기</title>
        <description>&lt;h3 id=&quot;20200706-수정&quot;&gt;2020/07/06 수정&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;macOS Catalina 10.15.5 반영&lt;/li&gt;
  &lt;li&gt;명령어 및 설정 최신 내용 반영&lt;/li&gt;
  &lt;li&gt;추천 프로그램 추가&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/neofetch-2.png&quot; alt=&quot;iTerm2 + snazzy&quot; /&gt;&lt;/p&gt;

&lt;p&gt;개발 관련 스터디 모임이나 컨퍼런스에서 발표를 듣다 보면 발표 주제와 별도로 예제 화면이나 라이브 코딩에서 사용하는 개발 도구에 관심이 가는 경우가 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;같은 macOS를 사용하는데 터미널이 왜 다르게 생긴 거지? vi 에디터에 원래 저런 기능이 있었어? 뭐가 저렇게 막 글자가 자동완성되는 거지? 저건 무슨 테마지?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;개인적인 경험으로도 어디서 발표를 할 때 주제와 상관없이 “아까 그거 무슨 프로그램이에요?”, “어떻게 셋팅한 거에요?” 와 같은 질문을 받은 적이 있고 다른 분들 화면을 보고 쉬는 시간에 조용히 가서 “아까 그거 어떻게 하신건지..” 하고 물어본 경우도 많습니다.&lt;/p&gt;

&lt;p&gt;개발 환경 설정은 실제적인 개발과 상관이 없고 &lt;del&gt;해도 그만 안 해도 그만&lt;/del&gt; 개발자들의 개인 취향에 영향을 많이 받기 때문에 처음부터 차근차근 설정하는 법을 알려주는 문서가 잘 없고 여기저기 작은 단위로 소개하거나 모임 같은 곳에서 입에서 입으로 전해지고 있습니다.&lt;/p&gt;

&lt;p&gt;이 글은 macOS에서 터미널을 자주 사용하는 개발자를 대상으로 심플하고 깔끔한 테마 위주의 개발 환경을 설정하는 방법을 소개합니다. 이 글을 보고 하나하나 설정하면 어디 가서 발표할 때 고오오급 개발자처럼 보이는 효과가 있으며 개발 생산성이 조금은 높아질 거라고 생각합니다.&lt;/p&gt;

&lt;p&gt;최종 설정이 완료된 화면을 살펴보고 어떻게 설정하는지 알아봅니다.&lt;/p&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-11-22-mac-os-development-environment-setup/terminal-demo.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/div&gt;

&lt;div align=&quot;center&quot; class=&quot;googleads googleads-content&quot;&gt;
                &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-2468713653725581&quot; data-ad-slot=&quot;8649023787&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
            &lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;키보드-기호-설명&quot;&gt;키보드 기호 설명&lt;/h2&gt;

&lt;p&gt;단축키 입력과 관련해서 기호를 사용합니다. 잘 기억해 둡니다.&lt;/p&gt;

&lt;table class=&quot;table table-key-value-60&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;기호&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;⌘&lt;/td&gt;
      &lt;td&gt;Command&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;⌥&lt;/td&gt;
      &lt;td&gt;Option&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;⌃&lt;/td&gt;
      &lt;td&gt;Control&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;⇧&lt;/td&gt;
      &lt;td&gt;Shift&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;+&lt;/td&gt;
      &lt;td&gt;동시 입력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;,&lt;/td&gt;
      &lt;td&gt;키를 떼고 다시 입력함&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;예) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;⌃&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c&lt;/code&gt; 는 control키를 누른 상태에서 b를 누르고 control키와 b에서 모두 손을 뗀 다음에 c를 입력하라는 의미입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;시스템-설정&quot;&gt;시스템 설정&lt;/h2&gt;

&lt;p&gt;본격적인 개발환경 설정에 앞서 몇 가지 유용한 시스템 설정을 확인해봅니다. macOS Catalina를 기준으로 하였으나 다른 버전도 비슷비슷할 것으로 보입니다. 반드시 동일하게 설정할 필요는 없으며 보고 괜찮다 싶은 항목만 적용하면 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;system-preferences&quot;&gt;System Preferences&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/system-preferences-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;상단 메뉴의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;/code&gt; 로고를 누르고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;System Preferences...&lt;/code&gt;를 선택합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;미션 컨트롤&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/mission-control.png&quot; alt=&quot;Mission Control&quot; /&gt;&lt;/p&gt;

&lt;p&gt;미션 컨트롤 창 순서 고정&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mission Control&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Automatically rearrange Spaces based on most recent use&lt;/code&gt;: 체크 안함&lt;/li&gt;
  &lt;li&gt;미션 컨트롤 창 순서가 기본적으로 최근 사용 순으로 설정되어 있어 의도하지 않게 순서가 변경되는 것을 막음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;언어&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/language-region.png&quot; alt=&quot;Language &amp;amp; Region&quot; /&gt;&lt;/p&gt;

&lt;p&gt;언어 설정 영어 우선순위로 변경&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Language &amp;amp; Region&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Preferred languages&lt;/code&gt;: English &amp;gt; 한국어 (드래그로 순서 조정)&lt;/li&gt;
  &lt;li&gt;간혹 locale 설정 때문에 오류가 발생하는 걸 방지해주고 영어 오류 메시지가 구글검색이 잘됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;보안&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/security-privacy-1.png&quot; alt=&quot;Security &amp;amp; Privacy&quot; /&gt;&lt;/p&gt;

&lt;p&gt;패스워드 즉시 설정&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Security &amp;amp; Privacy&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;General&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Require password&lt;/code&gt;: immediately&lt;/li&gt;
  &lt;li&gt;잠자기 모드나 화면 보호기가 켜지면 즉시 패스워드 입력을 활성화하여 보안을 최대한 안전하게 유지&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;분실대비 스크린 메시지 설정&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Security &amp;amp; Privacy&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;General&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Show a message when the screen is locked&lt;/code&gt;: 전화번호 / 이름&lt;/li&gt;
  &lt;li&gt;혹시 분실했을 경우를 대비하여 전화번호, 이름 등을 알려줌&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;디스크 암호화&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Security &amp;amp; Privacy&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FileVault&lt;/code&gt;: Turn On FileVault&lt;/li&gt;
  &lt;li&gt;분실 시 복구 불가능하게 디스크를 암호화&lt;/li&gt;
  &lt;li&gt;파일 읽기/쓰기 퍼포먼스가 걱정되지만 최신 CPU와 SSD에서는 거의 성능 차이가 없다고 함&lt;del&gt;믿고쓰자&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;키보드&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/keyboard-1.png&quot; alt=&quot;Keyboard &amp;gt; Text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;모든 텍스트 자동 변경 옵션 끄기&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Keyboard&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Text&lt;/code&gt;: 모든 자동 변경 옵션 끄기&lt;/li&gt;
  &lt;li&gt;입력한 단어를 컴퓨터 마음대로 바꾸는 걸 방지&lt;/li&gt;
  &lt;li&gt;특히 Use smart quotes and dashes는 코드 복사하다가 따옴표가 바뀌면서 고생이 시작됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/keyboard-2.png&quot; alt=&quot;Keyboard &amp;gt; Shortcuts&quot; /&gt;&lt;/p&gt;

&lt;p&gt;컨트롤 버튼 키보드로 제어하기 (&lt;a href=&quot;https://twitter.com/devthewild/status/1278683719310557187&quot;&gt;@devthewild님 추천&lt;/a&gt;)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Keyboard&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shortcut&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Use keyboard navigation to move focus between controls&lt;/code&gt; : 체크함&lt;/li&gt;
  &lt;li&gt;예/아니오 버튼을 키보드로 선택할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;트랙패드&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/trackpad.png&quot; alt=&quot;Trackpad&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클릭은 터치로&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Trackpad&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Point &amp;amp; Click&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Tab to click&lt;/code&gt;: 체크함&lt;/li&gt;
  &lt;li&gt;트랙패드 클릭 시 꾸욱 누를 필요 없이 톡톡 터치로 클릭해서 손의 피로를 줄임&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;접근성&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/accessibility.png&quot; alt=&quot;Accessibility&quot; /&gt;&lt;/p&gt;

&lt;p&gt;드래그는 세손가락으로&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Accessibility&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pointer Control&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Trackpad options...&lt;/code&gt;:  Enable dragging - three finger drag&lt;/li&gt;
  &lt;li&gt;창 또는 아이콘을 이동할 때 트랙패드를 누른 상태로 이동할 필요 없이 세 손가락으로 드래그 할 수 있음&lt;/li&gt;
  &lt;li&gt;이건 해봐야 감이 오는데 몰랐다면 신세계가 열림&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;finder-preference&quot;&gt;Finder Preference&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Finder&lt;/code&gt;를 실행하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;⌘&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;,&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Finder&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Preferences...&lt;/code&gt;)를 선택합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;파인더 기본 폴더 설정&lt;/strong&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;/assets/article_images/2017-11-22-mac-os-development-environment-setup/finder-1.png&quot; style=&quot;width: 450px&quot; /&gt;
&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;General&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;New Finder windows show&lt;/code&gt;: subicura (home folder)&lt;/li&gt;
  &lt;li&gt;파인더 최초 실행 시 버벅임이 없도록 기본 폴더를 홈 폴더로 설정&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;파일 확장자 보여주기&lt;/strong&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;/assets/article_images/2017-11-22-mac-os-development-environment-setup/finder-2.png&quot; style=&quot;width: 450px&quot; /&gt;
&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Advanced&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Show all filename extensions&lt;/code&gt;: 체크함&lt;/li&gt;
  &lt;li&gt;모든 파일의 확장자를 보여줌&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;download-folder-option&quot;&gt;Download Folder Option&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Downloads&lt;/code&gt; 폴더로 이동하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;⌘&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;J&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;View&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Show View Options&lt;/code&gt;)를 선택합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;날짜그룹 + 이름 정렬&lt;/strong&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;/assets/article_images/2017-11-22-mac-os-development-environment-setup/finder-3.png&quot; style=&quot;width: 300px&quot; /&gt;
&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Arrange By&lt;/code&gt;:Date added, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sort By&lt;/code&gt;:Name&lt;/li&gt;
  &lt;li&gt;파일 목록을 저장한 날짜별로 그룹화 하고 그룹 내에서 이름으로 다시 정렬&lt;/li&gt;
  &lt;li&gt;다운로드 폴더 특성상 최근에 받은 파일들을 찾는 경우가 많으므로 유용함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;-대신--입력하기&quot;&gt;‘₩’ 대신 ‘`’ 입력하기&lt;/h3&gt;

&lt;p&gt;맥 최신 버전에서 한글입력 일땐 &lt;strong&gt;₩&lt;/strong&gt;가 입력되고 영문입력 일땐 &lt;strong&gt;`&lt;/strong&gt;가 입력되어 불편한 경우가 많습니다. 무조건 &lt;strong&gt;`&lt;/strong&gt;가 입력되도록 시스템을 설정합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;~/Library/KeyBindings/DefaultkeyBinding.dict&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;해당 위치에 파일을 생성하고 다음과 같은 내용을 입력합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;s2&quot;&gt;&quot;₩&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;insertText:&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;OS 재시작이 필요합니다.&lt;/p&gt;

&lt;h2 id=&quot;필수-프로그램&quot;&gt;필수 프로그램&lt;/h2&gt;

&lt;p&gt;시스템 설정을 완료했으니 개발 환경 구축을 위한 필수 프로그램을 설치합니다.&lt;/p&gt;

&lt;h3 id=&quot;xcode&quot;&gt;Xcode&lt;/h3&gt;

&lt;p&gt;macOS는 기본적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gcc&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make&lt;/code&gt;와 같은 컴파일 도구가 설치되어 있지 않기 때문에 명령어 도구&lt;sub&gt;Command Line Tools&lt;/sub&gt;를 설치해야 합니다. 예전에는 Xcode를 전체 설치하고 추가로 명령어 도구를 설치해야 했으나 Xcode용량이 꽤 크고 모든 사람이 IDE가 필요한 게 아니기 때문에 명령어 도구만 따로 설치할 수 있게 변경되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설치&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;#homebrew&quot;&gt;homebrew&lt;/a&gt;를 설치하면 자동으로 Xcode 명령어 도구를 설치합니다. 따로 설치하지 않아도 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;xcode-select &lt;span class=&quot;nt&quot;&gt;--install&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;확인&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# gcc test&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;gcc
clang: error: no input files
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/xcode/&quot;&gt;Xcode 홈페이지&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;homebrew&quot;&gt;homebrew&lt;/h3&gt;

&lt;p&gt;brew&lt;sub&gt;homebrew&lt;/sub&gt;는 각종 커맨드라인 프로그램과 일반 프로그램(크롬..)을 손쉽게 설치해주는 맥용 패키지 매니저입니다.(최근에 리눅스도 지원하기 시작했습니다.) 리눅스의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apt&lt;/code&gt;나  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yum&lt;/code&gt;과 비슷하며 brew외에 &lt;a href=&quot;https://www.macports.org/&quot;&gt;MacPorts&lt;/a&gt; 라는 패키지 메니저가 있는데 몇몇 단점으로 요즘은 거의 brew를 사용하는 추세입니다. 다양한 프로그램을 복잡한 빌드과정 없이 손쉽게 설치할 수 있고 업데이트, 관리도 간단하므로 안쓸 이유가 없는 필수 프로그램입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;그냥 홈페이지 가서 다운로드 하고 설치하는 게 편한데..&lt;/code&gt;라고 하는분들이 있는데 나중에 업데이트나 삭제를 생각해보면 글쎄요.. brew 쓰세요!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설치&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;/bin/bash &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-fsSL&lt;/span&gt; https://raw.githubusercontent.com/Homebrew/install/master/install.sh&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;확인&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# brew test&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;brew doctor
Your system is ready to brew.
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://brew.sh/&quot;&gt;Homebrew 홈페이지&lt;/a&gt; / &lt;a href=&quot;https://docs.brew.sh/Manpage.html&quot;&gt;brew 명령어&lt;/a&gt; / &lt;a href=&quot;http://formulae.brew.sh/&quot;&gt;brew 패키지 검색&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;git&quot;&gt;git&lt;/h3&gt;

&lt;p&gt;버전 관리 도구로 유명한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git&lt;/code&gt;입니다. 다들 아시죠? macOS에 기본으로 설치되어 있지만 최신 버전이 아니므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;brew&lt;/code&gt;를 이용해서 업데이트 합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git-lfs&lt;/code&gt; 는 Git Large File Storage로 용량이 큰 바이너리 파일을 git으로 관리할 때 유용합니다. git 설치할 때 같이 설치합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설치&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;git git-lfs
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;git 설치가 완료되었으면 개인정보를 설정하고 맥에서 한글 파일명을 정상적으로 처리하기 위해 추가 옵션을 설정합니다. &lt;del&gt;망할 한글처리&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설정&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;git config &lt;span class=&quot;nt&quot;&gt;--global&lt;/span&gt; user.name &lt;span class=&quot;s2&quot;&gt;&quot;Your Name&quot;&lt;/span&gt;
git config &lt;span class=&quot;nt&quot;&gt;--global&lt;/span&gt; user.email &lt;span class=&quot;s2&quot;&gt;&quot;you@your-domain.com&quot;&lt;/span&gt;
git config &lt;span class=&quot;nt&quot;&gt;--global&lt;/span&gt; core.precomposeunicode &lt;span class=&quot;nb&quot;&gt;true
&lt;/span&gt;git config &lt;span class=&quot;nt&quot;&gt;--global&lt;/span&gt; core.quotepath &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://git-scm.com/&quot;&gt;Git 홈페이지&lt;/a&gt; / &lt;a href=&quot;https://git-lfs.github.com/&quot;&gt;Git LFS 홈페이지&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;터미널-설정&quot;&gt;터미널 설정&lt;/h2&gt;

&lt;p&gt;시스템 설정도 하고 필수 프로그램도 설치했으니 본격적으로 터미널을 설정해 봅니다.&lt;/p&gt;

&lt;h3 id=&quot;iterm2&quot;&gt;iTerm2&lt;/h3&gt;

&lt;p&gt;macOS에 기본으로 설치되어 있는 Terminal 앱 대신 iTerm2를 터미널 앱으로 사용합니다. iTerm2는 기본 앱에 없는 &lt;a href=&quot;https://www.iterm2.com/features.html&quot;&gt;다양한 기능&lt;/a&gt;이 있고 손쉽게 테마를 설정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설치&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;brew로 설치 하거나 &lt;a href=&quot;https://www.iterm2.com/downloads.html&quot;&gt;여기&lt;/a&gt;서 다운로드 합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;brew cask &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;iterm2
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;테마선택&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/snazzy-theme-2.png&quot; alt=&quot;snazzy&quot; /&gt;&lt;/p&gt;

&lt;p&gt;설치를 완료했으면 &lt;a href=&quot;https://raw.githubusercontent.com/sindresorhus/iterm2-snazzy/main/Snazzy.itermcolors&quot;&gt;Snazzy.itermcolors&lt;/a&gt; 파일을 오른쪽 버튼 누르고 다운 받거나 &lt;a href=&quot;http://iterm2colorschemes.com/&quot;&gt;여러 개의 테마&lt;/a&gt;를 둘러보고 맘에드는것을 고릅니다. 다운받은 파일을 더블클릭하면 자동으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;iTerm Color Preset&lt;/code&gt;에 추가됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;테마적용&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;iTerm2를 실행하고 설정(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;⌘&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;,&lt;/code&gt;)창에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Profiles&lt;/code&gt; 항목을 선택하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Colors&lt;/code&gt;탭을 선택합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/iterm-preferences-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;오른쪽 하단에  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Color presets...&lt;/code&gt; 선택 박스를 클릭하면 조금전에 추가한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Snazzy&lt;/code&gt; preset을 선택할 수 있습니다.&lt;/p&gt;

&lt;p&gt;음.. 그런데 테마를 바꿔도 그다지 달라지는 건 없어보입니다.. &lt;del&gt;이게 무슨 소리요?!&lt;/del&gt; 제대로 색을 활용하려면 쉘&lt;sub&gt;shell&lt;/sub&gt; 설정을 해야합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;추가 디자인 설정&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;iTerm창을 더 단순하게 만들기 위한 추가 설정입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;타이틀바 스타일 변경
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Appearance&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Theme&lt;/code&gt;: Minimal
        &lt;ul&gt;
          &lt;li&gt;탭의 높이를 얇게 조정하고 싶다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dark&lt;/code&gt;를 추천&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;타이틀바 밑에 1px 라인 제거
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Appearance&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Windows&lt;/code&gt; &amp;gt;  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Show line under title bar when the tab bar is not visible&lt;/code&gt;: 체크 안함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;폰트 크기 및 줄간격 변경
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Profiles&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Text&lt;/code&gt;: 폰트사이즈 12로 변경&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Profiles&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Text&lt;/code&gt;: n/n 줄간격 110으로 변경&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;마진 수정
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Advanced&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Height of top and bottom margins in terminal panes&lt;/code&gt;: 10&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Advanced&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Width of left and right margins in terminal panes&lt;/code&gt;: 12&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;탭 선 제거
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Advanced&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;In minimal tab style, how prominent should the tab outline be?&lt;/code&gt;: 0&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;한글파일 깨짐방지&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/text-unicode.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;파일명 또는 디렉토리명의 자/모가 분리되는 현상을 방지합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Unicode 설정
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Profiles&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Text&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Unicode normalization form&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NFC&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;단축키 변경&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/iterm-keys.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Option ⌥&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;←&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;→&lt;/code&gt;를 이용하여 단어 단위로 이동할 수 있게 단축키 설정을 변경합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;단축키 변경
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Profiles&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Keys&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Presets&lt;/code&gt;: Natural Text Editing 선택&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;상태바 추가&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/iterm2-status.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;iTerm2에 새롭게 추가된 상태바 기능입니다. 상단 또는 하단에 상태바를 추가하고 여러가지 정보를 볼 수 있습니다. 필요한 경우 활성화해서 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/iterm2-statusbar.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;상태바 추가
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Profile&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Session&lt;/code&gt;: Status bar enabled 체크
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Configure Status Bar&lt;/code&gt; 선택하여 원하는 항목 드레그 추가&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Appearance&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Status bar location&lt;/code&gt; : 상태바 위치 설정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://www.iterm2.com&quot;&gt;iTerm2 홈페이지&lt;/a&gt; / &lt;a href=&quot;https://www.iterm2.com/downloads.html&quot;&gt;iTerm2 다운로드&lt;/a&gt; / &lt;a href=&quot;https://github.com/sindresorhus/iterm2-snazzy&quot;&gt;snazzy github&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;zsh-with-oh-my-zsh&quot;&gt;zsh with oh-my-zsh&lt;/h3&gt;

&lt;p&gt;iTerm2도 설치하고 테마도 설치했으니 쉘을 바꿀 차례입니다.&lt;/p&gt;

&lt;p&gt;macOS는 기본으로 zsh을 사용하고 있습니다. 기존에 사용하던 bash에서 zsh로 기본 설정이 바뀐걸 보면 대세이긴 한 것 같습니다. zsh에 설정 관리 프레임워크인 oh-my-zsh을 사용하여 이쁜 테마를 적용하고 여러 가지 플러그인을 설치해봅니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설치&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;zsh을 최신 버전으로 업데이트하고 &lt;a href=&quot;https://github.com/zsh-users/zsh-completions&quot;&gt;zsh-completions&lt;/a&gt;도 설치합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;zsh zsh-completions
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;그리고 zsh의 설정을 관리해주는 oh-my-zsh을 설치합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sh &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-fsSL&lt;/span&gt; https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;설치스크립트를 실행하면 관련 파일을 설치하고 패스워드를 물어봅니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;플러그인&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;oh-my-zsh의 가장 강력한 점은 플러그인입니다. &lt;a href=&quot;https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins&quot;&gt;기본 플러그인&lt;/a&gt;외에 명령어 하이라이팅 플러그인 &lt;a href=&quot;https://github.com/zsh-users/zsh-syntax-highlighting&quot;&gt;zsh-syntax-highlighting&lt;/a&gt;과 자동완성 플러그인 &lt;a href=&quot;https://github.com/zsh-users/zsh-autosuggestions&quot;&gt;zsh-autosuggestions&lt;/a&gt;을 설치합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# zsh-syntax-highlighting&lt;/span&gt;
git clone https://github.com/zsh-users/zsh-syntax-highlighting.git &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ZSH_CUSTOM&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;~/.oh-my-zsh/custom&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;/plugins/zsh-syntax-highlighting

&lt;span class=&quot;c&quot;&gt;# zsh-autosuggestions&lt;/span&gt;
git clone git://github.com/zsh-users/zsh-autosuggestions &lt;span class=&quot;nv&quot;&gt;$ZSH_CUSTOM&lt;/span&gt;/plugins/zsh-autosuggestions
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;플러그인을 설치하면 반드시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.zshrc&lt;/code&gt;파일에 설정을 해야합니다. 파일을 열고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;plugins&lt;/code&gt;항목에 플러그인을 추가합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;plugins&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=(&lt;/span&gt;
  git
  zsh-syntax-highlighting
  zsh-autosuggestions
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;설정 파일을 수정했으면 터미널을 재시작하거나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;source ~/.zshrc&lt;/code&gt; 명령어를 실행하여 설정을 다시 불러와야 합니다. 이제 명령어를 입력할 때 존재하지 않는 명령어는 빨간색으로 뜨고 한번 입력했던 명령어를 흐릿하게 표현해주는 걸 확인할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;쉘-프롬프트&quot;&gt;쉘 프롬프트&lt;/h3&gt;

&lt;p&gt;oh-my-zsh의 기본 테마인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;robbyrussell&lt;/code&gt;도 깔끔하지만, 이 외에 &lt;a href=&quot;https://github.com/robbyrussell/oh-my-zsh/wiki/Themes&quot;&gt;다양한 테마&lt;/a&gt;가 존재합니다. 테마를 바꾸는 방법은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.zshrc&lt;/code&gt;파일의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZSH_THEME=&quot;robbyrussell&quot;&lt;/code&gt; 부분을 원하는 테마로 수정하면 됩니다.&lt;/p&gt;

&lt;p&gt;여기서는 단순히 색상, 모양 설정을 넘어 추가적인 기능을 설치합니다. 추가적인 기능은 현재 디렉토리의 git 상태를 보여주고 사용중인 nodejs, ruby의 버전을 보여주거나 aws, kubectl 프로필을 보여주기도 합니다.&lt;/p&gt;

&lt;p&gt;대표적인 프롬프트는 &lt;a href=&quot;https://github.com/romkatv/powerlevel10k&quot;&gt;Powerlevel10k&lt;/a&gt;, &lt;a href=&quot;https://denysdovhan.com/spaceship-prompt/&quot;&gt;spaceship&lt;/a&gt;, &lt;a href=&quot;https://github.com/sindresorhus/pure&quot;&gt;pure&lt;/a&gt;가 있습니다. 취향에 맞춰서 사용하면 되고 개인적으로 예전에는 pure를 썼지만 최근에는 Powerlevel10k를 사용하고 있습니다. Powerlevel10k는 쉘응답속도와 프롬프트 초기화가 가장 빠르고 Lean테마를 사용하면 단순한 형태로 사용할 수 있습니다. 특히 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aws&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl&lt;/code&gt;등 특정 명령어를 칠때만 나타나는 프로필 기능이 아주 마음에 듭니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;속도비교: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;powerline10k &amp;gt;&amp;gt;&amp;gt;&amp;gt; spaceship, pure&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;기능비교: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;powerline10 &amp;gt; spaceship &amp;gt;&amp;gt;&amp;gt;&amp;gt; pure&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;디자인비교 (취향탐): &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spaceship, pure &amp;gt; powerline10k&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Powerlevel10k(추천)&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;git clone &lt;span class=&quot;nt&quot;&gt;--depth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1 https://github.com/romkatv/powerlevel10k.git &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ZSH_CUSTOM&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;~/.oh-my-zsh/custom&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;/themes/powerlevel10k
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;설치를 완료하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.zshrc&lt;/code&gt;파일에 ZSH_THEME항목을 수정합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;ZSH_THEME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;powerlevel10k/powerlevel10k&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;저장 후 새로 탭을 열면, 대화형 설정창이 뜨고 상세하게 테마를 설정할 수 있습니다. 다시 설정하고 싶다면 언제든 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p10k configure&lt;/code&gt;를 입력하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;spaceship(설정귀찮으면 추천)&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;git clone https://github.com/denysdovhan/spaceship-prompt.git &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ZSH_CUSTOM&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/themes/spaceship-prompt&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;ln&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ZSH_CUSTOM&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/themes/spaceship-prompt/spaceship.zsh-theme&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ZSH_CUSTOM&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/themes/spaceship.zsh-theme&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;설치를 완료하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.zshrc&lt;/code&gt;파일에 ZSH_THEME항목을 수정합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;ZSH_THEME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;spaceship&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;pure&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;nodejs &lt;span class=&quot;c&quot;&gt;# nodejs가 설치되어 있다면 skip&lt;/span&gt;
npm &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--global&lt;/span&gt; pure-prompt
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;설치를 완료하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.zshrc&lt;/code&gt;파일에 다음항목을 추가합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;autoload &lt;span class=&quot;nt&quot;&gt;-U&lt;/span&gt; promptinit&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; promptinit
prompt pure
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;oh-my-zsh-팁&quot;&gt;oh-my-zsh 팁&lt;/h3&gt;

&lt;p&gt;zsh과 oh-my-zsh의 조합으로 강력한 쉘을 사용할 수 있게 되었습니다. 여기서 모든 기능을 설명할 순 없지만 자주 사용하는 몇 가지 팁을 소개합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;명령어가 기억나지 않으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tab&lt;/code&gt;을 누르세요&lt;/li&gt;
  &lt;li&gt;cd ../.. 대신 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;...&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;....&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.....&lt;/code&gt;, …&lt;/li&gt;
  &lt;li&gt;단축명령어 - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git status&lt;/code&gt; =&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gst&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git pull&lt;/code&gt; =&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gl&lt;/code&gt; 등등 &lt;a href=&quot;https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git&quot;&gt;다양한 단축명령어&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-11-22-mac-os-development-environment-setup/zsh-demo.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;팁이 맘에 든다면 &lt;a href=&quot;https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins&quot;&gt;다른 플러그인&lt;/a&gt;도 구경하세요. 어마어마한 양의 플러그인이 준비되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/robbyrussell/oh-my-zsh&quot;&gt;oh-my-zsh 홈페이지&lt;/a&gt; / &lt;a href=&quot;https://github.com/sindresorhus/pure&quot;&gt;pure github&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;커맨드라인-애플리케이션&quot;&gt;커맨드라인 애플리케이션&lt;/h2&gt;

&lt;p&gt;이제 터미널이 이뻐졌으니 각종 도구를 설정해봅니다.&lt;/p&gt;

&lt;h3 id=&quot;vim&quot;&gt;vim&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/spacevim.png&quot; alt=&quot;spacevim + snazzy&quot; /&gt;&lt;/p&gt;

&lt;p&gt;vim은 기본으로 설치된 터미널용 에디터로 GUI 환경의 에디터를 사용할 수 있는 macOS 환경에서는 일부 &lt;del&gt;고오오급&lt;/del&gt; 개발자를 제외하고는 잘 쓰이지 않습니다. 하지만 터미널 작업을 하다 보면 간단하게 수정할 파일이 있고 git 커밋메시지를 작성할 때 종종 사용하게 됩니다.&lt;/p&gt;

&lt;p&gt;기본으로 설정된 화면은 밋밋하기 그지 없기 때문에 강력한 기능의 플러그인을 설치해줍니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설치&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;내장된 vim대신 neovim을 설치합니다. neovim은 vim과 차이가 없어 보이는데 24bit True Color를 지원하고 오래된 vim 소스를 처음부터 다시 짜서 소스코드가 줄었다고 합니다. 저 같은 라이트 유저는 차이를 느끼진 못하지만 좋다고 해서 사용하고 있습니다. 그리고 테마에서 사용할 개발용 폰트를 설치합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Powerline10k&lt;/code&gt; 프롬프트를 사용하면 개발용 폰트(MesloLGS NF)가 자동으로 설치됩니다. 따로 설치할 필요가 없습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;neovim
&lt;span class=&quot;c&quot;&gt;# MesloLGS NF가 없는 경우&lt;/span&gt;
brew tap homebrew/cask-fonts
brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;font-meslo-lg-nerd-font
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;기본 설치가 완료되었으면 터미널 기본 에디터로 vi대신 neovim을 사용하도록 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.zshrc&lt;/code&gt;에 다음 항목을 추가합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;alias &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;vim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;nvim&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;alias &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;vi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;nvim&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;alias &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;vimdiff&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;nvim -d&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;EDITOR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/local/bin/nvim
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;source ~/.zshrc&lt;/code&gt;를 입력하여 설정을 다시 불러옵니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;플러그인&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;vim은 강력한 플러그인들이 많은데 설치가 어렵고 어떤 게 좋은지 라이트 유저는 알 수가 없습니다. SpaceVim이라는 프로젝트는 가장 많은 사람들이 사용하는 플러그인을 자동으로 설치해줍니다. 약간 무거운 느낌이 있긴 하지만 설치가 간단하고 화면을 보는 순간 고오오급 개발자의 포스를 만들어주니 바로 설치해봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;curl &lt;span class=&quot;nt&quot;&gt;-sLf&lt;/span&gt; https://spacevim.org/install.sh | bash
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;설치가 완료되면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vi&lt;/code&gt;를 실행합니다. 최초 실행 시 mode 설정을 물어보고 (잘모르면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;을 누릅니다) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;q&lt;/code&gt;를 눌러 종료했다가 다시 실행하면 자동으로 플러그인을 설치합니다. 플러그인이 많아서 시간이 꽤 걸립니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;테마&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;기본 테마는 뭔가 칙칙한 느낌이 듭니다. snazzy colorscheme를 다운받고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.SpaceVim.d/init.toml&lt;/code&gt; 파일에 설정을 추가합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; ~/.SpaceVim.d/colors
curl https://gist.githubusercontent.com/subicura/91696d2da58ad28b5e8b2877193015e1/raw/6fb5928c9bda2040b3c9561d1e928231dbcc9184/snazzy-custom.vim &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; ~/.SpaceVim.d/colors/snazzy-custom.vim
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;options]
  colorscheme &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;snazzy-custom&quot;&lt;/span&gt;
  enable_guicolors &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true
  &lt;/span&gt;statusline_separator &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;arrow&quot;&lt;/span&gt;
  enable_tabline_filetype_icon &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true
  &lt;/span&gt;enable_statusline_mode &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true
  &lt;/span&gt;statusline_unicode_symbols &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;설정 파일을 수정하고 다시 시작하면 좀 더 나은 화면을 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;폰트&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;vi를 실행하고 폰트가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;?&lt;/code&gt;로 깨져 보인다면 iTerm2에 개발 관련 폰트를 모은 NerdFont를 추가로 설정합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/iterm-font-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;iTerm2를 실행하고 설정(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;⌘&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;,&lt;/code&gt;)창에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Profiles&lt;/code&gt; 항목을 선택하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Text&lt;/code&gt;탭을 선택합니다. Font항목에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Use a different font for non-ASCII text&lt;/code&gt;를 체크하고 MesloLGS NF를 선택하면 폰트가 이쁘게 나옵니다.&lt;/p&gt;

&lt;p&gt;이제 설정이 모두 완료되었으니 vim 공부(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;esc&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:q!&lt;/code&gt;)만 하면 됩니다. :)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://neovim.io/&quot;&gt;neovim 홈페이지&lt;/a&gt; / &lt;a href=&quot;https://github.com/SpaceVim/SpaceVim&quot;&gt;SpaceVim github&lt;/a&gt; / &lt;a href=&quot;http://spacevim.org/documentation/&quot;&gt;SpaceVim 설정문서&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;fzf&quot;&gt;fzf&lt;/h3&gt;

&lt;p&gt;fzf는 강력하고 엄청나게 빠른 fuzzy finder 도구입니다. 증분 검색을 통하여 원하는 파일이나 히스토리를 쉽고 빠르게 찾을 수 있게 해줍니다. 정확하게 원하는 값을 입력하지 않고 일부만 입력해도 실시간으로 검색 결과를 보여줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/fzf-sample-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설치&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;fzf
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;설치가 완료되었으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.zshrc&lt;/code&gt;에 plugin을 추가해줍니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;plugins&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=(&lt;/span&gt;
  ...
  ...
  fzf
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;전부 완료되었으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;source ~/.zshrc&lt;/code&gt;를 입력하여 설정을 다시 불러옵니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;명령어&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;정말 다양하게 사용할 수 있지만 여기선 가장 기본적인 기능만 살펴봅니다.&lt;/p&gt;

&lt;table class=&quot;table table-key-value-60&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;단축키&lt;/th&gt;
      &lt;th&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;⌃&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;하위 디렉토리 파일 검색&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;⌃&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;히스토리 검색&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;esc&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;하위 디렉토리 검색 후 이동&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-11-22-mac-os-development-environment-setup/fzf-demo.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;단축키 입력하고 글자를 몇 개 입력하면 금방 감이 옵니다. 취소는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;esc&lt;/code&gt;입니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/junegunn/fzf&quot;&gt;fzf github&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;fasd&quot;&gt;fasd&lt;/h3&gt;

&lt;p&gt;fasd는 사용빈도가 높은 파일 또는 디렉토리 검색을 편하게 해서 생산성을 향상시켜주는 도구입니다. 열어본 파일이나 이동한 디렉토리를 기억하고 우선순위를 정해서 빠르게 검색할 수 있게 도와줍니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설치&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;fasd
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;설치가 완료되었으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.zshrc&lt;/code&gt;에 plugin을 추가해줍니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;plugins&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=(&lt;/span&gt;
  ...
  ...
  fasd
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;전부 완료되었으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;source ~/.zshrc&lt;/code&gt;를 입력하여 설정을 다시 불러옵니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;명령어&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;명령어를 사용하기 위해서는 일단 디렉토리를 좀 이동하고 파일도 열어보고 해야 합니다. 어느 정도 히스토리가 쌓이면 명령어를 입력해봅니다.&lt;/p&gt;

&lt;table class=&quot;table table-key-value-60&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;단축키&lt;/th&gt;
      &lt;th&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;z&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;디렉토리 이동&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;파일 or 디렉토리 검색&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;디렉토리를 이동할 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;z github&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tab&lt;/code&gt;과 같이 일부 검색어를 입력하고 tab을 눌러서 이동합니다.&lt;/p&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-11-22-mac-os-development-environment-setup/fasd-demo.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;단순한 기능만큼 굉장히 자주, 유용하게 사용하는 도구입니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/clvv/fasd&quot;&gt;fasd github&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;asdf-vm&quot;&gt;asdf vm&lt;/h3&gt;

&lt;p&gt;asdf-vm은 각종 프로그램(nodejs, ruby, python, …)의 버전을 손쉽게 관리해주는 &lt;del&gt;성의 없어 보이는 이름의&lt;/del&gt; 도구입니다. 기존에 nvm, rbenv등 언어, 프로그램별로 달랐던 관리 도구를 하나로 통합해서 사용할 수 있습니다. homebrew도 일부 버전 관리 기능을 제공하지만 asdf만큼 강력하지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설치&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;asdf
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;설치가 완료되었으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.zshrc&lt;/code&gt;에 plugin을 추가해줍니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;plugins&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=(&lt;/span&gt;
  ...
  ...
  asdf
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;전부 완료되었으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;source ~/.zshrc&lt;/code&gt;를 입력하여 설정을 다시 불러옵니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;명령어&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;asdf는 플러그인을 이용하기 때문에 필요한 프로그램을 찾아서 설치해야 합니다.&lt;/p&gt;

&lt;table class=&quot;table table-key-value-60&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;명령어&lt;/th&gt;
      &lt;th&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asdf plugin list&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;설치된 플러그인 목록&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asdf plugin add &amp;lt;name&amp;gt; [&amp;lt;git-ref&amp;gt;]&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;플러그인 설치 ex) asdf plugin add ruby https://github.com/asdf-vm/asdf-ruby.git&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asdf list all &amp;lt;name&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;플러그인 설치 가능한 버전 확인&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asdf install &amp;lt;name&amp;gt; &amp;lt;version&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;플러그인 버전 설치&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asdf local &amp;lt;name&amp;gt; &amp;lt;version&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;현재 경로 기준 버전 사용 설정&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asdf global &amp;lt;name&amp;gt; &amp;lt;version&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;전체 버전 사용 설정&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a href=&quot;https://twitter.com/KrComet/status/1278675880697425920&quot;&gt;@KrComet님 추천&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://asdf-vm.com&quot;&gt;asdf-vm&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;tmux&quot;&gt;tmux&lt;/h3&gt;

&lt;p&gt;tmux는 터미널 멀티플렉서&lt;sub&gt;Terminal MUltipleXer&lt;/sub&gt;라고 합니다. 하나의 화면에서 창을 여러 개 만들 수 있고 가로 분할, 세로 분할 할 수도 있습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;어, 그거 iTerm에서 그냥 되는데요?&lt;/code&gt;라고 말씀하시면 딱히 할말은 없지만&lt;del&gt;반박 불가&lt;/del&gt;.. 알아두면 원격 리눅스 서버 환경에서 유용하게 쓸 수 있고 무엇보다 꽤나 있어보이는 화면을 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설치&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;tmux
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;설치가 완료되었으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.zshrc&lt;/code&gt;에 plugin을 추가해줍니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;plugins&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=(&lt;/span&gt;
  ...
  ...
  tmux
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;테마&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;tmux 역시 기본 테마는 너무 밋밋하기 때문에 &lt;a href=&quot;https://github.com/gpakosz/.tmux&quot;&gt;잘 만들어 놓은 테마&lt;/a&gt;를 가져다 씁니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ~/
git clone https://github.com/gpakosz/.tmux.git
&lt;span class=&quot;nb&quot;&gt;ln&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; .tmux/.tmux.conf
&lt;span class=&quot;nb&quot;&gt;cp&lt;/span&gt; .tmux/.tmux.conf.local .
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;설정&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;예전에는 몰랐는데 요즘 tmux는 놀랍게도 마우스를 지원합니다. 터미널인데 마우스가 됩니다! 하단에 윈도우 탭을 누르면 바로바로 이동하고 분할 창&lt;sub&gt;pane&lt;/sub&gt;도 마우스를 누르는 창으로 포커스됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.tmux/.tmux.conf.local&lt;/code&gt;파일을 열고 맨 밑으로 이동해서 주석으로 되어 있는 설정을 해제해 줍니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# increase history size&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt; history-limit 10000

&lt;span class=&quot;c&quot;&gt;# start with mouse mode enabled&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt; mouse on

&lt;span class=&quot;c&quot;&gt;# force Vi mode&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# really you should export VISUAL or EDITOR environment variable, see manual&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt; status-keys vi
&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt; mode-keys vi
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;사용법&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;tmux는 꽤 사용난이도가 높은 프로그램입니다. 자세한 내용을 여기서 다루기엔 양이 너무 많기 떄문에 따로 공부를 해야하고 여기서는 아주 기본적인 기능 몇 가지만 알아봅니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;세션&lt;sub&gt;session&lt;/sub&gt;&lt;/strong&gt; tmux가 관리하는 가장 큰 단위&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;윈도우&lt;sub&gt;window&lt;/sub&gt;&lt;/strong&gt; 세션안에 존재하는 탭같은 단위&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;팬&lt;sub&gt;pane&lt;/sub&gt;&lt;/strong&gt; 윈도우 안에 가로 세로로 분할한 단위&lt;/li&gt;
&lt;/ul&gt;

&lt;table class=&quot;table table-key-value-60&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;명령어&lt;/th&gt;
      &lt;th&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tmux &lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;세션 생성&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tmux attach&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;생성되어 있는 세션에 진입&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tmux ls&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;세션 목록 확인&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table class=&quot;table table-key-value-60&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;단축키&lt;/th&gt;
      &lt;th&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;⌃&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;새 창 만들기&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;⌃&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;tmux 환경에서 나오기&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;⌃&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;~&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;9&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;해당 창으로 이동&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;⌃&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;세로로 창을 나눔 (좌/우)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;⌃&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;가로로 창을 나눔 (위/아래)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;⌃&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;화살표&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;나뉘어진 창을 좌/우/위/아래로 움직임&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-11-22-mac-os-development-environment-setup/tmux-demo.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;아주 간단하게 살펴보았지만 사실 스크롤, 복사 등등 알아야 할 게 은근 많습니다. &lt;del&gt;안될꺼야..&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/tmux/tmux&quot;&gt;tmux github&lt;/a&gt; / &lt;a href=&quot;https://github.com/gpakosz/.tmux&quot;&gt;Oh My Tmux!&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;tmuxinator&quot;&gt;tmuxinator&lt;/h3&gt;

&lt;p&gt;tmux의 쓸모를 한층 더 높여주는 게 tmuxinator입니다. 단축키로 창을 만들고 화면을 분할하는 것을 설정파일로 해줍니다.&lt;/p&gt;

&lt;p&gt;예를 들면, 1번 윈도우는 webpack을 실행하고 2번 윈도우는 rails server를 실행하고 3번 윈도우는 log를 실행하게 설정할 수 있습니다. 요즘 프로젝트는 복잡하게 구성된 경우가 많아서 굉장히 유용하게 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설치&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;tmuxinator는 ruby로 작성된 프로그램입니다. ruby를 최신 버전으로 업데이트하고 tmuxinator를 설치합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;ruby
gem &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;tmuxinator
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;설치가 완료되었으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.zshrc&lt;/code&gt;에 plugin과 alias를 추가합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;plugins&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=(&lt;/span&gt;
  ...
  ...
  tmuxinator
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;alias &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;mux&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;tmuxinator&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;샘플&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;간단하게 샘플을 하나 만들어 봅니다. 블로그를 작성하는 환경을 만드는데 1번창을 두개로 나눠서 위에는 jekyll을 실행하고 아래는 ngrok으로 서버를 외부로 오픈합니다. 2번 창은 post폴더를 vi로 오픈해보겠습니다.&lt;/p&gt;

&lt;p&gt;tmuxinator를 명령어가 너무 길어서 위에 설정에서 mux로 alias를 설정하였습니다. 새로 tmuxinator 프로젝트를 만들어보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;mux new jekyll
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;명령어를 실행하면 간단한 샘플이 포함된 jekyll 프로젝트 설정 파일이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.config/tmuxinator/jekyll.yml&lt;/code&gt; 만들어지고 자동으로 에디터가 열립니다. 설정 파일을 다음과 같이 작성합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;jekyll&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;~/Workspace/github.com/subicura/subicura.github.io&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;windows&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;layout&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;main-horizontal&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;panes&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;bundle exec jekyll serve --incremental&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ngrok http &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;4000&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;editor&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;vim _posts&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이제 프로젝트를 시작합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;s&quot;&gt;mux start jekyll&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-11-22-mac-os-development-environment-setup/mux-demo.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;샘플이라 약간 억지가 있어 보이는 구성이지만 스크립트 구성이 엄청나게 편하다는걸 알 수 있습니다. 전체 스크립트를 실행하고 intelliJ와 같은 IDE를 실행하게 구성할 수도 있습니다. 자세한 건 공식 홈페이지를 참고하세요.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/tmuxinator/tmuxinator&quot;&gt;tmuxinator github&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;추천-애플리케이션&quot;&gt;추천 애플리케이션&lt;/h2&gt;

&lt;p&gt;기본적인 프로그램 외에 사용하면 꽤 쓸만한 프로그램을 소개합니다.&lt;/p&gt;

&lt;h3 id=&quot;docker&quot;&gt;docker&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/docker-desktop.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;따로 소개할 필요가 없을 정도로 유명한 가상화 프로그램입니다. MySQL, Redis와 같은 데이터베이스나 rails, php 개발환경까지 두루두루 사용하고 있습니다. 하나의 개발 피시에 여러버전의 MySQL이나 Redis를 설치하는 건 쉽지 않은데 docker를 사용하면 쉽고 간단하게 개발환경을 구축할 수 있습니다.&lt;/p&gt;

&lt;p&gt;docker에 대한 자세한 내용은 &lt;a href=&quot;/2017/01/19/docker-guide-for-beginners-1.html&quot;&gt;여기&lt;/a&gt;서 확인하세요.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;brew cask &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;docker
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker 홈페이지&lt;/a&gt; / &lt;a href=&quot;https://www.docker.com/docker-mac&quot;&gt;Docker for mac download&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;tig&quot;&gt;tig&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/tig-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;텍스트모드 git 인터페이스 프로그램입니다. git 자체 기능이 강력하긴 하지만 여러 로그를 편하게 보기는 쉽지 않습니다. tig를 사용하여 화살표 키와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;h&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;j&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l&lt;/code&gt;키를 잘 사용하면 쉽게 로그를 볼 수 있고 메인 화면에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;h&lt;/code&gt;를 누르면 도움말을 확인할 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;tig
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/jonas/tig&quot;&gt;tig github&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;jq&quot;&gt;jq&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/jq-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;JSON 결과를 이쁘게 보여주고 원하는 대로 편집할 수 있는 도구입니다. 간단하게 필터를 적용하여 원하는 항목만 볼 수 있고 특정 결과를 다른 형태로 변경할 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;jq
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://stedolan.github.io/jq/&quot;&gt;jq github&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;bat&quot;&gt;bat&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/bat.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cat&lt;/code&gt;명령어에 코드 하이라이팅 + more 기능이 추가된 버전입니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;bat
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;~/.zshrc에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cat&lt;/code&gt; 대신 사용하도록 설정할 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;alias cat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;bat&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/sharkdp/bat&quot;&gt;bat github&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;openinterminal&quot;&gt;OpenInTerminal&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/open-in-terminal.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;파인더에서 바로 터미널을 열고 싶을 때 클릭한번으로 열 수 있는 유용한 도구 입니다. 프로그램을 설치하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;⌘&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;드래그&lt;/code&gt;로 버튼을 추가할 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;brew cask &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;openinterminal-lite
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Ji4n1ng/OpenInTerminal&quot;&gt;OpenInTerminal github&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;ngrok&quot;&gt;ngrok&lt;/h3&gt;

&lt;p&gt;로컬 서버를 외부로 터널링을 통해 오픈해주는 도구입니다. 보통 로컬에 개발 서버를 띄우면 외부에서 접근하기가 어려운데 ngrok을 이용하여 간단하게 오픈할 수 있습니다. 사용법도 간단합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;brew cask &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;ngrok
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://ngrok.com/&quot;&gt;ngrok 홈페이지&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;asciinema&quot;&gt;asciinema&lt;/h3&gt;

&lt;p&gt;터미널을 &lt;strong&gt;텍스트&lt;/strong&gt;로 녹화하는 프로그램입니다. 영상으로 녹화하는 것보다 용량이 적고 품질도 훌륭한 편입니다. 제 블로그에서 자주 볼 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;asciinema
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://asciinema.org/&quot;&gt;asciinema 홈페이지&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;neofetch&quot;&gt;neofetch&lt;/h3&gt;

&lt;p&gt;지금 보고 있는 포스트 첫번째 이미지에서 사용한 프로그램입니다. 간단하게 시스템 상태를 보여줍니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;neofetch
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/dylanaraps/neofetch&quot;&gt;neofetch github&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;brew-bundle&quot;&gt;brew bundle&lt;/h3&gt;

&lt;p&gt;하나하나 설치하기 귀찮다면 &lt;a href=&quot;https://github.com/Homebrew/homebrew-bundle&quot;&gt;brew bundle&lt;/a&gt; 기능을 이용해보세요!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://twitter.com/posquit0/status/1278708552983441408&quot;&gt;@posquit0님 추천&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;그래서&quot;&gt;그래서&lt;/h2&gt;

&lt;p&gt;너무 오랫동안 블로깅을 못 하고 있어서 가볍게 &lt;del&gt;급하게&lt;/del&gt; 작성한 포스트입니다. 새로 산 맥북프로를 셋팅하고 설치 프로그램 목록을 정리하던 중에 우연찮게 몇몇 분들한테 터미널 설정에 대한 질문을 받으면서 환경설정에 대한 글을 쓰면 괜찮다고 생각했습니다.&lt;/p&gt;

&lt;p&gt;커맨드라인 애플리케이션은 알면 알수록 새로운 것도 많고 개발자들 취향에 따라 설정이 조금씩 다르므로 가장 무난한 설정을 소개했고 대부분의 커스텀 설정은 수정하지 않았습니다. 설정이 굉장히 다양하므로 각 프로그램이 어떤 설정을 제공하는지는 꼭 한 번씩 보면 좋을 것 같습니다.&lt;/p&gt;

&lt;p&gt;최근 개발 모임이나 세미나에 참석해보면 맥북을 사용하시는 분들이 많고 개발자라면 계속해서 터미널을 사용하므로 아직 제대로 개발 환경을 구축하지 못한 분들에게 많은 도움이 되었으면 좋겠습니다. 그리고 괜찮은 도구 있으면 댓글로 추천해주세요! 더 좋은, 편안한 환경에서 개발하고 싶습니다.&lt;/p&gt;

&lt;p&gt;다른 &lt;del&gt;고오오급&lt;/del&gt;개발자들이 어떤 환경에서 작업하는지 궁금하다면 &lt;a href=&quot;https://usesthis.com&quot;&gt;usesthis.com&lt;/a&gt;에 인터뷰가 있으니 참고하시고 커스텀하게 변경한 환경설정 파일은 Dropbox나 Google Drive 등으로 파일을 링크(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ln -s&lt;/code&gt;)하여 백업하거나 &lt;a href=&quot;https://dotfiles.github.io/&quot;&gt;dotfiles&lt;/a&gt; 도구를 사용하여 백업하면 나중에 새로운 맥이 생겨도 동일한 환경을 빠르게 설정할 수 있습니다.&lt;/p&gt;

</description>
        <pubDate>Wed, 22 Nov 2017 00:00:00 +0900</pubDate>
        <link>https://subicura.com/2017/11/22/mac-os-development-environment-setup.html</link>
        <guid isPermaLink="true">https://subicura.com/2017/11/22/mac-os-development-environment-setup.html</guid>
        
        <category>Mac</category>
        
        <category>DevOps</category>
        
        <category>Server</category>
        
        <category>Development</category>
        
        <category>Environment</category>
        
        <category>Terminal</category>
        
        <category>zsh</category>
        
        <category>vi</category>
        
        <category>tmux</category>
        
        
        <category>Tool</category>
        
      </item>
    
      <item>
        <title>Docker Swarm을 이용한 쉽고 빠른 분산 서버 관리</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/docker-swarm.png&quot; alt=&quot;docker swarm&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제가 일하고 있는 퍼플웍스에서는 여러 대의 서버에 다양한 애플리케이션을 설치하여 사용하고 있습니다. &lt;del&gt;아직도 미완성인&lt;/del&gt; &lt;a href=&quot;http://www.purpleworks.co.kr/&quot;&gt;홈페이지&lt;/a&gt; 를 비롯하여 &lt;a href=&quot;https://ko.wikipedia.org/wiki/LDAP&quot;&gt;LDAP&lt;/a&gt;, &lt;a href=&quot;https://about.gitlab.com/&quot;&gt;Gitlab&lt;/a&gt;, &lt;a href=&quot;https://jenkins.io/&quot;&gt;Jenkins&lt;/a&gt;, &lt;a href=&quot;https://docs.docker.com/registry/&quot;&gt;Docker Registry&lt;/a&gt;, &lt;a href=&quot;https://sensuapp.org/&quot;&gt;Sensu&lt;/a&gt;, &lt;a href=&quot;http://grafana.org/&quot;&gt;Grafana&lt;/a&gt;, DB와 같은 업무용 프로그램이 여기저기 설치되어 있고 개발 중인 서비스들의 테스트/스테이징 서버도 여러 대 있습니다.&lt;/p&gt;

&lt;p&gt;많은 서비스를 효율적으로 관리하기 위해 서버마다 역할을 부여하였는데 1번 서버는 CI, 2번 서버는 모니터링, 3번 서버는 웹, 4번 서버는 디비, 5번 서버는 큐 이런 식으로 서비스의 종류에 따라 서버를 구분하였습니다. 이런 방식은 효율적이고 정리가 잘된 것처럼 보였지만 서버가 늘어나고 컨테이너가 추가될 때마다 비효율적이라는 걸 알게 되었습니다.&lt;/p&gt;

&lt;p&gt;서버가 역할에 따라 나뉘어 있었기 때문에 특정 서버에 컨테이너가 몰리는 상황이 발생했고 역할이 모호한 애플리케이션의 경우는 어디에 설치할지 고민되고 설치하고도 찝찝한 경우가 많았습니다. 리소스가 여유 있는 서버로 컨테이너를 옮기고 싶어도 다른 컨테이너와 의존성이 있어 쉽게 못 옮기는 경우도 있고 IP, Port와 같은 설정 파일을 수정하는 것도 문제였습니다. 컨테이너는 굉장히 유연하여 확장이나 이동이 쉬운데 그런 장점을 거의 못 살리고 있었습니다.&lt;/p&gt;

&lt;p&gt;도커덕분에 애플리케이션 설치 자체가 굉장히 편해져 이런 작업은 사소해 보일 수 있지만, 인간의 욕심은 끝이 없고 더욱 격렬하게 아무것도 안 하고 싶기 때문에 컨테이너를 실행할 서버를 고르는 것부터 정보를 관리하는 것까지 모든 과정을 자동화하면 좋겠다는 생각을 했습니다.&lt;/p&gt;

&lt;p&gt;다행히 비슷한 고민을 미리한 고오급 개발자들이 있었고 이러한 작업을 &lt;a href=&quot;https://en.wikipedia.org/wiki/Orchestration_(computing)&quot;&gt;오케스트레이션&lt;/a&gt;&lt;sub&gt;Orchestration&lt;/sub&gt;이라고 합니다.&lt;/p&gt;

&lt;div align=&quot;center&quot; class=&quot;googleads googleads-content&quot;&gt;
                &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-2468713653725581&quot; data-ad-slot=&quot;8649023787&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
            &lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;서버-오케스트레이션-server-orchestration&quot;&gt;서버 오케스트레이션 &lt;sub&gt;server orchestration&lt;/sub&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/container-orchestration.png&quot; alt=&quot;container orchestration&quot; /&gt;&lt;/p&gt;

&lt;p&gt;서버 오케스트레이션이라는 용어는 모호한 의미를 가지고 있습니다. 간단하게 정의하면 &lt;strong&gt;여러 대의 서버와 여러 개의 서비스를 편리하게 관리해주는 작업&lt;/strong&gt;이라고 할 수 있고 실제로는 스케줄링&lt;sub&gt;scheduling&lt;/sub&gt;, 클러스터링&lt;sub&gt;clustering&lt;/sub&gt;, 서비스 디스커버리&lt;sub&gt;service discovery&lt;/sub&gt;, 로깅&lt;sub&gt;logging&lt;/sub&gt;, 모니터링&lt;sub&gt;monitoring&lt;/sub&gt; 같은 일을 합니다.&lt;/p&gt;

&lt;p&gt;그냥 여러 대의 서버를 편하게 관리하고 싶을 뿐인데 새로운 용어가 많이 등장합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;스케줄링&lt;/strong&gt;: 컨테이너를 적당한 서버에 배포해 주는 작업입니다. 툴에 따라서 지원하는 전략이 조금씩 다른데 여러 대의 서버 중 가장 할일 없는 서버에 배포하거나 그냥 차례대로 배포 또는 아예 랜덤하게 배포할 수도 있습니다. 컨테이너 개수를 여러 개로 늘리면 적당히 나눠서 배포하고 서버가 죽으면 실행 중이던 컨테이너를 다른 서버에 띄워주기도 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;클러스터링&lt;/strong&gt;: 여러 개의 서버를 하나의 서버처럼 사용할 수 있습니다. 클러스터에 새로운 서버를 추가할 수도 있고 제거할 수도 있습니다. 작게는 몇 개 안 되는 서버부터 많게는 수천 대의 서버를 하나의 클러스터로 만들 수 있습니다. 여기저기 흩어져 있는 컨테이너도 가상 네트워크를 이용하여 마치 같은 서버에 있는 것처럼 쉽게 통신할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;서비스 디스커버리&lt;/strong&gt;: 말 그대로 서비스를 찾아주는 기능입니다. 클러스터 환경에서 컨테이너는 어느 서버에 생성될지 알 수 없고 다른 서버로 이동할 수도 있습니다. 따라서 컨테이너와 통신을 하기 위해서 어느 서버에서 실행중인지 알아야 하고 컨테이너가 생성되고 중지될 때 어딘가에 IP와 Port같은 정보를 업데이트해줘야 합니다. 키-벨류 스토리지에 정보를 저장할 수도 있고 내부 DNS 서버를 이용할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;로깅, 모니터링&lt;/strong&gt;: 여러 대의 서버를 관리하는 경우 로그와 서버 상태를 한곳에서 관리하는게 편합니다. 툴에서 직접 지원하는 경우도 있고 따로 프로그램을 설치해야 하는 경우도 있습니다. &lt;a href=&quot;https://www.elastic.co/kr/webinars/introduction-elk-stack&quot;&gt;ELK&lt;/a&gt;와 &lt;a href=&quot;https://prometheus.io/&quot;&gt;prometheus&lt;/a&gt;등 다양한 툴이 있습니다.&lt;/p&gt;

&lt;p&gt;오케스트레이션 툴은 서버를 중앙에서 관리하고 많은 것들을 자동화해주기 때문에 여러 대의 서버를 관리한다면 무조건 도입해야 할 굉장히 환상적인 방법이라고 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;하지만, &lt;strong&gt;이렇게 좋은 게 있는지 알면서도 여러 가지 이유로 도입하기 어려운 게 현실&lt;/strong&gt;입니다. &lt;del&gt;시무룩&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;가장 큰 이유는 설치와 관리가 어렵다는 건데 보통 오케스트레이션 툴들은 수백-수천-수만 대의 엄청나게 많은 서버를 관리하기 위한 목적으로 만들어졌습니다. 기본적으로 설치와 관리가 꽤 어려운 편이고 일부 고오오오급 회사들이 아니면 도입하는 비용이 수작업으로 관리하는 비용보다 훨씬 큽니다. 툴에 대해 공부도 많이 해야 하고 뭔가 장애가 생기면 전체 서버에 문제가 생길 수 있어서 도입이 조심스러울 수밖에 없습니다. &lt;del&gt;이거 누가 도입하자고 했어?!&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;이런 상황에서 등장한 도커 스웜은 오케스트레이션 툴은 관리가 어렵고 사용하기 복잡하다는 편견을 완전히 바꿔놓았습니다. &lt;strong&gt;구축 비용이 거의 들지 않고 관리 또한 쉬우며 다양한 기능을 쉽게 제공하고 가볍게 사용&lt;/strong&gt;할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;컨테이너-오케스트레이션-툴-container-orchestration-tool&quot;&gt;컨테이너 오케스트레이션 툴 &lt;sub&gt;Container Orchestration Tool&lt;/sub&gt;&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/orchestration-tools.png&quot; alt=&quot;orchestration tools&quot; /&gt;&lt;/p&gt;

&lt;p&gt;본격적인 스웜 설명에 앞서 다른 컨테이너 오케스트레이션 툴에 대해 살펴보겠습니다. 다양한 툴이 다양한 특징을 가지고 만들어졌으니 가볍게 비교해보면 좋을 것 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;fleet-by-coreos&quot;&gt;fleet by CoreOS&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/coreos/fleet&quot;&gt;링크&lt;/a&gt; / 설치 및 관리 ★★★★★ / 사용법 ★★★★ / 기능 ★&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CoreOS(Container OS)에 기본으로 내장되어 있는 &lt;a href=&quot;https://www.freedesktop.org/wiki/Software/systemd/&quot;&gt;systemd&lt;/a&gt;의 cluster 버전&lt;/li&gt;
  &lt;li&gt;스케줄링 외에 특별한 기능이 없어 전체 서버에 무언가(agent류)를 bootstrap 하는 용도에 적당&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mesos-by-apache&quot;&gt;Mesos by Apache&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://mesos.apache.org/&quot;&gt;링크&lt;/a&gt; / 설치 및 관리 ★★ / 사용법 ★★★ / 기능 ★★★★&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;역사와 전통의 범용적인 클러스터 툴로 Twitter, Airbnb, Apple, Uber등 다양한 곳에서 사용하여 안정성이 검증됨&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zookeeper.apache.org/&quot;&gt;Zookeeper&lt;/a&gt;를 기반으로 여러 대의 서버를 하나의 클러스터로 관리&lt;/li&gt;
  &lt;li&gt;설치와 관리가 어렵고 컨테이너를 사용하기 위해 추가적으로 &lt;a href=&quot;https://github.com/mesosphere/marathon&quot;&gt;Marathon&lt;/a&gt;이라는 프레임워크를 사용함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;kubernetes-by-cloud-native-computing-foundation-with-google&quot;&gt;kubernetes by Cloud Native Computing Foundation (with google)&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/&quot;&gt;링크&lt;/a&gt; / 설치 및 관리 ★★ / 사용법 ★★★ / 기능 ★★★★★&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;15년 동안 쌓인 구글의 노하우로 만든 “Production-Grade Container Orchestration”으로 기능이 매우 매우 훌륭함&lt;/li&gt;
  &lt;li&gt;자체적으로 구축하려면 설치와 관리가 까다롭지만, &lt;a href=&quot;https://cloud.google.com/&quot;&gt;Google Cloud&lt;/a&gt;, &lt;a href=&quot;https://azure.microsoft.com&quot;&gt;Azure&lt;/a&gt;, &lt;a href=&quot;https://coreos.com/tectonic/&quot;&gt;Tectonic&lt;/a&gt;, &lt;a href=&quot;https://www.openshift.com/&quot;&gt;Openshift&lt;/a&gt;같은 플랫폼을 이용하면 조금 편해짐&lt;/li&gt;
  &lt;li&gt;구성 및 개념에 대한 이해가 필요하고 새로운 툴과 사용법을 익히는데 시간이 좀 걸림&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ec2-container-service-ecs-by-aws&quot;&gt;EC2 Container Service (ECS) by AWS&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://aws.amazon.com/ko/ecs/&quot;&gt;링크&lt;/a&gt; / 설치 및 관리 ★★★★★ / 사용법 ★★★★ / 기능 ★★&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AWS를 사용 중이라면 쉽게 사용할 수 있고 개념도 간단함&lt;/li&gt;
  &lt;li&gt;기능이 매우 심플하지만 사실 대부분 시스템에서 복잡한 기능은 필요하지 않으므로 단순한 구성이라면 이 이상 편한툴은 없음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;nomad-by-hashicorp&quot;&gt;Nomad by HashiCorp&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nomadproject.io/&quot;&gt;링크&lt;/a&gt; / 설치 및 관리 ★★★ / 사용법 ★★★★ / 기능 ★★★★&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.vagrantup.com/&quot;&gt;Vagrant&lt;/a&gt;, &lt;a href=&quot;https://www.consul.io/&quot;&gt;Consul&lt;/a&gt;, &lt;a href=&quot;https://www.terraform.io/&quot;&gt;Terraform&lt;/a&gt;, &lt;a href=&quot;https://www.vaultproject.io/&quot;&gt;Vault&lt;/a&gt;등을 만든 DevOps 장인 &lt;a href=&quot;https://www.hashicorp.com/&quot;&gt;HashiCorp&lt;/a&gt;의 제품&lt;/li&gt;
  &lt;li&gt;같은 회사의 Consul과 Vault를 연동해서 사용할 수 있고 기능은 다양하고 좋지만 반대로 공부할 게 많고 관리가 복잡할 수 있다는 뜻&lt;/li&gt;
  &lt;li&gt;도커외에 rkt, java 애플리케이션을 지원하고 커맨드라인 명령어는 직관적이고 매우 이쁘게 동작함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;그외&quot;&gt;그외&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/rancher/cattle&quot;&gt;Cattle&lt;/a&gt; by rancher, &lt;a href=&quot;http://cockpit-project.org/&quot;&gt;Cockpit&lt;/a&gt;  by Redhat, &lt;a href=&quot;https://docs.cloudfoundry.org/concepts/diego/diego-architecture.html&quot;&gt;Diego&lt;/a&gt; by Cloud Foundry, &lt;a href=&quot;https://flynn.io/&quot;&gt;Flynn&lt;/a&gt;등등 다양한 툴이 있고 딱히 안 써봐서 정확한 내용을 모르지만 괜찮을 것 같음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;결론&quot;&gt;결론&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;적당한 규모(수십 대 이내)에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swarm&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;큰 규모의 클러스터에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubernetes&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;AWS에서 단순하게 사용한다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ECS&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;HashiCorp팬이라면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nomad&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;도커-스웜-살펴보기&quot;&gt;도커 스웜 살펴보기&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/swarmnado.gif&quot; alt=&quot;docker swarm mode&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 본격적으로 스웜에 대해 알아보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;도커-스웜의-등장&quot;&gt;도커 스웜의 등장&lt;/h3&gt;

&lt;p&gt;스웜은 도커와 별도로 개발되었지만 도커 1.12 버전부터 스웜 모드&lt;sub&gt;Swarm mode&lt;/sub&gt;라는 이름으로 합쳐졌습니다. 도커에 모오오오오든게 내장되어 다른 툴을 설치할 필요가 없고 도커 명령어와 compose를 그대로 사용할 수 있어 다른 툴에 비해 압도적으로 쉽고 편리합니다.&lt;/p&gt;

&lt;p&gt;기능이 단순하고 필요한 것만 구현되어 있어 세부적인 컨트롤은 어렵습니다. 갑툭튀한 것 같지만 꽤 오랫동안 개발되었고(2015년 1.0버전) 1,000개 노드에 50,000개 컨테이너도 문제없이 테스트하여 안전성이 검증되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;도커-스웜에서-사용하는-용어&quot;&gt;도커 스웜에서 사용하는 용어&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;스웜&lt;sub&gt;swarm&lt;/sub&gt;&lt;/strong&gt;: 직역하면 떼, 군중이라는 뜻을 가지고 있습니다. 도커 1.12버전에서 스웜이 스웜 모드로 바뀌었지만 그냥 스웜이라고도 하는듯 합니다. 스웜 클러스터 자체도 스웜이라고 합니다. (스웜을 만들다. 스웜에 가입하다. = 클러스터를 만들다. 클러스터에 가입하다)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;노드&lt;sub&gt;node&lt;/sub&gt;&lt;/strong&gt;: 스웜 클러스터에 속한 도커 서버의 단위입니다. 보통 한 서버에 하나의 도커데몬만 실행하므로 서버가 곧 노드라고 이해하면 됩니다. 매니저 노드와 워커 노드가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;매니저노드&lt;sub&gt;manager node&lt;/sub&gt;&lt;/strong&gt;: 스웜 클러스터 상태를 관리하는 노드입니다. 매니저 노드는 곧 워커노드가 될 수 있고 스웜 명령어는 매니저 노드에서만 실행됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;워커노드&lt;sub&gt;worker node&lt;/sub&gt;&lt;/strong&gt;: 매니저 노드의 명령을 받아 컨테이너를 생성하고 상태를 체크하는 노드입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;서비스&lt;sub&gt;service&lt;/sub&gt;&lt;/strong&gt;: 기본적인 배포 단위입니다. 하나의 서비스는 하나의 이미지를 기반으로 생성하고 동일한 컨테이너를 한개 이상 실행할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;테스크&lt;sub&gt;task&lt;/sub&gt;&lt;/strong&gt;: 컨테이너 배포 단위입니다. 하나의 서비스는 여러개의 테스크를 실행할 수 있고 각각의 테스크가 컨테이너를 관리합니다.&lt;/p&gt;

&lt;h3 id=&quot;도커-스웜이-제공하는-기능&quot;&gt;도커 스웜이 제공하는 기능&lt;/h3&gt;

&lt;p&gt;Docker 1.13을 기준으로 어떤 기능을 제공하는지 하나하나 살펴봅니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;스케줄링 &lt;sub&gt;scheduling&lt;/sub&gt;&lt;/strong&gt;: 서비스를 만들면 컨테이너를 워커노드에 배포합니다. 현재는 균등하게 배포&lt;sub&gt;spread&lt;/sub&gt;하는 방식만 지원하며 추후 다른 배포 전략이 추가될 예정입니다.
노드에 라벨을 지정하여 특정 노드에만 배포할 수 있고 모든 서버에 한 대씩 배포하는 기능(Global)도 제공합니다. 서비스별로 CPU, Memory 사용량을 미리 설정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;고가용성 &lt;sub&gt;High Available&lt;/sub&gt;&lt;/strong&gt;: &lt;a href=&quot;https://raft.github.io/&quot;&gt;Raft 알고리즘&lt;/a&gt;을 이용하여 여러 개의 매니저노드를 운영할 수 있습니다. 3대를 사용하면 1대가 죽어도 클러스터는 정상적으로 동작하며 매니저 노드를 지정하는 방법은 간단하므로 쉽게 관리할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;멀티 호스트 네트워크 &lt;sub&gt;Multi Host Network&lt;/sub&gt;&lt;/strong&gt;: Overlay network로 불리는 SDN(Software defined networks)를 지원하여 여러 노드에 분산된 컨테이너를 하나의 네트워크로 묶을수 있습니다. 컨테이너마다 독립된 IP가 생기고 서로 다른 노드에 있어도 할당된 IP로 통신할 수 있습니다. (호스트 IP를 몰라도 됩니다!)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;서비스 디스커버리 &lt;sub&gt;Service Discovery&lt;/sub&gt;&lt;/strong&gt;: 서비스 디스커버리를 위한 자체 DNS 서버를 가지고 있습니다. 컨테이너를 생성하면 서비스명과 동일한 도메인을 등록하고 컨테이너가 멈추면 도메인을 제거합니다. 멀티 호스트 네트워크를 사용하면 여러 노드에 분산된 컨테이너가 같은 네트워크로 묶이므로 서비스 이름으로 바로 접근할 수 있습니다. Consul이나 etcd, zookeeper와 같은 외부 서비스를 사용하지 않고 어떠한 추가 작업도 필요 없습니다. 스웜이 알아서 다 해 줍니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;순차적 업데이트 &lt;sub&gt;Rolling Update&lt;/sub&gt;&lt;/strong&gt;: 서비스를 새로운 이미지로 업데이트하는 경우 하나 하나 차례대로 업데이트합니다. 동시에 업데이트하는 작업의 개수와 업데이트 간격 시간을 조정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;상태 체크 &lt;sub&gt;Health Check&lt;/sub&gt;&lt;/strong&gt;: 서비스가 정상적으로 실행되었는지 확인하기 위해 컨테이너 실행 여부 뿐 특정 쉘 스크립크가 정상으로 실행됐는지 여부를 추가로 체크할 수 있습니다. 컨테이너 실행 여부로만 체크할 경우 아직 서버가 실행 되지 않아 접속시 오류가 날 수 있는 미묘한 타이밍을 잡는데 효과적입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;비밀값 저장 &lt;sub&gt;Secret Management&lt;/sub&gt;&lt;/strong&gt;: 비밀번호를 스웜 어딘가에 생성하고 컨테이너에서 읽을 수 있습니다. 비밀 값을 관리하기 위한 외부 서비스를 설치하지 않고 쉽게 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;로깅 &lt;sub&gt;Logging&lt;/sub&gt;&lt;/strong&gt;: 같은 노드에서 실행 중인 컨테이너뿐 아니라 다른 노드에서 실행 중인 서비스의 로그를 한곳에서 볼 수 있습니다. 특정 서비스의 로그를 보려면 어느 노드에서 실행 중인지 알필요도 없고 일일이 접속하지 않아도 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;모니터링 &lt;sub&gt;Monitoring&lt;/sub&gt;&lt;/strong&gt;: 리소스 모니터링 기능은 제공하지 않습니다. 3rd party 서비스(&lt;a href=&quot;https://prometheus.io/&quot;&gt;prometheus&lt;/a&gt;, &lt;a href=&quot;http://grafana.org/&quot;&gt;grafana&lt;/a&gt;)를 사용해야 합니다. 설치는 쉽지만 은근 귀츈…&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;크론, 반복작업 &lt;sub&gt;Cron&lt;/sub&gt;&lt;/strong&gt;: 크론, 반복작업도 알아서 구현해야 합니다. 여러 가지 방식으로 해결할 수 있겠지만 직접 제공하지 않아 아쉬운 부분입니다.&lt;/p&gt;

&lt;h2 id=&quot;스웜실습&quot;&gt;스웜실습&lt;/h2&gt;

&lt;p&gt;본격적으로 스웜 클러스터를 만들고 여러 가지 서비스를 생성해보면서 도커 스웜에 빠져보겠습니다. 전체적인 내용은 다음과 같습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;준비&lt;/li&gt;
  &lt;li&gt;스웜 클러스터 만들기&lt;/li&gt;
  &lt;li&gt;기본 웹 애플리케이션 서비스&lt;/li&gt;
  &lt;li&gt;방문자 수 체크 애플리케이션 (with redis)&lt;/li&gt;
  &lt;li&gt;비밀키 조회 애플리케이션&lt;/li&gt;
  &lt;li&gt;Traefik 리버스 프록시 서버&lt;/li&gt;
  &lt;li&gt;스웜 서버 모니터링&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;준비&quot;&gt;준비&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.vagrantup.com/&quot;&gt;Vagrant&lt;/a&gt;를 이용하여 3개의 &lt;a href=&quot;https://coreos.com/os/docs/latest&quot;&gt;CoreOS(Container Linux)&lt;/a&gt;가상머신을 만듭니다. 각각 1 CPU와 1G Memory를 할당하고 매니저 노드 하나와 워커 노드 2개를 설정하여 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/create-virtual-machine.png&quot; alt=&quot;virtual machines&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;core-01 (manager) / 172.17.8.101 / 1 cpu / 1G memory&lt;/li&gt;
  &lt;li&gt;core-02 (worker) / 172.17.8.102 / 1 cpu / 1G memory&lt;/li&gt;
  &lt;li&gt;core-03 (worker) / 172.17.8.103 / 1 cpu / 1G memory&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Vagrant는 VirtualBox, VMWare, Parallels같은 가상머신을 쉽게 만들고 관리해주는 툴입니다. CoreOS는 도커가 내장된 가벼운 OS입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;가상머신을 만드는 방법은 다음과 같습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;virtual box 설치 &lt;a href=&quot;https://www.virtualbox.org/&quot;&gt;다운로드&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Vagrant 설치 &lt;a href=&quot;https://www.vagrantup.com/downloads.html&quot;&gt;다운로드&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/cogitatio/vagrant-hostsupdater&quot;&gt;vagrant-hostsupdater&lt;/a&gt; plugin 설치 
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vagrant plugin install vagrant-hostsupdater&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;데모 파일 다운로드 &lt;a href=&quot;https://github.com/subicura/docker-swarm-demo&quot;&gt;GitHub - docker swarm demo&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;가상머신 생성
데모 디렉토리에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vagrant up&lt;/code&gt; 명령어 실행 -&amp;gt; 자동으로 생성!&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;가상머신이 정상적으로 생성되었는지 확인하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vagrant status&lt;/code&gt;, 가상머신을 삭제하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vagrant destroy&lt;/code&gt; 를 실행합니다. 가상머신에 접속하는 명령어는  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vagrant ssh [가상머신이름]&lt;/code&gt;입니다.&lt;/p&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-02-25-container-orchestration-with-docker-swarm/vagrant-up.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;vagrant up&lt;/figcaption&gt;&lt;/div&gt;

&lt;h3 id=&quot;스웜-클러스터-만들기&quot;&gt;스웜 클러스터 만들기&lt;/h3&gt;

&lt;p&gt;가상머신이 정상적으로 생성되었으면 스웜 클러스터를 만들어보겠습니다. 스웜 클러스터는 매니저 노드를 먼저 만들고 매니저 노드가 생성한 토큰을 가지고 워커 노드에서 매니저 노드로 접속하면 됩니다.&lt;/p&gt;

&lt;p&gt;먼저, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;core-01&lt;/code&gt;서버를 매니저 노드로 설정합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swarm init&lt;/code&gt;명령어를 사용합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# vagrant ssh core-01&lt;/span&gt;
docker swarm init &lt;span class=&quot;nt&quot;&gt;--advertise-addr&lt;/span&gt; 172.17.8.101
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;Swarm initialized: current node &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;gjm2fxwcx29ha4rfzkw3zskvt&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; is now a manager.

To add a worker to this swarm, run the following &lt;span class=&quot;nb&quot;&gt;command&lt;/span&gt;:

    docker swarm &lt;span class=&quot;nb&quot;&gt;join&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;--token&lt;/span&gt; SWMTKN-1-1la23f7y6y8joqxz27hac4j79yffyixcp15tjtlrnei14wwd1t-5tlmx4q9fm46drjzzd95g1l4q &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    172.17.8.101:2377

To add a manager to this swarm, run &lt;span class=&quot;s1&quot;&gt;'docker swarm join-token manager'&lt;/span&gt; and follow the instructions.
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;순식간에 매니저 노드가 생성되었습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swarm init&lt;/code&gt;명령어를 실행하면 친절하게 워커 노드에서 실행할 명령어를 알려줍니다. &lt;del&gt;친절한도커씨&lt;/del&gt; 명령어를 그대로 복사하여 2, 3번 서버에서 각각 실행합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# vagrant ssh core-02&lt;/span&gt;
docker swarm &lt;span class=&quot;nb&quot;&gt;join&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;--token&lt;/span&gt; SWMTKN-1-1la23f7y6y8joqxz27hac4j79yffyixcp15tjtlrnei14wwd1t-5tlmx4q9fm46drjzzd95g1l4q &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    172.17.8.101:2377
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;This node joined a swarm as a worker.
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;워커 노드가 정상적으로 만들어졌는지 매니저 노드에서 확인합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker node &lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;ID                           HOSTNAME  STATUS  AVAILABILITY  MANAGER STATUS
gjm2fxwcx29ha4rfzkw3zskvt &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;  core-01   Ready   Active        Leader
mu6l92w2dzjmsbucvar1bl9mg    core-03   Ready   Active
q5pa26ik11g9surws03quvrsk    core-02   Ready   Active
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;명령어 3줄로 클러스터가 생성되었습니다. 도커 외에 아무것도 설치하지 않았고 어떤 agent도 실행하지 않았습니다. 이렇게 쉽게 생성되는 클러스터 보셨나요?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;매니저 노드가 관리하는 정보는  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/var/lib/docker/swarm&lt;/code&gt;에 저장됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-02-25-container-orchestration-with-docker-swarm/swarm-cluster.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;init swarm cluster&lt;/figcaption&gt;&lt;/div&gt;

&lt;h3 id=&quot;기본-웹-애플리케이션&quot;&gt;기본 웹 애플리케이션&lt;/h3&gt;

&lt;p&gt;클러스터가 생성되었으니 간단한 웹 애플리케이션 서비스를 생성해보겠습니다.&lt;/p&gt;

&lt;p&gt;서비스를 생성하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;service create&lt;/code&gt;명령어를 이용합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;run&lt;/code&gt;명령어와 아주 유사합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker service create &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;whoami&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 4567:4567 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  subicura/whoami:1
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;beepr6q5kdm724vdvgmb2awxg
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subicura/whoami:1&lt;/code&gt; 이미지는 서버의 hostname을 출력하는 단순한 웹 애플리케이션입니다. 서비스의 이름을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;whoami&lt;/code&gt; 로 지정했고 4567 포트를 오픈하였습니다.&lt;/p&gt;

&lt;p&gt;서비스가 잘 생성되었는지 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;service ls&lt;/code&gt;명령어로 확인해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker service &lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;ID            NAME    MODE        REPLICAS  IMAGE                               
beepr6q5kdm7  &lt;span class=&quot;nb&quot;&gt;whoami  &lt;/span&gt;replicated  0/1       subicura/whoami:1 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;whoami&lt;/code&gt;라는 서비스가 보입니다. 아직 컨테이너가 생성되지 않아 REPLICAS 상태가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0/1&lt;/code&gt;입니다. 좀 더 상세한 상태를 확인하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;service ps&lt;/code&gt;명령어를 입력합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker service ps &lt;span class=&quot;nb&quot;&gt;whoami&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;ID            NAME      IMAGE              NODE     DESIRED STATE  CURRENT STATE            ERROR  PORTS
wnt5m97ci36t  whoami.1  subicura/whoami:1  core-01  Running        Preparing 7 seconds ago
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;서비스의 상태와 어떤 노드에서 실행 중인지를 상세하게 확인할 수 있습니다. 현재 상태가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Preparing&lt;/code&gt;인걸 보니 이미지를 다운 받는 중인 것 같습니다. 조금만 기다리고 컨테이너가 실행되면 상태가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Running&lt;/code&gt;으로 바뀝니다.&lt;/p&gt;

&lt;p&gt;정상적으로 서비스가 실행되었는지 HTTP 요청으로 테스트해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;curl core-01:4567

&lt;span class=&quot;c&quot;&gt;#output&lt;/span&gt;
cfb152786b87
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;와우! 첫번째 서비스를 성공적으로 생성하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;core-01&lt;/code&gt;에서 테스트를 했는데 다른 서버도 테스트해볼까요?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;curl core-02:4567
curl core-03:4567

&lt;span class=&quot;c&quot;&gt;#output&lt;/span&gt;
cfb152786b87
cfb152786b87
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;분명 컨테이너는  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;core-01&lt;/code&gt;노드에서 실행중인데 모든 노드에서 정상적으로 응답하고 있습니다. 어떻게 된일일까요?&lt;/p&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-02-25-container-orchestration-with-docker-swarm/basic-web-application.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;basic web application&lt;/figcaption&gt;&lt;/div&gt;

&lt;h3 id=&quot;ingress-network&quot;&gt;Ingress network&lt;/h3&gt;

&lt;p&gt;도커 스웜은 서비스를 외부에 쉽게 노출하기 위해 모든 노드가 &lt;a href=&quot;https://docs.docker.com/engine/swarm/ingress/&quot;&gt;ingress&lt;/a&gt;라는 가상 네트워크에 속해있습니다. ingress는 routing mesh라는 재미있는 개념을 가지고 있는데 이 개념은 서비스가 포트를 오픈할 경우 모오오든 노드에 포트가 오픈되고 어떤 노드에 요청을 보내도 실행 중인 컨테이너에 자동으로 전달해줍니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Ingress는 (어떤 장소에) 들어감, 입장이라는 뜻을 가지고 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/ingress-network.png&quot; alt=&quot;ingress network&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 예제에서는 4567 포트를 오픈했기 때문에 3개의 노드 전체에 4567 포트가 오픈되었고 어디에서 테스트를 하든 간에 core-01노드에 실행된 컨테이너로 요청이 전달됩니다. 컨테이너가 여러 개라면 내부 로드밸런서를 이용하여 여러 개의 컨테이너로 분산처리됩니다.&lt;/p&gt;

&lt;p&gt;뭔가 어색한 개념이라고 생각할 수 있지만, 어느 서버에 컨테이너가 실행 중인지 알 필요 없이 외부에서 그 어떤 방법보다 쉽게 접근할 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;실제 운영시에는 외부에 nginx 또는 haproxy같은 로드발란서를 두고 전체 스웜 노드를 바라보게 설정할 수 있습니다. &lt;a href=&quot;https://docs.docker.com/engine/swarm/ingress/#/configure-an-external-load-balancer&quot;&gt;관련링크&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;서비스-복제-replication&quot;&gt;서비스 복제 replication&lt;/h3&gt;

&lt;p&gt;앞에서 생성한 웹 애플리케이션에 부하가 발생했다고 가정하고 컨테이너를 5개로 늘려보겠습니다. 노드가 3개인데 컨테이너를 5개로 늘리면 서버 한 개에 2개의 컨테이너가 생성됩니다. 어차피 각각은 독립된 컨테이너이기 때문에 여러 개를 생성해도 상관없고 ingress 네트워크가 알아서 요청을 분산처리해줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/replication.png&quot; alt=&quot;service replication&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;service scale&lt;/code&gt;명령어를 이용하여 서비스 개수를 늘려보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker service scale &lt;span class=&quot;nb&quot;&gt;whoami&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;5
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;whoami &lt;/span&gt;scaled to 5 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;serivice ps&lt;/code&gt;명령어를 이용하여 상태를 확인합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker service ps &lt;span class=&quot;nb&quot;&gt;whoami&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;ID            NAME      IMAGE              NODE     DESIRED STATE  CURRENT STATE            ERROR  PORTS
z5mcfb0lcizi  whoami.1  subicura/whoami:1  core-01  Running        Running 11 minutes ago
nwkduapf1kvk  whoami.2  subicura/whoami:1  core-03  Running        Preparing 4 seconds ago
vhxmipcdht6c  whoami.3  subicura/whoami:1  core-03  Running        Preparing 4 seconds ago
mntns383mnhz  whoami.4  subicura/whoami:1  core-01  Running        Running 4 seconds ago
xga086cubnj3  whoami.5  subicura/whoami:1  core-02  Running        Preparing 4 seconds ago
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;처음 컨테이너를 생성하는 노드에서 이미지를 다운받는동안 Pending인 상태가 보이고 조금 기다리면 모두 실행됩니다. 이제 테스트해볼까요?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;curl core-01:4567
curl core-01:4567
curl core-01:4567
curl core-01:4567
curl core-01:4567
curl core-01:4567

&lt;span class=&quot;c&quot;&gt;#output&lt;/span&gt;
7590556fb196
7d5e26679eb8
a2c04acee702
88498091561a
e970ff9ed9c6
7590556fb196
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;5개의 컨테이너에 아주 이쁘게 요청이 분산되었습니다. 아무런 설정 없이 ingress 네트워크가 알아서 로드 밸런서 역할을 해주고 있습니다. Nginx나 haproxy같은 설정이 필요 없습니다. 너무 편하지 않나요?&lt;/p&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-02-25-container-orchestration-with-docker-swarm/replication.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;replication&lt;/figcaption&gt;&lt;/div&gt;

&lt;h3 id=&quot;healthcheck&quot;&gt;HEALTHCHECK&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/healthcheck.png&quot; alt=&quot;container running status&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스웜은 컨테이너가 실행되면 ingress에서 해당 컨테이너로 요청을 보내기 시작하는데 웹 서버가 부팅되는 동안 문제가 있습니다. 바로 위에 시연 리플레이를 보면 curl 테스트를 하는 도중 에러가 발생하는 걸 확인할 수 있습니다. ingress는 컨테이너가 실행되면 요청을 보내기 때문에 문제가 없을거라고 생각할 수 있지만 컨테이너가 실행되고 웹 서버가 완전히 실행되기 전에 요청을 보내면 서버를 찾을 수 없다는 메시지를 볼 수 있고 이러한 문제를 해결하기 위해 좀 더 자세한 상태 체크 방식이 필요하게 되었습니다.&lt;/p&gt;

&lt;p&gt;도커 1.12버전에서  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HEALTHCHECK&lt;/code&gt;명령어가 추가되었고 쉘 스크립트를 작성하여 좀 더 정확한 상태를 체크 할 수 있습니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;FROM ruby:2.3-alpine
MAINTAINER subicura@subicura.com
COPY Gemfile* /usr/src/app/
WORKDIR /usr/src/app
RUN bundle install
COPY . /usr/src/app
EXPOSE 4567
HEALTHCHECK --interval=10s CMD wget -qO- localhost:4567
CMD bundle exec ruby app.rb -o 0.0.0.0&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/57557d89ebc64005988e260515413b2a.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;아주 익숙한 도커파일샘플에 HEALTHCHECK 명령어를 추가했습니다. HEALTHCHECK 부분을 보면 10초마다 wget을 이용하여 4567 포트를 체크하는 걸 볼 수 있습니다. 스크립트(wget)가 0을 리턴하면 정상이라고 판단하고 그때서야 요청을 보내게 됩니다.&lt;/p&gt;

&lt;p&gt;처음 테스트로 생성한 서비스를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subicura/whoami:2&lt;/code&gt;이미지로 업데이트 해보겠습니다. 버전 1과 차이점은 HEALTHCHECK 유무입니다. HEALTHCHECK 옵션이 없다면 업데이트하는 동안 순간적으로 에러가 발생할 수 있는데 그런 문제를 방지해 줍니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;service update&lt;/code&gt;명령어를 이용하여 서비스를 업데이트합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker service update &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--image&lt;/span&gt; subicura/whoami:2 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;whoami&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;whoami &lt;/span&gt;scaled to 5
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;service ps&lt;/code&gt;명령어로 업데이트 상태를 확인해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker service ps &lt;span class=&quot;nb&quot;&gt;whoami&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;ID            NAME          IMAGE              NODE     DESIRED STATE  CURRENT STATE           ERROR  PORTS
kv2jddl0bsfw  whoami.1      subicura/whoami:2  core-01  Ready          Ready 2 seconds ago
z5mcfb0lcizi   &lt;span class=&quot;se&quot;&gt;\_&lt;/span&gt; whoami.1  subicura/whoami:1  core-01  Shutdown       Running 11 seconds ago
nwkduapf1kvk  whoami.2      subicura/whoami:1  core-03  Running        Running 9 minutes ago
vhxmipcdht6c  whoami.3      subicura/whoami:1  core-03  Running        Running 9 minutes ago
mntns383mnhz  whoami.4      subicura/whoami:1  core-01  Running        Running 11 minutes ago
xga086cubnj3  whoami.5      subicura/whoami:1  core-02  Running        Running 9 minutes ago
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;하나씩 하나씩 이쁘게 업데이트되는 과정을 볼 수 있고 접속 테스트를 하면 문제 없이 업데이트되는걸 확인 할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-02-25-container-orchestration-with-docker-swarm/healthcheck.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;service update&lt;/figcaption&gt;&lt;/div&gt;

&lt;h3 id=&quot;방문자수-체크-웹-애플리케이션&quot;&gt;방문자수 체크 웹 애플리케이션&lt;/h3&gt;

&lt;p&gt;아주아주 간단한 실습에 이어 조금 복잡한 구성을 살펴봅니다. 실제 세상에서는 웹 애플리케이션이 혼자 실행되는 경우가 거의 없죠. redis와 함께 웹 애플리케이션을 실행하고 서버에 접속할 때마다 카운트를 +1 하는 서비스를 만들어 보겠습니다.&lt;/p&gt;

&lt;p&gt;먼저, 웹 애플리케이션과 redis가 통신할 수 있는 오버레이 네트워크를 만듭니다. 오버레이 네트워크를 사용하면 redis는 외부에 포트를 오픈하지 않아도 되고 웹 애플리케이션과 다른 노드에 있어도 같은 서버에 있는 것처럼 통신할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/overlay-network.png&quot; alt=&quot;overlay network&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;network create&lt;/code&gt;명령어로 오버레이 네트워크를 생성합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker network create &lt;span class=&quot;nt&quot;&gt;--attachable&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--driver&lt;/span&gt; overlay &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  backend
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;k7ayhk5hqbxnk8zbb959txh6h  
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;잘 생성되었는지 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;network ls&lt;/code&gt;명령어로 확인해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker network &lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;NETWORK ID          NAME                DRIVER              SCOPE
k7ayhk5hqbxn        backend             overlay             swarm
c420312e4c9b        bridge              bridge              &lt;span class=&quot;nb&quot;&gt;local
&lt;/span&gt;c3ef285ed639        docker_gwbridge     bridge              &lt;span class=&quot;nb&quot;&gt;local
&lt;/span&gt;244840dc44fd        host                host                &lt;span class=&quot;nb&quot;&gt;local
&lt;/span&gt;4biz947vsmez        ingress             overlay             swarm
f41f0c773519        none                null                &lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;backend라는 이름의 오버레이 네트워크가 생성되었습니다. 그 외에 네트워크는 기본으로 생성되는 네트워크들입니다. 이제 redis를 backend네트워크에 생성하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/overlay-network-redis.png&quot; alt=&quot;redis with overlay network&quot; /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker service create &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; redis &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--network&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;backend &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  redis
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;cjqrmjqfvj8zyr7k9skih01g4
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--network&lt;/code&gt; 옵션으로 어느 네트워크에 속할지 정의하였습니다. backend 네트워크에 속한 redis 서비스는 외부 네트워크에서는 접근할 수 없고 backend 네트워크 상에서 원래 포트인 6379로 접속할 수 있습니다.&lt;/p&gt;

&lt;p&gt;redis 서비스가 제대로 생성되었다면 telnet명령어로 테스트해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker run &lt;span class=&quot;nt&quot;&gt;--rm&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--network&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;backend &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  alpine &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  telnet redis 6379

&lt;span class=&quot;c&quot;&gt;# test&lt;/span&gt;
KEYS &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;
SET hello world
GET hello
DEL hello
QUIT
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;외부 네트워크에서는 redis 서버에 접근할 수 없으므로 접속 테스트용 컨테이너를 생성하였습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--network&lt;/code&gt;옵션으로 backend 네트워크에 접속하였고 redis 서비스의 이름이 곧 도메인명이므로 바로 접속할 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;스웜은 서비스가 실행되면 내부 DNS에 자동으로 도메인 정보를 등록합니다. 따로 IP를 관리할 필요 없이 서비스명으로 접근할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이제 방문자 수를 체크하는 웹 애플리케이션 서비스를 생성해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/overlay-network-redis-counter.png&quot; alt=&quot;web application + redis&quot; /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker service create &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; counter &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--network&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;backend &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--replicas&lt;/span&gt; 3 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;REDIS_HOST&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;redis &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 4568:4567 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  subicura/counter
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;nlq75mhritr3hj4tibm8ka9d8
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;redis 서버와 통신해야 하므로 backend 네트워크를 지정했고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--replicas&lt;/code&gt;옵션을 이용하여 3개를 생성하도록 했습니다. 외부의 4568 포트로 접근할 수 있도록 포트를 오픈 했고 redis 서버의 도메인명을 환경변수로 전달했습니다.&lt;/p&gt;

&lt;p&gt;이제 테스트해볼까요?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;curl core-01:4568

&lt;span class=&quot;c&quot;&gt;#output&lt;/span&gt;
50bec9ce8874 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 1

curl core-01:4568

&lt;span class=&quot;c&quot;&gt;#output&lt;/span&gt;
50bec9ce8874 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 1
6705a6272a4a &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 1

curl core-01:4568

&lt;span class=&quot;c&quot;&gt;#output&lt;/span&gt;
50bec9ce8874 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 1
6705a6272a4a &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 1
92b471d0d741 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 1

curl core-01:4568

&lt;span class=&quot;c&quot;&gt;#output&lt;/span&gt;
50bec9ce8874 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 2
6705a6272a4a &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 1
92b471d0d741 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 1

curl core-01:4568

&lt;span class=&quot;c&quot;&gt;#output&lt;/span&gt;
50bec9ce8874 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 2
6705a6272a4a &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 2
92b471d0d741 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 1

curl core-01:4568

&lt;span class=&quot;c&quot;&gt;#output&lt;/span&gt;
50bec9ce8874 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 2
6705a6272a4a &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 2
92b471d0d741 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 2
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;웹 애플리케이션 서버와 redis가 backend오버레이 네트워크를 통해 연결되었고 ingress 네트워크가 3개의 웹 컨테이너에 이쁘게 부하를 분산하였습니다.&lt;/p&gt;

&lt;p&gt;스웜은 서로 통신이 필요한 서비스를 같은 이름의 오버레이 네트워크로 묶고 내부 DNS 서버를 이용하여 접근할 수 있습니다. 여러 개의 네트워크를 쉽게 만들 수 있고 하나의 서비스는 여러 개의 네트워크에 속할 수 있습니다. 모든 것은 스웜이 알아서 하고 관리자는 네트워크와 서비스만 잘 만들면 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;내부 DNS에서 counter의 IP는 10.0.0.4로 3개 컨테이너의 로드 벨런서용 IP를 가리키고 있습니다. 실제 각각의 IP는 tasks.counter의 A Record에 기록되어 있고 10.0.0.5~7을 가지고 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-02-25-container-orchestration-with-docker-swarm/overlay.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;service with overlay&lt;/figcaption&gt;&lt;/div&gt;

&lt;h3 id=&quot;비밀키-조회-애플리케이션&quot;&gt;비밀키 조회 애플리케이션&lt;/h3&gt;

&lt;p&gt;이번에는 1.13에 추가된 비밀키 관리 기능을 이용해보겠습니다. 먼저 비밀키를 생성합니다. 파일 또는 파이프를 이용한 stdin입력만 가능합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;this is my password!&quot;&lt;/span&gt; | docker secret create my-password -
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;8rsw3eu74xea4q2e8mnhuw6lu
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;my-passsword&lt;/code&gt;라는 이름의 비밀키에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;this is my password!&lt;/code&gt;라는 내용을 저장하였습니다. 이제 이 키를 사용할 서비스를 하나 생성하겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker service create &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; secret &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--secret&lt;/span&gt; my-password &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 4569:4567 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;SECRET_PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/run/secrets/my-password &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  subicura/secret
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;nmyk5647bv4mfneafwhpg7o4t
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--secret&lt;/code&gt;옵션으로 어떤 키를 사용할지 지정하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/run/secrest&lt;/code&gt;디렉토리 밑에 키 이름의 파일로 마운트 됩니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subicura/secret&lt;/code&gt; 이미지는 파일의 내용을 출력해주는 웹 애플리케이션으로 4569포트로 오픈하였습니다.&lt;/p&gt;

&lt;p&gt;잘 동작하는지 테스트해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;curl core-01:4569
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;this is my password!
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;아주 잘 동작합니다. 도커를 이용하여 서비스를 구축하면 패스워드 정보를 어떻게 할지 고민일 때가 있는데 아주 유용하게 사용할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-02-25-container-orchestration-with-docker-swarm/secret.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;docker secre&lt;/figcaption&gt;&lt;/div&gt;

&lt;h3 id=&quot;traefik-리버스-프록시-서버&quot;&gt;Traefik 리버스 프록시 서버&lt;/h3&gt;

&lt;p&gt;스웜은 매니저 노드에서 모든 서비스를 관리할 수 있고 서비스가 생성된 것을 체크하면 무언가를 자동화할 수 있습니다. &lt;a href=&quot;https://traefik.io/&quot;&gt;Traefik&lt;/a&gt;은 이러한 아이디어를 이용해 웹 애플리케이션이 생성되면 자동으로 도메인을 만들고 내부 서비스로 연결해줍니다.&lt;/p&gt;

&lt;p&gt;예를 들어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;whoami&lt;/code&gt;라는 서비스를 만들면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;whoami.local.dev&lt;/code&gt;도메인으로 접속할 수 있게 해주고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;counter&lt;/code&gt;라는 서비스를 만들면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;counter.local.dev&lt;/code&gt;도메인으로 접속할 수 있게 해줍니다.&lt;/p&gt;

&lt;p&gt;테스트를 위해 도메인 정보를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/hosts&lt;/code&gt;에 추가합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;172.17.8.101 portainer.local.dev counter.local.dev
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;프록시로 연결하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;frontend&lt;/code&gt;라는 네트워크를 생성합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker network create &lt;span class=&quot;nt&quot;&gt;--driver&lt;/span&gt; overlay frontend
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이제 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;traefik&lt;/code&gt;서비스를 frontend네트워크에 연결합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker service create &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; traefik &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--constraint&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'node.role == manager'&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 80:80 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 8080:8080 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--mount&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;bind&lt;/span&gt;,source&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/var/run/docker.sock,target&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/var/run/docker.sock &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--network&lt;/span&gt; frontend &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  traefik &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--docker&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--docker&lt;/span&gt;.swarmmode &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--docker&lt;/span&gt;.domain&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;local.dev &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--docker&lt;/span&gt;.watch &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--web&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--constraint&lt;/code&gt; 옵션을 이용하여 매니저 노드에서 실행하게 배포를 제한하였습니다. 스웜 서비스 정보를 얻기 위해서는 반드시 매니저 노드에서 실행되어야 합니다. 그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--mount&lt;/code&gt; 옵션을 이용해 호스트의 도커 소켓을 마운트 하였습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run -v&lt;/code&gt; 옵션과 유사한데 service를 만들 때는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--mount&lt;/code&gt; 옵션을 사용합니다. 80포트는 실제 웹 서비스를 제공하기 위해 사용할 포트고 8080은 관리자용 포트입니다.&lt;/p&gt;

&lt;p&gt;관리자 페이지에 접속해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/traefik.png&quot; alt=&quot;traefik dashboard&quot; /&gt;&lt;/p&gt;

&lt;p&gt;뭔가 그럴싸한 관리자 화면이 보입니다. 아직 아무것도 실행하지 않아 휑한 모습입니다. &lt;a href=&quot;http://portainer.io/&quot;&gt;portainer&lt;/a&gt; 웹 애플리케이션을 실행하여 자동으로 연결해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker service create &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; portainer &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--network&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;frontend &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--label&lt;/span&gt; traefik.port&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;9000 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--constraint&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'node.role == manager'&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--mount&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;type=bind,source=/var/run/docker.sock,target=/var/run/docker.sock&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  portainer/portainer
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;traefik과 접속할 수 있도록 frontend네트워크에 연결했고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--label&lt;/code&gt;옵션으로 내부적으로 사용하는 웹 포트를 알려주었습니다. traefik은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;traefik.port&lt;/code&gt;라벨의 값을 읽어 해당 포트로 리버스 프록시를 연결합니다. portainer는 스웜을 관리해주는 툴이기 때문에 매니저 노드에 실행하도록 했습니다.&lt;/p&gt;

&lt;p&gt;서비스 이름을 portainer로 했기 때문에 서비스가 실행되면 traefik서비스가 자동으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;portainer.local.dev&lt;/code&gt;도메인 정보를 생성하고 portainer컨테이너의 9000번 포트로 연결합니다. 서비스를 생성하고 잠시 기다리면 프록시 설정이 자동으로 완료됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/traefik-portainer.png&quot; alt=&quot;traefik dashboard - portainer&quot; /&gt;&lt;/p&gt;

&lt;p&gt;traefik 관리자 화면에 portainer가 등록된 모습이 보입니다! 이제 실제로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;portainer.local.dev&lt;/code&gt;에 접속해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/portainer-1.png&quot; alt=&quot;portainer dashboard&quot; /&gt;
&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/portainer-2.png&quot; alt=&quot;portainer services&quot; /&gt;
&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/portainer-3.png&quot; alt=&quot;portainer swarm&quot; /&gt;&lt;/p&gt;

&lt;p&gt;portainer도 역시 접속 성공입니다! 이제 어떤 서비스도 frontend네트워크를 연결하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;traefik.port&lt;/code&gt; 라벨만 지정하면 자동으로 외부에 노출됩니다. 내친김에 아까 만든 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;counter&lt;/code&gt;서비스도 붙여보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker service &lt;span class=&quot;nb&quot;&gt;rm &lt;/span&gt;counter
docker service create &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; counter &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--network&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;frontend &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--network&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;backend &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--replicas&lt;/span&gt; 3 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--label&lt;/span&gt; traefik.port&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;4567 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;REDIS_HOST&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;redis &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  subicura/counter
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;기존에 생성되어 있던 서비스를 삭제하고 새로운 옵션으로 서비스를 생성하였습니다. frontend와 backend 두개의 네트워크에 모두 속해있고 label을 주어 traefik에서 자동으로 인식할 수 있도록 했습니다. 이제 테스트해볼까요?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;curl counter.local.dev

&lt;span class=&quot;c&quot;&gt;# output&lt;/span&gt;

50bec9ce8874 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 2                                                                
5cbd7ecbb5b8 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 1                                                                
6705a6272a4a &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 2                                                                
92b471d0d741 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 2 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/magic.gif&quot; alt=&quot;this is magic!&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마법과 같은 일이 옵션 몇줄로 일어났습니다. 음.. 스웜 정말 좋지 않나요?&lt;/p&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-02-25-container-orchestration-with-docker-swarm/traefik.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;traefik&lt;/figcaption&gt;&lt;/div&gt;

&lt;h3 id=&quot;스웜-서버-모니터링&quot;&gt;스웜 서버 모니터링&lt;/h3&gt;

&lt;p&gt;스웜은 자체적인 모니터링 서비스를 제공하지 않습니다. 따라서 적당한 툴을 선택하여 직접 운영해야 합니다. &lt;a href=&quot;￼https://prometheus.io/&quot;&gt;prometheus&lt;/a&gt;와 &lt;a href=&quot;￼http://grafana.org/&quot;&gt;grafana&lt;/a&gt;를 이용하면 아주 그럴듯한 모니터링 시스템을 만들 수 있습니다. 게다가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker stack&lt;/code&gt;명령어를 이용하면 여러 개의 서비스를 일일이 생성하지 않고 하나의 docker-compose 설정 파일로 관리할 수 있습니다. 명령어 한 줄로 모든 서버에 정보를 수집하는 서비스를 생성하고 모니터링 툴을 설치할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/grafana.png&quot; alt=&quot;grafana&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스크린샷이 그럴듯해 보이지 않나요? 이부분에 대한 자세한 내용은 prometheus와 더불어 다음 기회에 따로 포스팅하도록 하겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a class=&quot;waiting-post&quot;&gt;[준비중] 도커 스웜과 prometheus를 이용한 서버 모니터링&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;결론-1&quot;&gt;결론&lt;/h2&gt;
&lt;p&gt;도커 스웜의 핵심내용인 노드와 서비스에 대해 알아보았고 ingress 네트워크와 자체 내장된 로드밸런서, DNS 서버를 사용해봤습니다.&lt;/p&gt;

&lt;p&gt;도커 스웜은 어떠한 툴도 추가적으로 설치할 필요 없이 굉장히 간단하고 빠르게 클러스터를 구성할 수 있습니다. 기능적으로 아쉬운 부분이 조금 있지만 작은 규모에서 일반적인 작업을 하기에는 무리가 없습니다. (오토스케일링 같은 기능을 많은 곳에서 쓰진 않겠죠)&lt;/p&gt;

&lt;p&gt;기존에 오케스트레이션 도입을 꺼렸던 많은 소규모 개발팀에서는 스웜이 아주 매력적인 선택이 될 것 같습니다.&lt;/p&gt;

</description>
        <pubDate>Sat, 25 Feb 2017 00:00:00 +0900</pubDate>
        <link>https://subicura.com/2017/02/25/container-orchestration-with-docker-swarm.html</link>
        <guid isPermaLink="true">https://subicura.com/2017/02/25/container-orchestration-with-docker-swarm.html</guid>
        
        <category>Docker</category>
        
        <category>Swarm</category>
        
        <category>DevOps</category>
        
        <category>Server</category>
        
        <category>Container</category>
        
        <category>Cluster</category>
        
        
        <category>Docker</category>
        
      </item>
    
      <item>
        <title>초보를 위한 도커 안내서 - 이미지 만들고 배포하기</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/docker-logo.png&quot; alt=&quot;docker logo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 글은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;초보를 위한 도커 안내서 - 설치부터 배포까지&lt;/code&gt; 시리즈의 마지막 글입니다. 지난 글에서 도커를 설치하고 컨테이너를 실행해 보았으니 이번엔 이미지를 만들고 서버에 배포해보도록 하겠습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/2017/01/19/docker-guide-for-beginners-1.html&quot;&gt;초보를 위한 도커 안내서 - 도커란 무엇인가?&lt;/a&gt; &lt;span class=&quot;series&quot;&gt;SERIES 1/3&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2017/01/19/docker-guide-for-beginners-2.html&quot;&gt;초보를 위한 도커 안내서 - 설치하고 컨테이너 실행하기&lt;/a&gt; &lt;span class=&quot;series&quot;&gt;SERIES 2/3&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;초보를 위한 도커 안내서 - 이미지 만들고 배포하기 ✓&lt;/strong&gt; &lt;span class=&quot;series&quot;&gt;SERIES 3/3&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot; class=&quot;googleads googleads-content&quot;&gt;
                &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-2468713653725581&quot; data-ad-slot=&quot;8649023787&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
            &lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;도커-이미지-만들기&quot;&gt;도커 이미지 만들기&lt;/h2&gt;
&lt;p&gt;도커는 이미지를 만들기 위해 &lt;strong&gt;컨테이너의 상태를 그대로 이미지로 저장&lt;/strong&gt;하는 단순하고 무식(?)한 방법을 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-10-docker-guide-for-beginners-create-image-and-deploy/create-image.png&quot; alt=&quot;create docker image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;예를 들어, 어떤 애플리케이션을 이미지로 만든다면 리눅스만 설치된 컨테이너에 애플리케이션을 설치하고 그 상태를 그대로 이미지로 저장합니다. 가상머신의 스냅샷과 비스므리한 방식입니다.&lt;/p&gt;

&lt;p&gt;이런 과정은 콘솔에서 명령어를 직접 입력하는 것과 별 차이가 없으므로 쉘 스크립트를 잘 알아야 하지만 좋은 샘플이 많이 &lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=dockerfile￼&quot;&gt;공개&lt;/a&gt;되어 있어 잘 몰라도 크게 걱정하지 않아도 됩니다. &lt;del&gt;복붙만세!&lt;/del&gt; 또한 컨테이너의 가벼운 특성과 레이어 개념을 이용하여 생성과 테스트를 빠르게 수행할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이제 &lt;a href=&quot;https://www.ruby-lang.org/ko&quot;&gt;Ruby&lt;/a&gt;로 만들어진 간단한 웹 애플리케이션을 도커라이징&lt;sub&gt;Dockerizing&lt;/sub&gt;(=도커 이미지를 만듦)해보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;sinatra-웹-애플리케이션-샘플&quot;&gt;Sinatra 웹 애플리케이션 샘플&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-10-docker-guide-for-beginners-create-image-and-deploy/sinatra.png&quot; alt=&quot;Sinatra&quot; /&gt;&lt;/p&gt;

&lt;p&gt;일단 웹 애플리케이션 소스코드를 작성해야겠죠. &lt;a href=&quot;http://www.sinatrarb.com/&quot;&gt;Sinatra&lt;/a&gt;라는 가벼운 웹 프레임워크를 사용하기 위해 새로운 폴더를 만들고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Gemfile&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;app.rb&lt;/code&gt;를 만듭니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Gemfile&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'https://rubygems.org'&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;gem&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'sinatra'&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;app.rb&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'sinatra'&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'socket'&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'/'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;Socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;gethostname&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;ruby와 sinatra에 대해 전혀 모르더라도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Gemfile&lt;/code&gt;은 패키지를 관리하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;app.rb&lt;/code&gt;는 호스트명을 출력하는 웹 서버를 만들었다는 걸 예상할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이제 패키지를 설치하고 서버를 실행해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;bundle &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;            &lt;span class=&quot;c&quot;&gt;# install package&lt;/span&gt;
bundle &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;ruby app.rb   &lt;span class=&quot;c&quot;&gt;# Run sinatra&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-02-10-docker-guide-for-beginners-create-image-and-deploy/run-sinatra.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;run-sinatra&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;ruby가 설치되어 있지 않다고요? 도커만 있으면 문제없습니다. 다음 명령어를 실행합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker run &lt;span class=&quot;nt&quot;&gt;--rm&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 4567:4567 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$PWD&lt;/span&gt;:/usr/src/app &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-w&lt;/span&gt; /usr/src/app &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
ruby &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
bash &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;bundle install &amp;amp;&amp;amp; bundle exec ruby app.rb -o 0.0.0.0&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-02-10-docker-guide-for-beginners-create-image-and-deploy/run-docker-sinatra.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;run-docker-sinatra&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;호스트의 디렉토리를 루비가 설치된 컨테이너의 디렉토리에 마운트한다음 그대로 명령어를 실행하면 로컬에 개발 환경을 구축하지 않고 도커 컨테이너를 개발환경으로 사용할 수 있습니다. &lt;del&gt;어으썸!&lt;/del&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;도커를 개발환경으로 사용하면 개발=테스트=운영이 동일한 환경에서 실행되는 놀라운 상황이 펼쳐집니다. 이 부분은 재미있는 내용이 많지만, 주제에서 벗어나므로 이 정도만 언급하고 다음 기회에 더 자세히 알아봅니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;서버가 정상적으로 실행됐으면 웹 브라우저에서 테스트해봅니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://localhost:4567&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-10-docker-guide-for-beginners-create-image-and-deploy/first-test.png&quot; alt=&quot;Browser test&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도커 컨테이너의 호스트명이 보입니다. 소스는 잘 작성한 것 같네요! 이제 도커 이미지를 만들 준비가 완료됐습니다.&lt;/p&gt;

&lt;h3 id=&quot;ruby-application-dockerfile&quot;&gt;Ruby Application Dockerfile&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-10-docker-guide-for-beginners-create-image-and-deploy/dockerfile.png&quot; alt=&quot;Dockerfile&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도커는 이미지를 만들기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;이라는 이미지 빌드용 DSL&lt;sub&gt;Domain Specific Language&lt;/sub&gt; 파일을 사용합니다. 단순 텍스트 파일로 일반적으로 소스와 함께 관리합니다.&lt;/p&gt;

&lt;p&gt;고오급 개발자는 바로 Dockerfile을 만들 수도 있겠지만, 일반 개발자들은 일단 리눅스 서버에서 테스트로 설치해보고 안 되면 될 때까지 삽질하면서 최적의 과정을 Dockerfile로 작성해야 합니다. 우리는 초보니까 Ruby 웹 애플리케이션을 ubuntu에 배포하는 과정을 먼저 살펴보겠습니다.&lt;/p&gt;

&lt;table class=&quot;table table-key-value-60&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;순서&lt;/th&gt;
      &lt;th&gt;작업&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;ubuntu 설치&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;ruby  설치&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;소스 복사&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;Gem 패키지 설치&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;Sinatra 서버 실행&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이 과정을 그대로 쉘 스크립트로 옮겨봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# 1. ubuntu 설치 (패키지 업데이트)&lt;/span&gt;
apt-get update

&lt;span class=&quot;c&quot;&gt;# 2. ruby 설치&lt;/span&gt;
apt-get &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;ruby
gem &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;bundler

&lt;span class=&quot;c&quot;&gt;# 3. 소스 복사&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; /usr/src/app
scp Gemfile app.rb root@ubuntu:/usr/src/app  &lt;span class=&quot;c&quot;&gt;# From host&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 4. Gem 패키지 설치&lt;/span&gt;
bundle &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 5. Sinatra 서버 실행&lt;/span&gt;
bundle &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;ruby app.rb
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;ubuntu 컨테이너를 실행하고 위 명령어를 그대로 실행하면 웹 서버를 실행할 수 있습니다. 리눅스에서 테스트가 끝났으니 이 과정을 Dockerfile로 만들면 됩니다. 아직 자세한 명령어를 배우진 않았지만 일단 만들어 봅니다. 핵심 명령어는  파일을  복사하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COPY&lt;/code&gt;와 명령어를 실행하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RUN&lt;/code&gt;입니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;# 1. ubuntu 설치 (패키지 업데이트 + 만든사람 표시)
FROM       ubuntu:16.04
MAINTAINER subicura@subicura.com
RUN        apt-get -y update

# 2. ruby 설치
RUN apt-get -y install ruby
RUN gem install bundler

# 3. 소스 복사
COPY . /usr/src/app

# 4. Gem 패키지 설치 (실행 디렉토리 설정)
WORKDIR /usr/src/app
RUN     bundle install

# 5. Sinatra 서버 실행 (Listen 포트 정의)
EXPOSE 4567
CMD    bundle exec ruby app.rb -o 0.0.0.0&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/f3f9d9b67dc59da9bad9afe76caba824.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;쉘 스크립트의 내용을 거어어어어의 그대로 Dockerfile로 옮겼습니다. 차이점은 도커 빌드 중엔 키보드를 입력할 수 없기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(y/n)&lt;/code&gt;을 물어보는 걸 방지하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-y&lt;/code&gt; 옵션을 추가한 것 정도입니다.&lt;/p&gt;

&lt;p&gt;빌드 파일을 작성했으니 이제 이미지를 만들어 봅니다.&lt;/p&gt;

&lt;h3 id=&quot;docker-build&quot;&gt;Docker build&lt;/h3&gt;

&lt;p&gt;이미지를 빌드하는 명령어는 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker build [OPTIONS] PATH | URL | -&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;생성할 이미지 이름을 지정하기 위한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-t(--tag)&lt;/code&gt; 옵션만 알면 빌드가 가능합니다.&lt;/p&gt;

&lt;p&gt;Dockerfile을 만든 디렉토리로 이동하여 다음 명령어를 입력합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker build &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; app .
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;Sending build context to Docker daemon 22.02 kB
Step 1/10 : FROM ubuntu:16.04
 ---&amp;gt; f49eec89601e
Step 2/10 : MAINTAINER subicura@subicura.com
 ---&amp;gt; Running in 06f20ac1017d
 ---&amp;gt; fc41cd8ac52d
Removing intermediate container 06f20ac1017d
Step 3/10 : RUN apt-get -y update
 ---&amp;gt; Running in c35738e75a51
Get:1 http://archive.ubuntu.com/ubuntu xenial InRelease [247 kB]
Get:2 http://archive.ubuntu.com/ubuntu xenial-updates InRelease [102 kB]
Get:3 http://archive.ubuntu.com/ubuntu xenial-security InRelease [102 kB]
Get:4 http://archive.ubuntu.com/ubuntu xenial/main Sources [1103 kB]
Get:5 http://archive.ubuntu.com/ubuntu xenial/restricted Sources [5179 B]

... 생략 ...

Step 9/10 : EXPOSE 4567
 ---&amp;gt; Running in 9c514a1f0c8e
 ---&amp;gt; c5ce4376282e
Removing intermediate container 9c514a1f0c8e
Step 10/10 : CMD bundle exec ruby app.rb -o 0.0.0.0
 ---&amp;gt; Running in 1f7a9ba8d63c
 ---&amp;gt; 54d239c00f11
Removing intermediate container 1f7a9ba8d63c
Successfully built 54d239c00f11
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-02-10-docker-guide-for-beginners-create-image-and-deploy/docker-build.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;docker-build&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;빌드 명령어를 실행하면 Dockerfile에 정의한 내용이 한 줄 한 줄 실행되는 걸 볼 수 있습니다. 실제로 명령어를 실행하기 때문에 빌드 시간이 꽤 걸리는 걸 알 수 있습니다. 최종적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Successfully built xxxxxxxx&lt;/code&gt; 메시지가 보이면 정상적으로 이미지를 생성한 것입니다.&lt;/p&gt;

&lt;p&gt;그럼 이미지가 잘 생성되었는지 확인해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker images
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
app                 latest              54d239c00f11        4 minutes ago       209 MB
ubuntu              16.04               f49eec89601e        2 weeks ago         129 MB
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;와..와우! 드디어 첫 번째 도커 이미지를 생성했습니다! 이미지를 생성했으니 잘 동작하는지 컨테이너를 실행해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker run -d -p 8080:4567 app
docker run -d -p 8081:4567 app
docker run -d -p 8082:4567 app
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-10-docker-guide-for-beginners-create-image-and-deploy/container-test.png&quot; alt=&quot;Container test result&quot; /&gt;&lt;/p&gt;

&lt;p&gt;접속 성공입니다. 기분이 좋아서 호스트 네임을 출력하는 &lt;del&gt;무쓸모&lt;/del&gt; 웹서버를 3개나 만들었습니다. 이미지가 잘 만들어졌네요.&lt;/p&gt;

&lt;h3 id=&quot;dockerfile-기본-명령어&quot;&gt;Dockerfile 기본 명령어&lt;/h3&gt;

&lt;p&gt;이미지를 만드는 데 사용한 Dockerfile의 기본적인 명령어를 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FROM&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FROM &amp;lt;image&amp;gt;:&amp;lt;tag&amp;gt;
FROM ubuntu:16.04
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;베이스 이미지를 지정합니다. 반드시 지정해야 하며 어떤 이미지도 베이스 이미지가 될 수 있습니다. tag는 될 수 있으면 latest(기본값)보다 구체적인 버전(16.04등)을 지정하는 것이 좋습니다.
이미 만들어진 다양한 베이스 이미지는 &lt;a href=&quot;https://hub.docker.com/explore/&quot;&gt;Docker hub&lt;/a&gt;에서 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MAINTAINER&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MAINTAINER &amp;lt;name&amp;gt;
MAINTAINER subicura@subicura.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Dockerfile을 관리하는 사람의 이름 또는 이메일 정보를 적습니다. 빌드에 딱히 영향을 주지는 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;COPY&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;COPY &amp;lt;src&amp;gt;... &amp;lt;dest&amp;gt;
COPY . /usr/src/app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;파일이나 디렉토리를 이미지로 복사합니다. 일반적으로 소스를 복사하는 데 사용합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;target&lt;/code&gt;디렉토리가 없다면 자동으로 생성합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ADD&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ADD &amp;lt;src&amp;gt;... &amp;lt;dest&amp;gt;
ADD . /usr/src/app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COPY&lt;/code&gt;명령어와 매우 유사하나 몇가지 추가 기능이 있습니다.  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;src&lt;/code&gt;에 파일 대신 URL을 입력할 수 있고  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;src&lt;/code&gt;에 압축 파일을 입력하는 경우 자동으로 압축을 해제하면서 복사됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RUN&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;RUN &amp;lt;command&amp;gt;
RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]
RUN bundle install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;가장 많이 사용하는 구문입니다. 명령어를 그대로 실행합니다. 내부적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/bin/sh -c&lt;/code&gt; 뒤에 명령어를 실행하는 방식입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CMD&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]
CMD command param1 param2
CMD bundle exec ruby app.rb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;도커 컨테이너가 실행되었을 때 실행되는 명령어를 정의합니다. 빌드할 때는 실행되지 않으며 여러 개의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CMD&lt;/code&gt;가 존재할 경우 가장 마지막 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CMD&lt;/code&gt;만 실행됩니다. 한꺼번에 여러 개의 프로그램을 실행하고 싶은 경우에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;run.sh&lt;/code&gt;파일을 작성하여 데몬으로 실행하거나 &lt;a href=&quot;http://supervisord.org/&quot;&gt;supervisord&lt;/a&gt;나 &lt;a href=&quot;https://github.com/ddollar/forego&quot;&gt;forego&lt;/a&gt;와 같은 여러 개의 프로그램을 실행하는 프로그램을 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WORKDIR&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;WORKDIR /path/to/workdir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;RUN, CMD, ADD, COPY등이 이루어질 기본 디렉토리를 설정합니다. 각 명령어의 현재 디렉토리는 한 줄 한 줄마다 초기화되기 때문에  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RUN cd /path&lt;/code&gt;를 하더라도 다음 명령어에선 다시 위치가 초기화 됩니다. 같은 디렉토리에서 계속 작업하기 위해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WORKDIR&lt;/code&gt;을 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;EXPOSE&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;EXPOSE &amp;lt;port&amp;gt; [&amp;lt;port&amp;gt;...]
EXPOSE 4567
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;도커 컨테이너가 실행되었을 때 요청을 기다리고 있는(Listen) 포트를 지정합니다. 여러개의 포트를 지정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;VOLUME&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;VOLUME [&quot;/data&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;컨테이너 외부에 파일시스템을 마운트 할 때 사용합니다. 반드시 지정하지 않아도 마운트 할 수 있지만, 기본적으로 지정하는 것이 좋습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ENV&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ENV &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;
ENV &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; ...
ENV DB_URL mysql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;컨테이너에서 사용할 환경변수를 지정합니다. 컨테이너를 실행할 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-e&lt;/code&gt;옵션을 사용하면 기존 값을 오버라이딩 하게 됩니다.&lt;/p&gt;

&lt;p&gt;여기까지 Dockerfile에서 가장 많이 사용하는 명령어에 대해 알아보았습니다. 모든 명령어가 궁금하신 분은 &lt;a href=&quot;https://docs.docker.com/engine/reference/builder/&quot;&gt;공식문서&lt;/a&gt;를 참고하세요.&lt;/p&gt;

&lt;h3 id=&quot;build-분석&quot;&gt;Build 분석&lt;/h3&gt;

&lt;p&gt;도커는 Dockerfile을 가지고 무슨 일을 하는 걸까요? 빌드를 하면서 궁금하지 않으셨나요? 궁금하지 않으셨더라도 build로그를 보면서 하나하나 살펴봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;Sending build context to Docker daemon  5.12 kB   &amp;lt;&lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
Step 1/10 : FROM ubuntu:16.04                     &amp;lt;&lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; f49eec89601e                                &amp;lt;&lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;3&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
Step 2/10 : MAINTAINER subicura@subicura.com      &amp;lt;&lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;4&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; Running &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;f4de0c750abb                     &amp;lt;&lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;5&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 4a400609ff73                                &amp;lt;&lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;6&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
Removing intermediate container f4de0c750abb      &amp;lt;&lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;7&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
Step 3/10 : RUN apt-get &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; update                 &amp;lt;&lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;8&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
...
...
Successfully built 20369cef9829                   &amp;lt;&lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;9&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(1) Sending build context to Docker daemon  5.12 kB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;빌드 명령어를 실행한 디렉토리의 파일들을 빌드컨텍스트&lt;sub&gt;build context&lt;/sub&gt;라고 하고 이 파일들을 도커 서버(daemon)로 전송합니다. 도커는 서버-클라이언트 구조이므로 도커 서버가 작업하려면 미리 파일을 전송해야 합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(2) Step 1/10 : FROM ubuntu:16.04
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Dockerfile을 한 줄 한 줄 수행합니다. 첫 번째로 FROM 명령어를 수행합니다. ubuntu:16.04 이미지를 다운받는 작업입니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(3) ---&amp;gt; f49eec89601e
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;명령어 수행 결과를 이미지로 저장합니다. 여기서는 ubuntu:16.04를 사용하기로 했기 때문에 ubuntu 이미지의 ID가 표시됩니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(4) Step 2/10 : MAINTAINER subicura@subicura.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Dockerfile의 두 번째 명령어인 MAINTAINER 명령어를 수행합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(5) ---&amp;gt; Running in f4de0c750abb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;명령어를 수행하기 위해 바로 이전에 생성된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f49eec89601e&lt;/code&gt; 이미지를 기반으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f4de0c750abb&lt;/code&gt;컨테이너를 임시로 생성하여 실행합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(6) ---&amp;gt; 4a400609ff73
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;명령어 수행 결과를 이미지로 저장합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(7) Removing intermediate container f4de0c750abb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;명령어를 수행하기 위해 임시로 만들었던 컨테이너를 제거합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(8) Step 3/10 : RUN apt-get -y update
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Dockerfile의 세 번째 명령어를 수행합니다. 이전 단계와 마찬가지로 바로 전에 만들어진 이미지를 기반으로 임시 컨테이너를 만들어 명령어를 실행하고 그 결과 상태를 이미지로 만듭니다. 이 과정을 마지막 줄까지 무한 반복합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(9) Successfully built 20369cef9829
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;최종 성공한 이미지 ID를 출력합니다.&lt;/p&gt;

&lt;p&gt;결론적으로 도커 빌드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;임시 컨테이너 생성&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;명령어 수행&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이미지로 저장&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;임시 컨테이너 삭제&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;새로 만든 이미지 기반 임시 컨테이너 생성&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;명령어 수행&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이미지로 저장&lt;/code&gt; &amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;임시 컨테이너 삭제&lt;/code&gt; &amp;gt; … 의 과정을 계속해서 반복한다고 볼 수 있습니다. 명령어를 실행할 때마다 이미지 레이어를 저장하고 다시 빌드할 때 Dockerfile이 변경되지 않았다면 기존에 저장된 이미지를 그대로 캐시처럼 사용합니다.&lt;/p&gt;

&lt;p&gt;이러한 레이어 개념을 잘 이해하고 있어야 최적화된 이미지를 생성할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;도커-이미지-리팩토링&quot;&gt;도커 이미지 리팩토링&lt;/h3&gt;

&lt;p&gt;사실 앞에서 만든 이미지는 몇 가지 최적화 문제가 있습니다. 다시 한땀 한땀 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Base Image&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;위에서 만든 Ruby 애플리케이션 이미지는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ubuntu&lt;/code&gt;를 베이스로 만들었지만 사실 훠어어얼씬 간단한  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ruby&lt;/code&gt; 베이스 이미지가 존재합니다. &lt;del&gt;미리 이야기하지 않아 죄송..&lt;/del&gt; 기존에 ruby를 설치했던 명령어는 ruby 이미지를 사용하는 것으로 간단하게 생략할 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# before&lt;/span&gt;
FROM ubuntu:16.04
MAINTAINER subicura@subicura.com
RUN apt-get &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; update
RUN apt-get &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;ruby
RUN gem &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;bundler

&lt;span class=&quot;c&quot;&gt;# after&lt;/span&gt;
FROM ruby:2.3
MAINTAINER subicura@subicura.com
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;ruby외에도 nodejs, python, java, go등 다양한 베이스 이미지가 이미 존재합니다. 세부적인 설정이 필요하지 않다면 그대로 사용하는게 간편합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Build Cache&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;조금전에 빌드한 이미지를 다시 빌드해볼까요?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;Sending build context to Docker daemon 13.31 kB
Step 1/10 : FROM ubuntu:16.04
 &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; f49eec89601e
Step 2/10 : MAINTAINER subicura@subicura.com
 &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; Using cache
 &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; fc41cd8ac52d
Step 3/10 : RUN apt-get &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; update
 &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; Using cache
 &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 61d45ce11dc6
 ....
 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;한번 빌드한 이미지를 다시 빌드하면 굉장히 빠르게 완료되는 걸 알 수 있습니다. 이미지를 빌드하는 과정에서 각 단계를 이미지 레이어로 저장하고 다음 빌드에서 캐시로 사용합니다.&lt;/p&gt;

&lt;p&gt;도커는 빌드할 때 Dockerfile의 명령어가 수정되었거나 추가하는 파일이 변경 되었을 때 캐시가 깨지고 그 이후 작업은 새로 이미지를 만들게 됩니다. ruby gem 패키지를 설치하는 과정은 꽤 많은 시간이 소요되는데 최대한 캐시를 이용하여 빌드 시간을 줄여야 합니다.&lt;/p&gt;

&lt;p&gt;기존 소스에서 소스파일이 수정되면 캐시가 깨지는 부분은 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;COPY &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; /usr/src/app    &lt;span class=&quot;c&quot;&gt;# &amp;lt;- 소스파일이 변경되면 캐시가 깨짐&lt;/span&gt;
WORKDIR /usr/src/app
RUN bundle &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;     &lt;span class=&quot;c&quot;&gt;# 패키지를 추가하지 않았는데 또 인스톨하게 됨 ㅠㅠ&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;복사하는 파일이 이전과 다르면 캐시를 사용하지 않고 그 이후 명령어는 다시 실행됩니다. ruby gem 패키지를 관리하는 파일은 Gemfile이고 Gemfile은 잘 수정되지 않으므로 다음과 같이 순서를 바꿀 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;COPY Gemfile&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; /usr/src/app/ &lt;span class=&quot;c&quot;&gt;# Gemfile을 먼저 복사함&lt;/span&gt;
WORKDIR /usr/src/app
RUN bundle &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;# 패키지 인스톨&lt;/span&gt;
COPY &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; /usr/src/app         &lt;span class=&quot;c&quot;&gt;# &amp;lt;- 소스가 바꼈을 때 캐시가 깨지는 시점 ^0^&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;gem 설치 하는 부분을 소스 복사 이전으로 옮겼습니다. 이제 소스가 수정되더라도 매번 gem을 설치하지 않아 더욱 빠르게 빌드할 수 있습니다. 요즘 언어들은 대부분 패키지 매니저를 사용하므로 비슷한 전략으로 작성하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;명령어 최적화&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이미지를 빌드할 때 불필요한 로그는 무시하는게 좋고 패키지 설치시 문서 파일도 생성할 필요가 없습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# before&lt;/span&gt;
RUN apt-get &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; update

&lt;span class=&quot;c&quot;&gt;# after&lt;/span&gt;
RUN apt-get &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-qq&lt;/span&gt; update
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-qq&lt;/code&gt; 옵션으로 로그를 출력하지 않게 했습니다. 각종 리눅스 명령어는 보통 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;quite&lt;/code&gt; 옵션이 있으니 적절하게 적용하면 됩니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# before&lt;/span&gt;
RUN bundle &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# after&lt;/span&gt;
RUN bundle &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--no-rdoc&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--no-ri&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--no-doc&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--no-ri&lt;/code&gt; 옵션으로 필요 없는 문서를 생성하지 않아 이미지 용량도 줄이고 빌드 속도도 더 빠르게 했습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이쁘게&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;명령어는 비슷한 것끼리 묶어 주는 게 보기도 좋고 레이어 수를 줄이는데 도움이 됩니다. 도커 이미지는 스토리지 엔진에 따라 레이어의 개수가 127개로 제한되어 있는 경우도 있어 너무 많은 명령어는 좋지 않습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# before&lt;/span&gt;
RUN apt-get &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-qq&lt;/span&gt; update
RUN apt-get &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-qq&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;ruby

&lt;span class=&quot;c&quot;&gt;# after&lt;/span&gt;
RUN apt-get &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-qq&lt;/span&gt; update &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    apt-get &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-qq&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;ruby
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;최종&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;최종 결과는 다음과 같습니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;FROM ruby:2.3
MAINTAINER subicura@subicura.com
COPY Gemfile* /usr/src/app/
WORKDIR /usr/src/app
RUN bundle install --no-rdoc --no-ri
COPY . /usr/src/app
EXPOSE 4567
CMD bundle exec ruby app.rb -o 0.0.0.0&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/877bced4293c68769302141f51e4b766.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;드디어 아까보다 훨씬 나은 이미지가 완성됐습니다. &lt;del&gt;만세&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;이 외에도 다양한 이미지 생성팁이 있지만 일단 이 정도면 꽤 이쁘게 만들어진 것 같습니다.&lt;/p&gt;

&lt;h2 id=&quot;이미지-저장소&quot;&gt;이미지 저장소&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-10-docker-guide-for-beginners-create-image-and-deploy/docker-registry.png&quot; alt=&quot;Docker Registry&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도커는 빌드한 이미지를 서버에 배포하기 위해 직접 파일을 복사하는 방법 대신 &lt;a href=&quot;https://docs.docker.com/registry/&quot;&gt;도커 레지스트리&lt;/a&gt;&lt;sub&gt;Docker Registry&lt;/sub&gt;라는 이미지 저장소를 사용합니다. 도커 명령어를 이용하여 이미지를 레지스트리에 푸시&lt;sub&gt;push&lt;/sub&gt;하고 다른 서버에서 풀&lt;sub&gt;pull&lt;/sub&gt;받아 사용하는 구조입니다. &lt;del&gt;git을 사용하는 느낌?&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;도커 레지스트리는  &lt;a href=&quot;https://github.com/docker/distribution&quot;&gt;오픈소스&lt;/a&gt;로 무료로 설치할 수 있고 설치형이 싫다면 도커(Docker Inc.)에서 서비스 중인 &lt;a href=&quot;https://hub.docker.com/&quot;&gt;도커 허브&lt;/a&gt;&lt;sub&gt;Docker Hub&lt;/sub&gt;를 사용할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;docker-hub&quot;&gt;Docker Hub&lt;/h3&gt;

&lt;p&gt;도커 허브는 도커에서 제공하는 기본 이미지 저장소로 ubuntu, centos, debian등의 베이스 이미지와 ruby, golang, java, python 등의 공식 이미지가 저장되어 있습니다. 일반 사용자들이 만든 이미지도 50만 개가 넘게 저장되어 있고 다운로드 횟수는 80억 회를 넘습니다.&lt;/p&gt;

&lt;p&gt;회원가입만 하면 대용량의 이미지를 무료로 저장할 수 있고 다운로드 트래픽 또한 무료입니다. 단, 기본적으로 모든 이미지는 공개되어 누구나 접근 가능하므로 비공개로 사용하려면 유료 서비스를 이용해야 합니다. (한 개는 무료)&lt;/p&gt;

&lt;p&gt;회원가입을 하고 앞에서 만든 Ruby 웹 애플리케이션 이미지를 저장해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;회원가입&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-10-docker-guide-for-beginners-create-image-and-deploy/docker-hub.png&quot; alt=&quot;Docker Hub&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://hub.docker.com/&quot;&gt;도커 허브&lt;/a&gt;사이트에 접속하면 쉽게 회원가입을 할 수 있습니다. 디자인이 참 마음에 들지 않는데… 처음부터 지금까지 업데이트한 모습이 이 모양이라 앞으로도 크게 기대되지 않습니다. &lt;del&gt;다른 페이지는 다 이쁜데 ㅠㅠ&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;로그인&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;도커에서 도커 허브 계정을 사용하려면 로그인을 해야합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker login
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;Login with your Docker ID to push and pull images from Docker Hub. If you don&lt;span class=&quot;s1&quot;&gt;'t have a Docker ID, head over to https://hub.docker.com to create one.
Username: subicura
Password:
Login Succeeded&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;ID와 패스워드를 입력하면 로그인이 되고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.docker/config.json&lt;/code&gt;에 인증정보가 저장되어 로그아웃하기 전까지 로그인 정보가 유지됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이미지 태그&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;도커 이미지 이름은 다음과 같은 형태로 구성됩니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;[Registry URL]/[사용자 ID]/[이미지명]:[tag]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Registry URL은 기본적으로 도커 허브를 바라보고 있고 사용자 ID를 지정하지 않으면 기본값(library)을 사용합니다. 따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ubuntu&lt;/code&gt; = &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;library/ubuntu&lt;/code&gt; = &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker.io/library/ubuntu&lt;/code&gt; 는 모두 동일한 표현입니다.&lt;/p&gt;

&lt;p&gt;도커의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tag&lt;/code&gt;명령어를 이용하여 기존에 만든 이미지에 추가로 이름을 지어줄 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;앞에서 만든 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;app&lt;/code&gt;이미지에 계정정보와 버전 정보를 추가해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker tag app subicura/sinatra-app:1
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subicura&lt;/code&gt;라는 ID를 사용하고 이미지 이름을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sinatra-app&lt;/code&gt;으로 변경했습니다. 첫 번째 버전이므로 태그는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;을 사용합니다. 이제  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push&lt;/code&gt;명령을 이용해 도커 허브에 이미지를 전송해 봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker push subicura/sinatra-app:1
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;The push refers to a repository &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;docker.io/subicura/sinatra-app]
2adeabae7edc: Pushed
8343e5bcf528: Pushed
af3b68c8b565: Pushed
40dd6783317f: Pushed
c6ae77e29c22: Pushed
5eb5bd4c5014: Mounted from library/ubuntu
d195a7a18c70: Mounted from library/ubuntu
af605e724c5a: Mounted from library/ubuntu
59f161c3069d: Mounted from library/ubuntu
4f03495a4d7d: Mounted from library/ubuntu
1: digest: sha256:af83aca920982c1fb17f08b4aa300439470349d58d63c921f67261054a0c9467 size: 2409
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;성공적으로 이미지를 도커 허브에 푸시하였습니다. 도커 허브에 저장된 50만 개의 이미지에 새로운 이미지가 하나 추가되었습니다!&lt;/p&gt;

&lt;p&gt;이제 어디서든 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subicura/sinatra-app:1&lt;/code&gt;이미지를 사용할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;private-docker-registry&quot;&gt;Private Docker Registry&lt;/h3&gt;

&lt;p&gt;도커 이미지를 비공개로 저장하려면  &lt;a href=&quot;https://www.docker.com/products/docker-cloud&quot;&gt;Docker Cloud&lt;/a&gt;를 유료($7 for 5 repos/month)로 사용하거나 레지스트리 서버를 자체적으로 구축해야합니다.&lt;/p&gt;

&lt;p&gt;도커 레지스트리는 도커를 이용하여 쉽게 만들 수 있습니다. 도커 이미지를 저장할 서버를 도커 스스로 만들어서 도커 이미지를 관리하다니 뭔가 므-_-흣합니다. &lt;del&gt;도커로 다하는 느낌&lt;/del&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker run &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$PWD&lt;/span&gt;/registry:/var/lib/registry &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 5000:5000 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
distribution/registry:2.6.0
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;저장된 이미지는 파일로 관리되기 때문에 호스트의 디렉토리를 마운트하였습니다. (S3 저장소를 사용할 수도 있습니다) 이제 레지스트리 서버의 아이피와 포트정보를 이미지명에 추가하면 바로 사용할 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker tag app localhost:5000/subicura/sinatra-app:1
docker push localhost:5000/subicura/sinatra-app:1
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;앞에서 만든 이름에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;localhost:5000/&lt;/code&gt;를 추가했습니다. 레지스트리 서버에 파일이 잘 저장되었나 마운트한 디렉토리를 한번 살펴봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;tree registry
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;registry
└── docker
    └── registry
        └── v2
            ├── blobs
            │   └── sha256
            │       ├── 05
            │       │   └── 05e91de6d378244d3b4dcfbb978548e47b2c22d9918638444c0f9e640d2bf819
            │       │       └── data
            │       ├── 1b
            │       │   └── 1bacd3c8ccb1f15609a10bd4a403831d0ec0b354438ddbf644c95c5d54f8eb13
            │       │       └── data
            │       ├── 3e
            │       │   └── 3e309f550af7bb4e3177e94e498938a24c20cf7404d90da4b24bd586d6376ab2
            │       │       └── data
            │       ├── 5b
            │       │   └── 5b8ee2811f46dea888057c8a2eb1fcd43838bb2545588f7e108d462d0836e217
            │       │       └── data
            │       ├── 76
            │       │   └── 761e0e61cc35ced6b08ce33b1db84a3e92a4843f908476d4cfc52f99b2b7e78a
            │       │       └── data
            │       ├── 86
            │       │   └── 869d5d3f92f8bbdcaa1023ce719df7e337d34b2a13954cde7954c6b1327297e9
            │       │       └── data
            │       ├── 97
            │       │   └── 976dd3af6adc358c852b97651cef1ceaade821a25f3bf566de3a8ea8b7d6bc6a
            │       │       └── data
            │       ├── a2
            │       │   └── a2037218c9af7a6913308a60127a320272fd6d58405692a5be48ce976ace6c6d
            │       │       └── data
            │       ├── e2
            │       │   └── e2d7e96004fdd10e671372a8b5e861bae78bcf878e062d13f6c470311936d500
            │       │       └── data
            │       ├── f4
            │       │   └── f40e1388890a7ca2b5180e2fae69aa982926307cdfa98c8c6a2dde01c0464587
            │       │       └── data
            │       ├── f8
            │       │   └── f8a4e25b40ce0ecc925cfb0b2ec7eec0a06948eda173e943c228cd51f78b40c5
            │       │       └── data
            │       └── fd
            │           └── fdeb3bd5d1b49c094875dcacccb743b0bc913c7de80ba783f2f1bbda6b1a3b55
            │               └── data
            └── repositories
                └── subicura
                    └── app
                        ├── _layers
                        │   └── sha256
                        │       ├── 1bacd3c8ccb1f15609a10bd4a403831d0ec0b354438ddbf644c95c5d54f8eb13
                        │       │   └── link
                        │       ├── 3e309f550af7bb4e3177e94e498938a24c20cf7404d90da4b24bd586d6376ab2
                        │       │   └── link
                        │       ├── 5b8ee2811f46dea888057c8a2eb1fcd43838bb2545588f7e108d462d0836e217
                        │       │   └── link
                        │       ├── 761e0e61cc35ced6b08ce33b1db84a3e92a4843f908476d4cfc52f99b2b7e78a
                        │       │   └── link
                        │       ├── 869d5d3f92f8bbdcaa1023ce719df7e337d34b2a13954cde7954c6b1327297e9
                        │       │   └── link
                        │       ├── 976dd3af6adc358c852b97651cef1ceaade821a25f3bf566de3a8ea8b7d6bc6a
                        │       │   └── link
                        │       ├── a2037218c9af7a6913308a60127a320272fd6d58405692a5be48ce976ace6c6d
                        │       │   └── link
                        │       ├── e2d7e96004fdd10e671372a8b5e861bae78bcf878e062d13f6c470311936d500
                        │       │   └── link
                        │       ├── f40e1388890a7ca2b5180e2fae69aa982926307cdfa98c8c6a2dde01c0464587
                        │       │   └── link
                        │       ├── f8a4e25b40ce0ecc925cfb0b2ec7eec0a06948eda173e943c228cd51f78b40c5
                        │       │   └── link
                        │       └── fdeb3bd5d1b49c094875dcacccb743b0bc913c7de80ba783f2f1bbda6b1a3b55
                        │           └── link
                        ├── _manifests
                        │   ├── revisions
                        │   │   └── sha256
                        │   │       └── 05e91de6d378244d3b4dcfbb978548e47b2c22d9918638444c0f9e640d2bf819
                        │   │           └── link
                        │   └── tags
                        │       └── latest
                        │           ├── current
                        │           │   └── link
                        │           └── index
                        │               └── sha256
                        │                   └── 05e91de6d378244d3b4dcfbb978548e47b2c22d9918638444c0f9e640d2bf819
                        │                       └── link
                        └── _uploads

56 directories, 26 files
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이미지가 레이어별로 이쁘게 저장된 걸 확인할 수 있습니다. 이렇게 개인 저장소를 만드는 법은 매우 간단합니다. 이제 내부적으로 이미지를 관리하고 여러 서버에 배포할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;보안&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;도커 레지스트리는 일반적인 HTTP 프로토콜을 사용하여 이미지를 전송합니다. 따라서 SSL(HTTPS)을 사용하지 않으면 이미지 내용이 유출될 수 있습니다. 이런 보안 이슈 때문에 도커는 기본적으로 로컬(localhost) 서버를 제외하곤 HTTP 사용을 금지하고 있으며 이런 보안위험을 무시하려면 도커 엔진을 실행할 때 허용 옵션을 넣어야 합니다.&lt;/p&gt;

&lt;p&gt;관련 설정은 &lt;a href=&quot;https://docs.docker.com/registry/insecure/&quot;&gt;문서&lt;/a&gt;를 참고하시기 바랍니다.&lt;/p&gt;

&lt;h2 id=&quot;배포하기&quot;&gt;배포하기&lt;/h2&gt;
&lt;p&gt;드디어 도커 안내서의 마지막 주제, 서버관리의 꽃! 배포&lt;sub&gt;deploy&lt;/sub&gt;에 대해 알아보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;컨테이너-배포-방식으로&quot;&gt;컨테이너 배포 방식으로&lt;/h3&gt;

&lt;p&gt;컨테이너를 배포하는 방식은 기존에 애플리케이션을 배포하는 방식과 큰 차이가 있습니다.&lt;/p&gt;

&lt;p&gt;기존에 애플리케이션을 배포하는 방식은 사용하는 언어, 프레임워크, 웹(or WAS)서버, 리눅스 배포판, 개발자의 취향에 따라 각각 다른 방식을 사용했습니다.&lt;/p&gt;

&lt;p&gt;새로운 서버를 셋팅하고 한 번에 배포를 성공한다는 건 굉장히 힘든 일이었고 의존성 라이브러리가 제대로 설치되었는지 검증하기도 매우 어려웠습니다.&lt;/p&gt;

&lt;p&gt;ftp, rsync, ant, gradle, capistrano, fabric, chef, puppet, ansible등 다양한 배포툴이 저마다의 장점을 가지고 등장하였고 배포하는 방식을 하나로 정의한다는 건 거의 불가능했습니다.&lt;/p&gt;

&lt;p&gt;하지만, 컨테이너를 사용하면 어떤 언어, 어떤 프레임워크를 쓰든 상관없이 배포 방식이 동일해지고 과정 또한 굉장히 단순해집니다. 그냥 이미지를 다운받고 컨테이너를 실행하면 끝입니다.&lt;/p&gt;

&lt;p&gt;음…&lt;/p&gt;

&lt;p&gt;&lt;em&gt;네, 그게 답니다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;서버에 접속해서 컨테이너를 실행할 줄 안다면 이미 배포하는 법을 알고 있는 겁니다.  참 쉽죠?&lt;/p&gt;

&lt;h3 id=&quot;컨테이너-업데이트&quot;&gt;컨테이너 업데이트&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-10-docker-guide-for-beginners-create-image-and-deploy/docker-update.png&quot; alt=&quot;Update&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도커를 사용하면 업데이트하는 방식도 배포와 큰 차이가 없습니다.&lt;/p&gt;

&lt;p&gt;최신 이미지를 기반으로 새 컨테이너를 만들고 이전 컨테이너를 중지(삭제)하면 됩니다. 최신 소스를 어떻게 복사할지 서버 프로세스는 어떻게 재시작할지 고민할 필요가 없습니다. 그냥 통째로 바꿔버리는 겁니다.&lt;/p&gt;

&lt;p&gt;단, 컨테이너를 중지하지 않고 graceful&lt;del&gt;스무스&lt;/del&gt;하게 샤샤샥 교체하는 방법은 아쉽지만 존재하지 않습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;컨테이너를 중지하지 않고 컨테이너 내부에 접속하여 소스를 업데이트하는 방법도 “가능”은 하지만 컨테이너의 장점을 살릴 수 없는 “잘못된 패턴”입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이런 방식은 매우 단순하지만, 컨테이너가 멈추는 순간 실행 중인 프로세스가 &lt;strong&gt;종료&lt;/strong&gt;되고 프로세스가 종료되면 고객들은 접속이 안 되고 접속이 안 되면 매출이 떨어지고 매출이 떨어지면 월급이 안나오기 때문에 무중단을 고려한 &lt;a href=&quot;http://nginx.org/&quot;&gt;nginx&lt;/a&gt;나 &lt;a href=&quot;http://www.haproxy.org/&quot;&gt;HAProxy&lt;/a&gt;같은 로드 발란서&lt;sub&gt;Load Balancer&lt;/sub&gt;와 2대 이상의 컨테이너를 사용해야 합니다.&lt;/p&gt;

&lt;p&gt;여기서는 개념만 소개하고 실제로 컨테이너를 업데이트하는 구체적인 방법은 &lt;a href=&quot;/2016/06/07/zero-downtime-docker-deployment.html&quot;&gt;도커를 이용한 웹서비스 무중단 배포하기&lt;/a&gt;&lt;del&gt;막간 홍보&lt;/del&gt;글로 대신합니다.&lt;/p&gt;

&lt;h3 id=&quot;배포에-대해-더-알아보기&quot;&gt;배포에 대해 더 알아보기&lt;/h3&gt;

&lt;p&gt;도커를 이용한 배포, 그 자체는 매우 단순하지만 여러 대의 서버를 관리하고 문제없이 업데이트 하는 건 완전히 새로운 이야기입니다.&lt;/p&gt;

&lt;p&gt;여러 대의 서버를 관리하려면 가상네트워크, 공유 파일, 로그관리, CPU나 메모리 같은 자원분배에 대해 고민해야 하고 Service Discovery에 대한 개념과 Orchestration이라는 주제에 관해 공부해야 합니다. 딱 정해진 답은 없고 현재 운영 중인 환경에 적합한 방법을 찾아야 하며 지금도 계속해서 발전하고 여러 컨퍼런스에서 활발하게 논의되는 주제입니다.&lt;/p&gt;

&lt;p&gt;자세한 내용은 초보를 위한 안내서의 범위를 벗어나므로 더 많은 내용이 궁금하신 분은 각자 공부하는 것으로… &lt;del&gt;화이팅!!&lt;/del&gt;&lt;/p&gt;

&lt;h2 id=&quot;마무으리&quot;&gt;마무으리&lt;/h2&gt;
&lt;p&gt;클라우드가 발전하면서 언제든 원하는 장소에 수십 대의 서버를 클릭 한 번으로 생성하는 시대가 되었습니다. 서버는 구입하는것이 아니라 필요한 만큼 잠시 &lt;strong&gt;대여&lt;/strong&gt;하는 개념이 되었고 오토 스케일링이라는 환상적인 기능은 부하에 따라 자동으로 서버 개수를 늘리고 줄여줍니다.&lt;/p&gt;

&lt;p&gt;이러한 흐름 속에서 아무 문제 없이 서비스를 배포하고 운영하는 것은 사실 기적이라고 할 수 있습니다. 도커가 등장하여 복잡한 부분을 단순하게 하고 많은 문제를 해결해 주고 있지만 도커도 모든 문제를 해결해 주지는 않습니다. (대표적으로 데이터베이스처럼 stateful한 애플리케이션은 관리가 어렵습니다) 다만, 현재 시점에서 그 어떤 방법보다도 &lt;strong&gt;좀 더 나은 방법&lt;/strong&gt;인 건 확실합니다.&lt;/p&gt;

&lt;p&gt;초보를 위한 도커 안내서는 오늘도 서버운영으로 고통받고 있는 개발자분께 도커를 소개하고 전반적인 내용을 전달하기 위해 작성하였습니다. 길다면 길고 짧다면 짧은 글을 통해 아무쪼록 초보분들에게 많은 도움이 되었으면 좋겠습니다.&lt;/p&gt;

&lt;p&gt;도커에 대해 궁금한 점은 &lt;a href=&quot;http://slack.opencontainer.co.kr&quot;&gt;오픈컨테이너 슬랙&lt;/a&gt;으로 오시면 많은 도움을 받을 수 있습니다. 내용에 대한 다양한 피드백도 환영합니다. 읽어주셔서 감사합니다~&lt;/p&gt;

&lt;p&gt;마지막으로 “Future of Everything(모든것의 미래)”라는 슬라이드를 소개하며 글을 마칩니다.&lt;/p&gt;

&lt;div style=&quot;text-align: center; margin-bottom: 20px&quot;&gt;
  &lt;iframe src=&quot;//www.slideshare.net/slideshow/embed_code/key/IylipWTfVGtdaY&quot; width=&quot;595&quot; height=&quot;485&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen=&quot;&quot;&gt; &lt;/iframe&gt; 
  &lt;div style=&quot;margin-bottom:5px; font-size: 14px&quot;&gt; &lt;strong&gt; &lt;a href=&quot;//www.slideshare.net/MichaelDucy/the-future-of-everything-37344357&quot; title=&quot;The Future of Everything&quot; target=&quot;_blank&quot;&gt;The Future of Everything&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;//www.slideshare.net/MichaelDucy&quot;&gt;Michael Ducy&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://bit.ly/inflearn-docker&quot;&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/inflearn.png&quot; alt=&quot;이제 도커안내서를 영상으로 만나보세요!&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 10 Feb 2017 00:00:00 +0900</pubDate>
        <link>https://subicura.com/2017/02/10/docker-guide-for-beginners-create-image-and-deploy.html</link>
        <guid isPermaLink="true">https://subicura.com/2017/02/10/docker-guide-for-beginners-create-image-and-deploy.html</guid>
        
        <category>Docker</category>
        
        <category>DevOps</category>
        
        <category>Server</category>
        
        <category>Container</category>
        
        
        <category>Docker</category>
        
      </item>
    
      <item>
        <title>초보를 위한 도커 안내서 - 설치하고 컨테이너 실행하기</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/docker-logo.png&quot; alt=&quot;docker logo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 글은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;초보를 위한 도커 안내서 - 설치부터 배포까지&lt;/code&gt; 2번째 글입니다. 이번엔 도커 설치부터 컨테이너를 실행하고 컨테이너를 둘러보는 방법에 대해 설명합니다. 도커에 대해 1도 모르는 분들을 위해 아주 가볍게 자주 쓰는 명령어만 다루었기 때문에 모든 명령어가 궁금하신 분은 &lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/&quot;&gt;여기&lt;/a&gt;를 참고해주세요.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/2017/01/19/docker-guide-for-beginners-1.html&quot;&gt;초보를 위한 도커 안내서 - 도커란 무엇인가?&lt;/a&gt; &lt;span class=&quot;series&quot;&gt;SERIES 1/3&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;초보를 위한 도커 안내서 - 설치하고 컨테이너 실행하기 ✓&lt;/strong&gt; &lt;span class=&quot;series&quot;&gt;SERIES 2/3&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2017/02/10/docker-guide-for-beginners-create-image-and-deploy.html&quot;&gt;초보를 위한 도커 안내서 - 이미지 만들고 배포하기&lt;/a&gt; &lt;span class=&quot;series&quot;&gt;SERIES 3/3&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot; class=&quot;googleads googleads-content&quot;&gt;
                &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-2468713653725581&quot; data-ad-slot=&quot;8649023787&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
            &lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;도커-설치하기&quot;&gt;도커 설치하기&lt;/h2&gt;

&lt;p&gt;도커는 리눅스 컨테이너 기술이므로 macOS나 windows에 설치할 경우 가상머신에 설치가 됩니다. 리눅스 컨테이너 말고 윈도우즈 컨테이너라는 것도 존재하지만 여기서는 다루지 않습니다.&lt;/p&gt;

&lt;h3 id=&quot;linux&quot;&gt;Linux&lt;/h3&gt;

&lt;p&gt;리눅스에 도커를 설치하는 방법은 자동 설치 스크립트를 이용하는 것이 가장 쉽습니다. 다음 명령어를 입력하면 root 권한을 요구하고 잠시 기다리면 설치가 완료됩니다. 음.. 참 쉽죠?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;curl &lt;span class=&quot;nt&quot;&gt;-fsSL&lt;/span&gt; https://get.docker.com/ | &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;sh
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-install-on-linux.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;Docker Install (ubuntu)&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;sudo 없이 사용하기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;docker는 기본적으로 root권한이 필요합니다. root가 아닌 사용자가 sudo없이 사용하려면 해당 사용자를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker&lt;/code&gt;그룹에 추가합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;usermod &lt;span class=&quot;nt&quot;&gt;-aG&lt;/span&gt; docker &lt;span class=&quot;nv&quot;&gt;$USER&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 현재 접속중인 사용자에게 권한주기&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;usermod &lt;span class=&quot;nt&quot;&gt;-aG&lt;/span&gt; docker your-user &lt;span class=&quot;c&quot;&gt;# your-user 사용자에게 권한주기&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;사용자가 로그인 중이라면 다시 로그인 후 권한이 적용됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주의사항&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;도커를 실행하기 위한 kernel 버전은 3.10.x 이상입니다. ubuntu 14.04 이상을 사용하면 큰 문제가 없고 kernel의 버전이 낮을 경우 제대로 동작을 안하거나 문제가 생길 수 있습니다. 가급적 최신버전으로 업데이트 해주세요.&lt;/li&gt;
  &lt;li&gt;ubuntu나 centos가 아닌 경우는 다른 방법이 필요합니다. 다른 리눅스를 쓰시는 분은 대부분 고오오급 개발자 분이시니 따로 설명하지 않아도 될 것 같아 &lt;a href=&quot;https://docs.docker.com/engine/installation/&quot;&gt;링크&lt;/a&gt;로 대신하겠습니다. &lt;del&gt;절대 귀찮아서가 아님&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;docker-for-mac--docker-for-windows&quot;&gt;Docker for Mac / Docker for Windows&lt;/h3&gt;

&lt;p&gt;도커를 맥이나 윈도우즈에 설치하려면 &lt;a href=&quot;https://docs.docker.com/docker-for-mac&quot;&gt;Docker for mac&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.docker.com/docker-for-windows&quot;&gt;Docker for windows&lt;/a&gt;를 설치하면 됩니다. 파일을 다운받고 설치하고 재부팅하면 대부분 문제없이 완료됩니다. 소소한 옵션들이 있는데 특별히 건드릴 부분은 없으나 한번 살펴보고 적절하게 설정하시면 됩니다. (windows는 공유 드라이브를 선택해주세요)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-2/docker-for-mac.png&quot; alt=&quot;Docker for Mac&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마치 네이티브스럽게 설치된 것 같지만 도커는 리눅스 컨테이너이므로 실제로는 가상머신에 설치가 되었습니다. 사용자는 가상머신을 사용한다는 느낌이 전혀 안드는데 그런부분을 굉장히 신경써서 설계하였습니다. 예를 들면, 포트를 연결하기 위해 도커 컨테이너의 특정 포트를 가상머신에 연결하고 다시 mac이나 windows의 포트와 연결해야 합니다. 디렉토리를 연결한다면 디렉토리를 가상머신과 공유하고 그 디렉토리를 다시 컨테이너와 연결해야 합니다. 이런 한단계 추가적으로 거쳐야하는 부분을 자연스럽게 처리해줍니다.&lt;/p&gt;

&lt;p&gt;docker for mac은 &lt;a href=&quot;https://github.com/mist64/xhyve&quot;&gt;xhyve&lt;/a&gt;라는 macOS에서 제공하는 가상환경을 이용하고 docker for windows는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Hyper-V&quot;&gt;Hyper-V&lt;/a&gt;기능을 이용합니다. 따라서 OS가 최신버전이 아니면 동작하지 않을 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;가상머신에-설치하기&quot;&gt;가상머신에 설치하기&lt;/h3&gt;

&lt;p&gt;이런저런 이유로 Docker for … 를 사용하지 못하는 경우 &lt;a href=&quot;https://docs.docker.com/machine/&quot;&gt;Docker machine&lt;/a&gt;을 이용할 수 있는데 처음 도커를 공부하는 경우에는 Virtual Box나 VMware같은 가상머신에 리눅스를 설치하고 리눅스에 접속하여 도커를 사용하는 방법을 권장합니다. 처음부터 Docker machine을 사용하면 환경이 약간 혼란스러울 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;설치확인하기&quot;&gt;설치확인하기&lt;/h3&gt;

&lt;p&gt;설치가 완료되었다면 정상적으로 설치되었는지 도커 명령어를 입력해 확인해 봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker version
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;Client:
 Version:      1.12.6
 API version:  1.24
 Go version:   go1.6.4
 Git commit:   78d1802
 Built:        Wed Jan 11 00:23:16 2017
 OS/Arch:      darwin/amd64

Server:
 Version:      1.12.6
 API version:  1.24
 Go version:   go1.6.4
 Git commit:   78d1802
 Built:        Wed Jan 11 00:23:16 2017
 OS/Arch:      linux/amd64
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Client와 Server 정보가 정상적으로 출력되었다면 설치가 완료된 것 입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Server 정보가 안나오고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Error response from daemon: Bad response from Docker engine&lt;/code&gt;이라는 메시지가 출력되는 경우는 보통 docker daemon이 정상적으로 실행되지 않았거나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo&lt;/code&gt;를 입력하지 않은 경우입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;혹시, 특이한 부분을 찾으셨나요? 버전정보가 클라이언트와 서버로 나뉘어져 있습니다. 도커는 하나의 실행파일이지만 실제로 클라이언트와 서버역할을 각각 할 수 있습니다. 도커 커맨드를 입력하면 도커 클라이언트가 도커 서버로 명령을 전송하고 결과를 받아 터미널에 출력해 줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-2/docker-host.png&quot; alt=&quot;docker client-host&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기본값이 도커 서버의 소켓을 바라보고 있기 때문에 사용자는 의식하지 않고 마치 바로 명령을 내리는 것 같은 느낌을 받습니다. 이러한 설계가 mac이나 windows의 터미널에서 명령어를 입력했을때 가상 서버에 설치된 도커가 동작하는 이유입니다.&lt;/p&gt;

&lt;h2 id=&quot;컨테이너-실행하기&quot;&gt;컨테이너 실행하기&lt;/h2&gt;
&lt;p&gt;이제! 드디어! 컨테이너를 실행해 보려고 합니다. 손이 근질근질하고 컨테이너의 강려크함을 보여드리고 싶기 때문에 여러개의 프로그램을 마구잡이로 손쉽게 띄워보겠습니다.&lt;/p&gt;

&lt;p&gt;도커를 실행하는 명령어는 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;다음은 자주 사용하는 옵션들입니다.&lt;/p&gt;

&lt;table class=&quot;table table-key-value-60&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;옵션&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-d&lt;/td&gt;
      &lt;td&gt;detached mode 흔히 말하는 백그라운드 모드&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-p&lt;/td&gt;
      &lt;td&gt;호스트와 컨테이너의 포트를 연결 (포워딩)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-v&lt;/td&gt;
      &lt;td&gt;호스트와 컨테이너의 디렉토리를 연결 (마운트)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-e&lt;/td&gt;
      &lt;td&gt;컨테이너 내에서 사용할 환경변수 설정&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–name&lt;/td&gt;
      &lt;td&gt;컨테이너 이름 설정&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–rm&lt;/td&gt;
      &lt;td&gt;프로세스 종료시 컨테이너 자동 제거&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-it&lt;/td&gt;
      &lt;td&gt;-i와 -t를 동시에 사용한 것으로 터미널 입력을 위한 옵션&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–link&lt;/td&gt;
      &lt;td&gt;컨테이너 연결 [컨테이너명:별칭]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;엄청나게 직관적인 옵션으로 몇번 실행해보면 자연스럽게 익숙해집니다.&lt;/p&gt;

&lt;h3 id=&quot;ubuntu-1604-container&quot;&gt;ubuntu 16.04 container&lt;/h3&gt;

&lt;p&gt;시작은 가볍게 ubuntu 16.04 컨테이너를 생성하고 컨테이너 내부에 들어가 봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker run ubuntu:16.04
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-run-ubuntu.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;run ubuntu 16.04 container&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;run&lt;/code&gt;명령어를 사용하면 사용할 이미지가 저장되어 있는지 확인하고 없다면 다운로드(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pull&lt;/code&gt;)를 한 후 컨테이너를 생성(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;create&lt;/code&gt;)하고 시작(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start&lt;/code&gt;) 합니다.&lt;/p&gt;

&lt;p&gt;위 예제는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ubuntu:16.04&lt;/code&gt; 이미지를 다운받은 적이 없기 때문에 이미지를 다운로드 한 후 컨테이너가 실행되었습니다. 컨테이너는 정상적으로 실행됐지만 뭘 하라고 명령어를 전달하지 않았기 때문에 컨테이너는 생성되자마자 종료됩니다. 컨테이너는 프로세스이기 때문에 실행중인 프로세스가 없으면 컨테이너는 종료됩니다.&lt;/p&gt;

&lt;p&gt;이번에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/bin/bash&lt;/code&gt; 명령어를 입력해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ubuntu:16.04&lt;/code&gt; 컨테이너를 실행해 보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker run &lt;span class=&quot;nt&quot;&gt;--rm&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; ubuntu:16.04 /bin/bash

&lt;span class=&quot;c&quot;&gt;# in container&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /etc/issue
Ubuntu 16.04.1 LTS &lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\l&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls
&lt;/span&gt;bin   dev  home  lib64  mnt  proc  run   srv  tmp  var
boot  etc  lib   media  opt  root  sbin  sys  usr
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-run-ubuntu-bash.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;run ubuntu 16.04 container with /bin/bash&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;컨테이너 내부에 들어가기 위해 bash 쉘을 실행하고 키보드 입력을 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-it&lt;/code&gt; 옵션을 줍니다. 추가적으로 프로세스가 종료되면 컨테이너가 자동으로 삭제되도록 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--rm&lt;/code&gt; 옵션도 추가하였습니다.&lt;/p&gt;

&lt;p&gt;이번에는 바로 전에 이미지를 다운 받았기 때문에 이미지를 다운로드 하는 화면 없이 바로 실행되었습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cat /etc/issue&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ls&lt;/code&gt;를 실행해보면 ubuntu 리눅스인걸 알 수 있습니다. 뭔가 가벼운 가상머신 같나요?&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exit&lt;/code&gt;로 bash 쉘을 종료하면 컨테이너도 같이 종료됩니다.&lt;/p&gt;

&lt;p&gt;도커를 이용하여 가장 기본적인 컨테이너를 순식간에 만들어 보았습니다.&lt;/p&gt;

&lt;h3 id=&quot;redis-container&quot;&gt;redis container&lt;/h3&gt;

&lt;p&gt;2번째 컨테이너는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redis&lt;/code&gt; 입니다. &lt;a href=&quot;https://redis.io/&quot;&gt;redis&lt;/a&gt;는 메모리기반의 다양한 기능을 가진 스토리지입니다. 6379 포트로 통신하며 telnet 명령어로 테스트해 볼 수 있습니다. redis 컨테이너는 detached mode(백그라운드 모드)로 실행하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-d&lt;/code&gt; 옵션을 추가하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-p&lt;/code&gt; 옵션을 추가하여 컨테이너의 포트를 호스트의 포트로 연결해보겠습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-d&lt;/code&gt;옵션이 없다면 프로세스가 foreground로 실행되어 아무키도 입력할 수 없게 됩니다. 컨테이너를 종료하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ctrl + c&lt;/code&gt;를 입력해 주세요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker run &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 1234:6379 redis

&lt;span class=&quot;c&quot;&gt;# redis test&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;telnet localhost 1234
&lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;mykey hello
+OK
get mykey
&lt;span class=&quot;nv&quot;&gt;$5&lt;/span&gt;
hello
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-run-redis.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;run redis container&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-d&lt;/code&gt; 옵션을 주었기 때문에 컨테이너를 실행하자마자 컨테이너의 ID(5dff91d2…)를 보여주고 바로 쉘로 돌아왔습니다. 컨테이너는 종료된 것이 아니라 백그라운드 모드로 동작하고 있고 컨테이너 ID를 이용하여 컨테이너를 제어할 수 있습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-p&lt;/code&gt; 옵션을 이용하여 호스트의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1234포트&lt;/code&gt;를 컨테이너의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;6379포트&lt;/code&gt;로 연결하였고 localhost의 1234포트로 접속하면 하면 redis를 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;테스트 결과 redis에 접속하여 새로운 키를 저장하고 불러오는데 성공했습니다. 실행이 간단한건 물론이고 호스트의 포트만 다르게 하면 하나의 서버에 여러개의 redis 서버를 띄우는 것도 매우 간단합니다.&lt;/p&gt;

&lt;h3 id=&quot;mysql-57-container&quot;&gt;MySQL 5.7 container&lt;/h3&gt;

&lt;p&gt;3번째 실행할 컨테이너는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MySQL 서버&lt;/code&gt;입니다. 가장 흔하게 사용하는 데이터베이스인데 이번에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-e&lt;/code&gt; 옵션을 이용하여 환경변수를 설정하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--name&lt;/code&gt; 옵션을 이용하여 컨테이너에 읽기 어려운 ID 대신 쉬운 이름을 부여할 예정입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--name&lt;/code&gt;옵션을 생략하면 도커가 자동으로 이름을 지어 줍니다. 이름은 유명한 과학자나 해커의 이름과 수식어를 조합하여 랜덤으로 &lt;a href=&quot;https://github.com/docker/docker/blob/master/pkg/namesgenerator/names-generator.go&quot;&gt;생성&lt;/a&gt;합니다. (ex - boring_wozniak) 우리나라 과학자 &lt;a href=&quot;https://github.com/docker/docker/issues/8996&quot;&gt;장영실&lt;/a&gt;도 등록되어 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://hub.docker.com/_/mysql/&quot;&gt;MySQL Docker hub&lt;/a&gt; 페이지에 접속하면 간단한 사용법과 환경변수에 대한 설명이 있습니다. 여러가지 설정값이 있는데 패스워드 없이 root계정을 만들기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MYSQL_ALLOW_EMPTY_PASSWORD&lt;/code&gt; 환경변수를 설정합니다. 그리고 컨테이너의 이름은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mysql&lt;/code&gt;로 할당하고 백그라운드 모드로 띄우기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-d&lt;/code&gt; 옵션을 줍니다. 포트는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3306포트&lt;/code&gt;를 호스트에서 그대로 사용하겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker run &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 3306:3306 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;MYSQL_ALLOW_EMPTY_PASSWORD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; mysql &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  mysql:5.7

&lt;span class=&quot;c&quot;&gt;# MySQL test&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;mysql &lt;span class=&quot;nt&quot;&gt;-h127&lt;/span&gt;.0.0.1 &lt;span class=&quot;nt&quot;&gt;-uroot&lt;/span&gt;

mysql&amp;gt; show databases&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
4 rows &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0.00 sec&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

mysql&amp;gt; quit
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-run-mysql.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;run mysql 5.7 container&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;와우, 순식간에 MySQL서버가 실행되었습니다. 이번 테스트는 호스트 OS에 MySQL 클라이언트가 설치되어 있어야 합니다. 추후에 실행중인 MySQL 도커 컨테이너에 접속하여 클라이언트를 실행해 보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;처음 접속 시도시 에러가 난 화면은 MySQL 서버가 최초로 실행되면서 준비작업을 하기 때문에 발생하는 에러입니다. 컨테이너를 실행하면 백그라운드에서 MySQL 서버를 띄우는 시간이 필요하기 때문에 잠시 후에 다시 시도 했을 때 정상적으로 접속된 걸 확인할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;wordpress-container&quot;&gt;WordPress container&lt;/h3&gt;

&lt;p&gt;이번에는 블로그&lt;del&gt;보다 웹용으로 더 흔히 쓰이는&lt;/del&gt;엔진으로 유명한 &lt;a href=&quot;https://wordpress.com&quot;&gt;워드프레스&lt;/a&gt;를 실행합니다. 워드프레스는 데이터베이스가 필요하기 때문에 조금 복잡한 형태를 띄지만 크게 어렵지 않습니다. 바로 전에 생성했던 MySQL 컨테이너에 워드프레스 데이터베이스를 만들고 WordPress 컨테이너를 실행할 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--link&lt;/code&gt; 옵션을 이용하여 MySQL 컨테이너를 연결하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--link&lt;/code&gt; 옵션은 환경변수와 IP정보를 공유하는데 링크한 컨테이너의 IP정보를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/hosts&lt;/code&gt;에 자동으로 입력하므로 워드프레스 컨테이너가 MySQL 데이터베이스의 정보를 알 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;먼저, 워드프레스용 데이터베이스를 생성하고 워드프레스 컨테이너를 실행합니다. 호스트의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;8080포트&lt;/code&gt;를 컨테이너의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;80포트&lt;/code&gt;로 연결하고 MySQL 컨테이너와 연결한 후 각종 데이터베이스 설정 정보를 환경변수로 입력합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# create mysql database&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;mysql &lt;span class=&quot;nt&quot;&gt;-h127&lt;/span&gt;.0.0.1 &lt;span class=&quot;nt&quot;&gt;-uroot&lt;/span&gt;
create database wp CHARACTER SET utf8&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
grant all privileges on wp.&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; to wp@&lt;span class=&quot;s1&quot;&gt;'%'&lt;/span&gt; identified by &lt;span class=&quot;s1&quot;&gt;'wp'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
flush privileges&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
quit

&lt;span class=&quot;c&quot;&gt;# run wordpress container&lt;/span&gt;
docker run &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 8080:80 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--link&lt;/span&gt; mysql:mysql &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;WORDPRESS_DB_HOST&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;mysql &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;WORDPRESS_DB_NAME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;wp &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;WORDPRESS_DB_USER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;wp &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;WORDPRESS_DB_PASSWORD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;wp &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  wordpress
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-run-wp.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;run wordpress container&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;컨테이너가 제대로 실행되었는지 웹 브라우저로 확인해봅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-2/wp.png&quot; alt=&quot;wordpress setup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;워드프레스가 실행되었습니다! 단지 이미지를 다운받고 적절한 환경변수를 입력하여 컨테이너를 실행했을 뿐입니다. 워드프레스 컨테이너 내부는 apache2와 php가 설치되어 있지만 추상화되어 있어 실행과정에선 드러나지 않습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이번 예제는 테스트용으로만 사용해야 합니다. 운영 환경에서 사용하려면 추가적인 셋팅이 필요합니다. 이부분은 밑에서 다시 다룹니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--link&lt;/code&gt; 옵션은 deprecated 되어 곧 사용할 수 없습니다. 대신 Docker network 기능을 이용해야 하지만 쉬운 이해를 돕기 위해 사용하였습니다. &lt;del&gt;참고만 하고 실제 사용은 ㄴㄴ&lt;/del&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이제, 원하는 서비스가 있다면 이미지를 찾거나 직접 만들고, 어디서나 손쉽게 서비스를 실행할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;tensorflow&quot;&gt;tensorflow&lt;/h3&gt;

&lt;p&gt;마지막으로 이렇게 활용할 수 있다라는 예제로 tensorflow를 실행보도록 하겠습니다. &lt;a href=&quot;https://www.tensorflow.org/&quot;&gt;tensorflow&lt;/a&gt;는 손쉽게 머신러닝을 할 수 있는 툴입니다. tensorflow는 python으로 만들어져 python과 관련 패키지를 설치해야 합니다. 이번에 설치하는 이미지는 python과 함께 numpy, scipy, pandas, jupyter, scikit-learn, gensim, BeautifulSoup4, Tensorflow가 설치되어 있습니다. 뭔가 복잡해 보이지만 도커라면 손쉽게 실행해 볼 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker run &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 8888:8888 &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 6006:6006 teamlab/pydata-tensorflow:0.1
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;설치된 파일이 많아 다운로드 하는데 시간이 좀 걸립니다. 컨테이너가 실행되면 웹 브라우저에서 jupyter에 접속하여 머신러닝을 시작해 봅시다!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-2/tensorflow.png&quot; alt=&quot;Hello, Tensorflow!&quot; /&gt;&lt;/p&gt;

&lt;p&gt;와우! 성공적으로 tensorflow 테스트를 마쳤습니다. 이제 조금 있으면 A.I를 만들 수 있을 것 같습니다.(?!)&lt;/p&gt;

&lt;p&gt;여기까지 ubuntu, MySQL, redis, Wordpress, tensorflow를 실행해 보았습니다. 가상머신을 이용해서 동일한 작업을 했다면 컴퓨터가 엄청나게 버벅이기 시작했겠지만 컨테이너 기반의 도커를 이용하여 매우 가볍게 실행하고 있습니다. 내부 구조나 설치과정은 자세히 모르지만, 간단한 도커 명령어로 여러개의 서비스를 순식간에 실행하고 사용할 수 있다니 정말 짱짱맨입니다.&lt;/p&gt;

&lt;h2 id=&quot;도커-기본-명령어&quot;&gt;도커 기본 명령어&lt;/h2&gt;

&lt;p&gt;앞에서 도커의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;run&lt;/code&gt; 명령어를 이용하여 여러개의 컨테이너를 실행했습니다. 이제 컨테이너의 상태를 살펴보고 어떤 이미지가 설치되어 있는지 확인하는 명령어를 알아봅니다.&lt;/p&gt;

&lt;h3 id=&quot;컨테이너-목록-확인하기-ps&quot;&gt;컨테이너 목록 확인하기 (ps)&lt;/h3&gt;

&lt;p&gt;컨테이너 목록을 확인하는 명령어는 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker ps [OPTIONS]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;일단 기본옵션과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-a, --all&lt;/code&gt; 옵션만 살펴봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker ps
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;CONTAINER ID        IMAGE                           COMMAND                  CREATED              STATUS              PORTS                                                    NAMES
6a1d027b604f        teamlab/pydata-tensorflow:0.1   &quot;/opt/start&quot;             About a minute ago   Up About a minute   0.0.0.0:6006-&amp;gt;6006/tcp, 22/tcp, 0.0.0.0:8888-&amp;gt;8888/tcp   desperate_keller
52a516f87ceb        wordpress                       &quot;docker-entrypoint.sh&quot;   8 minutes ago        Up 8 minutes        0.0.0.0:8080-&amp;gt;80/tcp                                     happy_curran
2e2c569115b9        mysql:5.7                       &quot;docker-entrypoint.sh&quot;   9 minutes ago        Up 9 minutes        0.0.0.0:3306-&amp;gt;3306/tcp                                   mysql
56341072b515        redis                           &quot;docker-entrypoint.sh&quot;   16 minutes ago       Up 9 minutes        0.0.0.0:1234-&amp;gt;6379/tcp                                   furious_tesla
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps&lt;/code&gt; 명령어는 실행중인 컨테이너 목록을 보여줍니다. detached mode로 실행중인 컨테이너들이 보입니다. 어떤 이미지를 기반으로 만들었는지 어떤 포트와 연결이 되어있는지 등 간단한 내용을 보여줍니다.&lt;/p&gt;

&lt;p&gt;이번에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-a&lt;/code&gt; 옵션을 추가로 실행해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker ps &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;CONTAINER ID        IMAGE                           COMMAND                  CREATED             STATUS                      PORTS                                                    NAMES
6a1d027b604f        teamlab/pydata-tensorflow:0.1   &quot;/opt/start&quot;             2 minutes ago       Up 2 minutes                0.0.0.0:6006-&amp;gt;6006/tcp, 22/tcp, 0.0.0.0:8888-&amp;gt;8888/tcp   desperate_keller
52a516f87ceb        wordpress                       &quot;docker-entrypoint.sh&quot;   9 minutes ago       Up 9 minutes                0.0.0.0:8080-&amp;gt;80/tcp                                     happy_curran
2e2c569115b9        mysql:5.7                       &quot;docker-entrypoint.sh&quot;   10 minutes ago      Up 10 minutes               0.0.0.0:3306-&amp;gt;3306/tcp                                   mysql
56341072b515        redis                           &quot;docker-entrypoint.sh&quot;   18 minutes ago      Up 10 minutes               0.0.0.0:1234-&amp;gt;6379/tcp                                   furious_tesla
e1a00c5934a7        ubuntu:16.04                    &quot;/bin/bash&quot;              32 minutes ago      Exited (0) 32 minutes ago                                                            berserk_visvesvaraya
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;맨 처음 실행했다가 종료된 컨테이너(Exited (0))가 추가로 보입니다. 컨테이너는 종료되어도 삭제되지 않고 남아있습니다. 종료된 건 다시 시작할 수 있고 컨테이너의 읽기/쓰기 레이어는 그대로 존재합니다. 명시적으로 삭제를 하면 깔끔하게 컨테이너가 제거됩니다.&lt;/p&gt;

&lt;h3 id=&quot;컨테이너-중지하기-stop&quot;&gt;컨테이너 중지하기 (stop)&lt;/h3&gt;

&lt;p&gt;실행중인 컨테이너를 중지하는 명령어는 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker stop [OPTIONS] CONTAINER [CONTAINER...]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;옵션은 특별한게 없고 실행중인 컨테이너를 하나 또는 여러개 (띄어쓰기로 구분) 중지할 수 있습니다.&lt;/p&gt;

&lt;p&gt;앞에서 실행한 tensorflow 컨테이너는 더이상 필요가 없으니 중지해 보겠습니다. 중지하려면 컨테이너의 ID 또는 이름을 입력하면 됩니다. tensorflow 컨테이너의 ID를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps&lt;/code&gt;명령을 통해 확인하고 중지해 봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker ps &lt;span class=&quot;c&quot;&gt;# get container ID&lt;/span&gt;
docker stop &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;TENSORFLOW_CONTAINER_ID&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
docker ps &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# show all containers&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;blockquote&gt;
  &lt;p&gt;도커 ID의 전체 길이는 64자리 입니다. 하지만 명령어의 인자로 전달할 때는 전부 입력하지 않아도 됩니다. 예를 들어 ID가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;abcdefgh...&lt;/code&gt;라면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;abcd&lt;/code&gt;만 입력해도 됩니다. 앞부분이 겹치지 않는다면 1-2자만 입력해도 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;잠시 기다리면 tensorflow 컨테이너가 종료됩니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps -a&lt;/code&gt;명령어를 입력하여 종료되었는지 확인합니다.&lt;/p&gt;

&lt;h3 id=&quot;컨테이너-제거하기-rm&quot;&gt;컨테이너 제거하기 (rm)&lt;/h3&gt;

&lt;p&gt;종료된 컨테이너를 완전히 제거하는 명령어는 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker rm [OPTIONS] CONTAINER [CONTAINER...]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;종료 명령어도 옵션은 특별한게 없습니다. 종료된 컨테이너를 하나 또는 여러개 삭제할 수 있습니다. 종료된 ubuntu 컨테이너와 tensorflow 컨테이너를 삭제해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker ps &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# get container ID&lt;/span&gt;
docker &lt;span class=&quot;nb&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;UBUNTU_CONTAINER_ID&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;TENSORFLOW_CONTAINER_ID&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
docker ps &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# check exist&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;컨테이너가 말끔히 삭제되었습니다. 호스트 OS는 아무런 흔적도 남아있지 않고 컨테이너만 격리된 상태로 실행되었다가 삭제되었습니다. 시스템이 꼬일 걱정이 없습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;중지된 컨테이너를 일일이 삭제 하는 건 귀찮은 일입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker rm -v $(docker ps -a -q -f status=exited)&lt;/code&gt; 명령어를 입력하면 중지된 컨테이너 ID를 가져와서 한번에 삭제합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;이미지-목록-확인하기-images&quot;&gt;이미지 목록 확인하기 (images)&lt;/h3&gt;

&lt;p&gt;도커가 다운로드한 이미지 목록을 보는 명령어는 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker images [OPTIONS] [REPOSITORY[:TAG]]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;간단하게 도커 이미지 목록을 확인해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker images
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE
wordpress                   latest              b1fe82b15de9        43 hours ago        400.2 MB
redis                       latest              45c3ea2cecac        44 hours ago        182.9 MB
mysql                       5.7                 f3694c67abdb        46 hours ago        400.1 MB
ubuntu                      16.04               104bec311bcd        4 weeks ago         129 MB
teamlab/pydata-tensorflow   0.1                 7bdf5d7e0191        6 months ago        3.081 GB
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이미지 주소와 태그, ID, 생성시점, 용량이 보입니다. 이미지가 너무 많이 쌓이면 용량을 차지하기 때문에 사용하지 않는 이미지는 지우는 것이 좋습니다.&lt;/p&gt;

&lt;h3 id=&quot;이미지-다운로드하기-pull&quot;&gt;이미지 다운로드하기 (pull)&lt;/h3&gt;

&lt;p&gt;이미지를 다운로드하는 명령어는 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker pull [OPTIONS] NAME[:TAG|@DIGEST]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ubuntu:14.04&lt;/code&gt;를 다운받아보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker pull ubuntu:14.04
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;run&lt;/code&gt;명령어를 입력하면 이미지가 없을 때 자동으로 다운받으니 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pull&lt;/code&gt;명령어를 언제 쓰는지 궁금할 수 있는데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pull&lt;/code&gt;은 최신버전으로 다시 다운 받습니다. 같은 태그지만 이미지가 업데이트 된 경우는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pull&lt;/code&gt;명령어를 통해 새로 다운받을 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;이미지-삭제하기-rmi&quot;&gt;이미지 삭제하기 (rmi)&lt;/h3&gt;

&lt;p&gt;이미지를 삭제하는 방법은 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker rmi [OPTIONS] IMAGE [IMAGE...]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;images&lt;/code&gt;명령어를 통해 얻은 이미지 목록에서 이미지 ID를 입력하면 삭제가 됩니다. 단, 컨테이너가 실행중인 이미지는 삭제되지 않습니다. 컨테이너는 이미지들의 레이어를 기반으로 실행중이므로 당연히 삭제할 수 없습니다.&lt;/p&gt;

&lt;p&gt;tensorflow는 더 이상 사용하지 않으니 이미지를 제거해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker images &lt;span class=&quot;c&quot;&gt;# get image ID&lt;/span&gt;
docker rmi &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;TENSORFLOW_IMAGE_ID&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;Untagged: teamlab/pydata-tensorflow:0.1
Untagged: teamlab/pydata-tensorflow@sha256:cb5e036afc0aa647a6fe1f384475275aeed946c751de5209d84282c986589b7f
Deleted: sha256:7bdf5d7e0191a6133a385ac69ec6a07be46b08cf5b5e6b826a89b9b47aadabe5
Deleted: sha256:9d72165f240630813a39e2f802a75f45caa2bc230881fa73c2f620c4b04686b5
Deleted: sha256:5c90ba76fff96b155b8a9446f2fb42d2ae04566832f3929df41dc52c0ae462ae
Deleted: sha256:1e23db6b02673d34c54fe87ec958ae8f2e310ca4aa911c7f8488b6c7988bfba0
Deleted: sha256:759641367a6788b55361f9eeedcbc356f8e464ef794a883b5621fba6e23c6b18
Deleted: sha256:b5d017cd48c0d8461230b5ab0aed68e27a4018996344470db3c4b5adba10b49f
Deleted: sha256:470cdb158a12a416ffebde8d299fdbde28d56da062c701bf7a51d6484f777e97
Deleted: sha256:d136c3aea28597fadb667a084a6e5701e287fd36f03cc9555b0e5bca2e674f9b
Deleted: sha256:e62e6cce767baec3711dc1ec8cfcd76f68b88a6ca9ffcd2f3d22345048a0f8d7
Deleted: sha256:8e0761516c1c1ad792c9e67d1541d574905f067cb3b67e19a3af58ca7389eee9
Deleted: sha256:ad45f6539a6ce95216c9990d26b4b2e44c0b50637c1f0949b6965610b023fd97
Deleted: sha256:ebe200261801abef54e60699c098def3a4bd39a7b4833f164b99e23a88e8a98a
Deleted: sha256:698c310f0ec8a1f607a59f15a6affa7d9d21e21d9eaf6eb65b6ab6f33fcb62b4
Deleted: sha256:e5da0b4fd6d0143d7953e47a244a9be16919d1f4018e128e82fba6df967e790e
Deleted: sha256:7d8ffbfe2c1a55581e08b81f34506a746022e5beeb85f5848154b0b7d41208cf
Deleted: sha256:854cd556e616f5e5b21cd69f1e7c0d225c9b28eb5cf653aa4aa0937930298d72
Deleted: sha256:10e6f47febf1912a4d7a08b7652e360905a6ba8b76f188fd167c8d6afa09951a
Deleted: sha256:737ee41ad49072c9ba8301a17751e16d69c1045df74ac77f4ae05f849b08faec
Deleted: sha256:62b01cf4b1440085b0b9311372eb8acb509581faf655b2837a2e234c12fdfd24
Deleted: sha256:7dcdbe5fc9a2290d596e3bab8052c3141a69a451a29a98bd12678a7139891094
Deleted: sha256:8a9f069492b445dc889f9639572dc289f7c3fc1ac4d597a7468614fa2c624091
Deleted: sha256:34a63dcc0c5574597918a8e9df80e364f9fec88c0f4e25a0e5187acd241773ad
Deleted: sha256:af6fa43db2e379d3f0f3f36d61a0ece782133314c678d7223872eb7158f102ba
Deleted: sha256:efbafc7aa3a87241c10bf0c495672cf4a7b0cc2d23db06120ae1e13528316f82
Deleted: sha256:ea0c616be3659f71afce45eff2e28e51e04b25f1ae58b306521e6877f3adf2df
Deleted: sha256:f2dccb8902ea3d85aa9a954af894f59100fc00fa78c09b213c76dcf2727e3c3e
Deleted: sha256:3fe0adbd3614d696ded87bcb47aed81f49b113770a3778e276cd88abe9010b9f
Deleted: sha256:b88d260c0bcff3b4434a39ba33f58a2f9807400d664185057edd393133630242
Deleted: sha256:4de08f41d77237b2dbc0660036fe8352fdbacf6e079623d318003ed7e833a40a
Deleted: sha256:f32c8f02713c719181c2bf32be13dbd333932411d5fc3e0b6cfb780da8bb8124
Deleted: sha256:985d69571ed5d6d7e69bf58232fd8f30f8cd4ac77f41122a80fdab56347ec22d
Deleted: sha256:8509bc9969877f784fa6e704098cbcf77d694596644f389c5a2fefe5267878ab
Deleted: sha256:0ad5b9ed74fe2eee856b368d426cdd9335a6a6ecec0c4c705b5153c219a82692
Deleted: sha256:b159c847c5b9b899c23eba59395a4d7b7b275a8c686191ed6c4ef21ceadad8a2
Deleted: sha256:89e9f76552fd1a8d249c1e133e4c8964fe1f9104bb708db1e0ca6f6171ee4c22
Deleted: sha256:6d31e1827ca8f5037077314b2403eabd82590f9eae8baf956a2c2a819db68d4e
Deleted: sha256:7f4734de8e3dd402f10030f06bcb8781129b1eb6a25c58811a76d015f2a0982f
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이미지가 삭제되었습니다. 이미지는 여러개의 레이어로 구성되어 있기 때문에 모든 레이어가 삭제된 것을 알 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;컨테이너-둘러보기&quot;&gt;컨테이너 둘러보기&lt;/h2&gt;

&lt;p&gt;도커에 대한 아주아주아주 기본적인 명령어를 살펴보았습니다. 사실 저 명령어들과 이번에 살펴볼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;log&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec&lt;/code&gt; 명령어를 익히면 도커에서 사용하는 명령어는 거의 다 익혔다고 할 수 있습니다. 다른 명령어는 필요에 따라 하나하나 살펴보면 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;컨테이너-로그-보기-logs&quot;&gt;컨테이너 로그 보기 (logs)&lt;/h3&gt;

&lt;p&gt;컨테이너가 정상적으로 동작하는지 확인하는 좋은 방법은 로그를 확인하는 것 입니다. 로그를 확인하는 방법은 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker logs [OPTIONS] CONTAINER&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;기본 옵션과, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-f&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--tail&lt;/code&gt; 옵션을 살펴봅니다.&lt;/p&gt;

&lt;p&gt;기존에 생성해 놓은 워드프레스 컨테이너 로그를 확인해 보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker ps
docker logs &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;WORDPRESS_CONTAINER_ID&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;WordPress not found in /var/www/html - copying now...
Complete! WordPress has been successfully copied to /var/www/html
AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.4. Set the 'ServerName' directive globally to suppress this message
AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.4. Set the 'ServerName' directive globally to suppress this message
[Thu Jan 19 16:10:16.507735 2017] [mpm_prefork:notice] [pid 1] AH00163: Apache/2.4.10 (Debian) PHP/5.6.29 configured -- resuming normal operations
[Thu Jan 19 16:10:16.507776 2017] [core:notice] [pid 1] AH00094: Command line: 'apache2 -D FOREGROUND'
172.17.0.1 - - [19/Jan/2017:16:11:54 +0000] &quot;GET / HTTP/1.1&quot; 302 379 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:11:54 +0000] &quot;GET /wp-admin/install.php HTTP/1.1&quot; 200 2513 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/css/buttons.min.css?ver=4.7.1 HTTP/1.1&quot; 200 1698 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/js/zxcvbn-async.min.js?ver=1.0 HTTP/1.1&quot; 200 582 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-admin/css/install.min.css?ver=4.7.1 HTTP/1.1&quot; 200 2329 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/js/jquery/jquery-migrate.min.js?ver=1.4.1 HTTP/1.1&quot; 200 4366 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/js/jquery/jquery.js?ver=1.12.4 HTTP/1.1&quot; 200 34120 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-admin/js/password-strength-meter.min.js?ver=4.7.1 HTTP/1.1&quot; 200 825 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/js/wp-util.min.js?ver=4.7.1 HTTP/1.1&quot; 200 924 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-admin/js/user-profile.min.js?ver=4.7.1 HTTP/1.1&quot; 200 2590 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/js/underscore.min.js?ver=1.8.3 HTTP/1.1&quot; 200 6173 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/css/dashicons.min.css?ver=4.7.1 HTTP/1.1&quot; 200 28951 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-admin/images/wordpress-logo.svg?ver=20131107 HTTP/1.1&quot; 200 1810 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:02 +0000] &quot;GET /wp-includes/js/zxcvbn.min.js HTTP/1.1&quot; 200 330747 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:02 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 200 229 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
::1 - - [19/Jan/2017:16:12:08 +0000] &quot;OPTIONS * HTTP/1.0&quot; 200 126 &quot;-&quot; &quot;Apache/2.4.10 (Debian) PHP/5.6.29 (internal dummy connection)&quot;
::1 - - [19/Jan/2017:16:12:09 +0000] &quot;OPTIONS * HTTP/1.0&quot; 200 126 &quot;-&quot; &quot;Apache/2.4.10 (Debian) PHP/5.6.29 (internal dummy connection)&quot;
::1 - - [19/Jan/2017:16:12:10 +0000] &quot;OPTIONS * HTTP/1.0&quot; 200 126 &quot;-&quot; &quot;Apache/2.4.10 (Debian) PHP/5.6.29 (internal dummy connection)&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;컨테이너에서 실행한 로그가 쭈욱 보입니다. 아무 옵션을 주지 않았을 때는 전체 로그를 &lt;del&gt;무식하게&lt;/del&gt; 전부 다 출력합니다. 너무 많으니 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--tail&lt;/code&gt;옵션으로 마지막 10줄만 출력해 보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker logs &lt;span class=&quot;nt&quot;&gt;--tail&lt;/span&gt; 10 &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;WORDPRESS_CONTAINER_ID&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/js/wp-util.min.js?ver=4.7.1 HTTP/1.1&quot; 200 924 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-admin/js/user-profile.min.js?ver=4.7.1 HTTP/1.1&quot; 200 2590 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/js/underscore.min.js?ver=1.8.3 HTTP/1.1&quot; 200 6173 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/css/dashicons.min.css?ver=4.7.1 HTTP/1.1&quot; 200 28951 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-admin/images/wordpress-logo.svg?ver=20131107 HTTP/1.1&quot; 200 1810 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:02 +0000] &quot;GET /wp-includes/js/zxcvbn.min.js HTTP/1.1&quot; 200 330747 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:02 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 200 229 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
::1 - - [19/Jan/2017:16:12:08 +0000] &quot;OPTIONS * HTTP/1.0&quot; 200 126 &quot;-&quot; &quot;Apache/2.4.10 (Debian) PHP/5.6.29 (internal dummy connection)&quot;
::1 - - [19/Jan/2017:16:12:09 +0000] &quot;OPTIONS * HTTP/1.0&quot; 200 126 &quot;-&quot; &quot;Apache/2.4.10 (Debian) PHP/5.6.29 (internal dummy connection)&quot;
::1 - - [19/Jan/2017:16:12:10 +0000] &quot;OPTIONS * HTTP/1.0&quot; 200 126 &quot;-&quot; &quot;Apache/2.4.10 (Debian) PHP/5.6.29 (internal dummy connection)&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;마지막 10줄만 보니 좀 나아 보입니다. 이제 실시간으로 로그가 생성되는 걸 확인해보겠습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-f&lt;/code&gt; 옵션으로 실행합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker logs &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;WORDPRESS_CONTAINER_ID&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-log-f.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;docker logs -f&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;로그를 켜 놓은 상태에서 워드프레스 페이지를 새로고침하면 브라우저 접속 로그가 실시간으로 보입니다. 가장 흔하게 사용하는 옵션이고 로그 보기를 중지하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ctrl&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c&lt;/code&gt;를 입력하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;로그에 대해 좀 더 자세히&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;프로그램마다 로그 파일은 제각각 생길텐데 어떻게 저 로그가 나올까 라는 의문이 생깁니다. 도커는 로그파일을 자동으로 알아채는게 아니라 &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams&quot;&gt;표준 스트림&lt;/a&gt;&lt;sub&gt;Standard streams&lt;/sub&gt; 중 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stdout&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stderr&lt;/code&gt;를 수집합니다. 따라서 컨테이너에서 실행되는 프로그램의 로그 설정을 파일이 아닌 표준출력으로 바꾸어야 합니다. 단지 출력 방식만 바꾸는 것으로 모든 컨테이너는 로그에 대해 같은 방식으로 관리할 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;또하나 중요한 점은 컨테이너의 로그파일은 json 방식으로 어딘가에 저장이 됩니다. 로그가 많으면 은근히 파일이 차지하는 용량이 커지므로 주의해야합니다. 도커는 다양한 플러그인을 지원하여 json이 아닌 특정 로그 서비스에 스트림을 전달할 수 있습니다. 어느 정도 앱의 규모가 커지면 기본적인 방식 대신 로그 서비스를 이용하는 걸 고려해야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;컨테이너-명령어-실행하기-exec&quot;&gt;컨테이너 명령어 실행하기 (exec)&lt;/h3&gt;

&lt;p&gt;컨테이너를 관리하다 보면 실행중인 컨테이너에 들어가보거나 컨테이너의 파일을 실행하고 싶을 때가 있습니다. 컨테이너에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH&lt;/code&gt;를 설치하면 되지 않을까? 라고 생각할 수 있지만 SSH는 권장하지 않습니다. &lt;del&gt;하지 말라고 하면 꼭 하는 분들이 있던데 제발..&lt;/del&gt; 예전에는 &lt;a href=&quot;https://github.com/jpetazzo/nsenter&quot;&gt;nsenter&lt;/a&gt;라는 프로그램을 이용하였는데 docker에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec&lt;/code&gt;라는 명령어로 흡수되었습니다.&lt;/p&gt;

&lt;p&gt;컨테이너 명령어를 실행하는 방법은 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker exec [OPTIONS] CONTAINER COMMAND [ARG...]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;run&lt;/code&gt; 명령어와 유사해 보입니다. 차이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;run&lt;/code&gt;은 새로 컨테이너를 만들어서 실행하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec&lt;/code&gt;는 실행중인 컨테이너에 명령어를 내리는 정도입니다.&lt;/p&gt;

&lt;p&gt;일단, 가볍게 실행중인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MySQL&lt;/code&gt; 컨테이너에 접속해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker &lt;span class=&quot;nb&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; mysql /bin/bash

&lt;span class=&quot;c&quot;&gt;# MySQL test&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;mysql &lt;span class=&quot;nt&quot;&gt;-uroot&lt;/span&gt;

mysql&amp;gt; show databases&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| wp                 |
+--------------------+
5 rows &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0.00 sec&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

mysql&amp;gt; quit
&lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-exec-bash.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;docker exec bash&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;키보드 입력이 필요하니 run 명령어와 마찬가지로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-it&lt;/code&gt; 옵션을 주었고 bash 쉘로 접속하여 마치 가상머신에 들어온 것 같은 느낌이 듭니다. 접속한 이후에는 어떤 작업도 할 수 있고 컨테이너를 마음껏 건드릴 수 있습니다.&lt;/p&gt;

&lt;p&gt;쉘로 완전한 권한을 얻는 방법말고 바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mysql&lt;/code&gt;명령어를 실행 할 수도 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker &lt;span class=&quot;nb&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; mysql mysql &lt;span class=&quot;nt&quot;&gt;-uroot&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# MySQL test&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;mysql &lt;span class=&quot;nt&quot;&gt;-uroot&lt;/span&gt;

mysql&amp;gt; show databases&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| wp                 |
+--------------------+
5 rows &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0.00 sec&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

mysql&amp;gt; quit
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-exec-mysql.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;docker exec mysql&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;이제, 호스트 OS에 mysql을 설치하지 않아도 mysql 클라이언트를 사용할 수 있습니다. 굳이 복잡한 작업이 필요 없는 경우는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-it&lt;/code&gt; 옵션없이 단순하게 명령을 실행하고 종료할 수도 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;컨테이너-업데이트&quot;&gt;컨테이너 업데이트&lt;/h2&gt;

&lt;p&gt;이제 지금까지 배운 모든걸 정리해서 컨테이너를 새로운 버전으로 업데이트 하는 과정을 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-2/container-update.png&quot; alt=&quot;도커 컨테이너 업데이트&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도커에서 컨테이너를 업데이트 하려면 새 버전의 이미지를 다운(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pull&lt;/code&gt;)받고 기존 컨테이너를 삭제(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stop&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rm&lt;/code&gt;) 한 후 새 이미지를 기반으로 새 컨테이너를 실행(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;run&lt;/code&gt;)하면 됩니다. 배포와 관련된 자세한 사항은 다음글에서 이야기하고 여기선 그냥 그렇구나 하고 이해합시다.&lt;/p&gt;

&lt;p&gt;컨테이너를 삭제한다는 건 컨테이너에서 생성된 파일이 사라진다는 뜻입니다. 데이터베이스라면 그동안 쌓였던 데이터가 모두 사라진다는 것이고 웹 어플리케이션이라면 그동안 사용자가 업로드한 이미지가 모두 사라진다는 것입니다. ㄷㄷ&lt;/p&gt;

&lt;p&gt;이런 상황&lt;del&gt;도커 도입했다가 퇴사&lt;/del&gt;을 방지하기 위해 컨테이너 삭제시 유지해야하는 데이터는 반드시 컨테이너 내부가 아닌 외부 스토리지에 저장해야 합니다. 가장 좋은 방법은 &lt;a href=&quot;http://docs.aws.amazon.com/ko_kr/AmazonS3/latest/dev/Welcome.html&quot;&gt;AWS S3&lt;/a&gt;같은 클라우드 서비스를 이용하는 것이고 그렇지 않으면 데이터 볼륨&lt;sub&gt;Data volumes&lt;/sub&gt;을 컨테이너에 추가해서 사용해야 합니다. 데이터 볼륨을 사용하면 해당 디렉토리는 컨테이너와 별도로 저장되고 컨테이너를 삭제해도 데이터가 지워지지 않습니다.&lt;/p&gt;

&lt;p&gt;데이터 볼륨을 사용하는 방법은 몇가지가 있는데 여기서는 호스트의 디렉토리를 마운트해서 사용하는 방법에 대해 알아봅니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;run&lt;/code&gt;명령어에서 소개한 옵션중에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-v&lt;/code&gt; 옵션을 드디어 사용해 보겠습니다. MySQL이라면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/var/lib/mysql&lt;/code&gt;디렉토리에 모든 데이터베이스 정보가 담기므로 호스트의 특정 디렉토리를 연결해주면 됩니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# before&lt;/span&gt;
docker run &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 3306:3306 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;MYSQL_ALLOW_EMPTY_PASSWORD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; mysql &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  mysql:5.7

&lt;span class=&quot;c&quot;&gt;# after&lt;/span&gt;
docker run &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 3306:3306 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;MYSQL_ALLOW_EMPTY_PASSWORD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; mysql &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; /my/own/datadir:/var/lib/mysql &lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;# &amp;lt;- volume mount&lt;/span&gt;
  mysql:5.7
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 샘플은 호스트의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/my/own/datadir&lt;/code&gt;디렉토리를 컨테이너의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/var/lib/mysql&lt;/code&gt;디렉토리로 마운트 하였습니다. 이제 데이터베이스 파일은 호스트의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/my/own/datadir&lt;/code&gt;디렉토리에 저장되고 컨테이너를 삭제해도 데이터는 사라지지 않습니다. 최신버전의 MySQL 이미지를 다운받고 다시 컨테이너를 실행할 때 동일한 디렉토리를 마운트 한다면 그대로 데이터를 사용할 수 있습니다. &lt;del&gt;만세!&lt;/del&gt;&lt;/p&gt;

&lt;h2 id=&quot;docker-compose&quot;&gt;Docker Compose&lt;/h2&gt;

&lt;p&gt;지금까지 도커를 커맨드라인에서 명령어로 작업했습니다. 지금은 간단한 작업만 했기 때문에 명령이 길지 않지만 컨테이너 조합이 많아지고 여러가지 설정이 추가되면 명령어가 금방 복잡해집니다.&lt;/p&gt;

&lt;p&gt;도커는 복잡한 설정을 쉽게 관리하기 위해 &lt;a href=&quot;https://en.wikipedia.org/wiki/YAML&quot;&gt;YAML&lt;/a&gt;방식의 설정파일을 이용한 &lt;a href=&quot;https://docs.docker.com/compose/&quot;&gt;Docker Compose&lt;/a&gt;라는 툴을 제공합니다. 깊게 파고들면 은근 기능이 많고 복잡한데 이번에는 아주 가볍게 다루고 지나가도록 하겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;설치하기&quot;&gt;설치하기&lt;/h3&gt;

&lt;p&gt;Docker for Mac 또는 Docker for Windows를 설치했다면 자동으로 설치됩니다. 리눅스의 경우 다음 명령어를 입력하여 설치합니다. 그냥 설치파일 하나 다운받으면 됩니다. &lt;del&gt;Golang 짱&lt;/del&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;curl &lt;span class=&quot;nt&quot;&gt;-L&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;https://github.com/docker/compose/releases/download/1.9.0/docker-compose-&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;uname&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;uname&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; /usr/local/bin/docker-compose
&lt;span class=&quot;nb&quot;&gt;chmod&lt;/span&gt; +x /usr/local/bin/docker-compose
&lt;span class=&quot;c&quot;&gt;# test&lt;/span&gt;
docker-compose version
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;wordpress-만들기&quot;&gt;wordpress 만들기&lt;/h3&gt;

&lt;p&gt;기존에 명령어로 만들었던 wordpress를 compose를 이용해 만들어 보겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 빈 디렉토리를 하나 만들고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker-compose.yml&lt;/code&gt;파일을 만들어 설정을 입력합니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;version: &amp;#39;2&amp;#39;

services:
   db:
     image: mysql:5.7
     volumes:
       - db_data:/var/lib/mysql
     restart: always
     environment:
       MYSQL_ROOT_PASSWORD: wordpress
       MYSQL_DATABASE: wordpress
       MYSQL_USER: wordpress
       MYSQL_PASSWORD: wordpress

   wordpress:
     depends_on:
       - db
     image: wordpress:latest
     volumes:
       - wp_data:/var/www/html
     ports:
       - &amp;quot;8000:80&amp;quot;
     restart: always
     environment:
       WORDPRESS_DB_HOST: db:3306
       WORDPRESS_DB_PASSWORD: wordpress
volumes:
    db_data:
    wp_data:&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/7c76c1a90e65606f5e5f55f83943eac2.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;몇몇 생소해보이는 설정이 눈에 보이지만, 일단 실행해 봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker-compose up
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-compose.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;docker-compose&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;와우, 아주 손쉽게 워드프레스가 만들어 졌습니다. 단지 명령어를 설정파일로 바꾼거에 불과하지만 가독성과 편리성은 훨씬 향상되었습니다.&lt;/p&gt;

&lt;p&gt;Docker Compose의 다른 기능과 생소한 설정내용은 숙제로 남겨드립니다. 원래 개발공부라는게 왠만큼 했다고 생각하면 또 다른게 나오고 끊임없이 공부해야 하는 분야입니다. &lt;del&gt;화이팅!&lt;/del&gt; 도커에 대해 이해를 했다면 Docker Compose 또한 쉽게 사용할 수 있을 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;

&lt;p&gt;여기까지 도커에 대해 기본적인 내용부터 컨테이너를 실행하고 살펴보는 방법까지 알아보았습니다. 도커가 어떤건지, 컨테이너가 뭔지, 이미지가 뭔지 감이 좀 오시나요? 이제 남이 만든 이미지를 사용하는 것이 아니라 직접 이미지를 만들고 컨테이너를 여러 서버로 배포하는 방법을 알아봐야하는데… 다음글에서 알아보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://bit.ly/inflearn-docker&quot;&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/inflearn.png&quot; alt=&quot;이제 도커안내서를 영상으로 만나보세요!&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/2017/01/19/docker-guide-for-beginners-1.html&quot;&gt;초보를 위한 도커 안내서 - 도커란 무엇인가?&lt;/a&gt; &lt;span class=&quot;series&quot;&gt;SERIES 1/3&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;초보를 위한 도커 안내서 - 설치하고 컨테이너 실행하기 ✓&lt;/strong&gt; &lt;span class=&quot;series&quot;&gt;SERIES 2/3&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2017/02/10/docker-guide-for-beginners-create-image-and-deploy.html&quot;&gt;초보를 위한 도커 안내서 - 이미지 만들고 배포하기&lt;/a&gt; &lt;span class=&quot;series&quot;&gt;SERIES 3/3&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
</description>
        <pubDate>Thu, 19 Jan 2017 00:00:00 +0900</pubDate>
        <link>https://subicura.com/2017/01/19/docker-guide-for-beginners-2.html</link>
        <guid isPermaLink="true">https://subicura.com/2017/01/19/docker-guide-for-beginners-2.html</guid>
        
        <category>Docker</category>
        
        <category>DevOps</category>
        
        <category>Server</category>
        
        <category>Container</category>
        
        
        <category>Docker</category>
        
      </item>
    
  </channel>
</rss>
